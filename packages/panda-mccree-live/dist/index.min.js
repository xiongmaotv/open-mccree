/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(e,o){"function"==typeof e.define&&e.define.amd?e.define(["PandaMccreeLive"],o):"object"===( false?"undefined":_typeof(exports))?module.exports=o(e.PandaMccreeLive):e.PandaMccreeLive=o(e.PandaMccreeLive),e.PandaMccreeLive=o(e.PandaMccreeLive)}("undefined"==typeof window?global:window,function(e){return e=__webpack_require__(1).default});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _classCallCheck(e,r){if(!(e instanceof r))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(e,r){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!r||"object"!=typeof r&&"function"!=typeof r?e:r}function _inherits(e,r){if("function"!=typeof r&&null!==r)throw new TypeError("Super expression must either be null or a function, not "+typeof r);e.prototype=Object.create(r&&r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),r&&(Object.setPrototypeOf?Object.setPrototypeOf(e,r):e.__proto__=r)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.PandaMccreeLive=void 0;var _createClass=function(){function e(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(r,t,o){return t&&e(r.prototype,t),o&&e(r,o),r}}(),_mccreeCore=__webpack_require__(2),_mccreeCore2=_interopRequireDefault(_mccreeCore),_mccreeLoaderFetch=__webpack_require__(9),_mccreeLoaderFetch2=_interopRequireDefault(_mccreeLoaderFetch),_mccreeLoaderMozXhr=__webpack_require__(11),_mccreeLoaderMozXhr2=_interopRequireDefault(_mccreeLoaderMozXhr),_mccreeHelperBrowser=__webpack_require__(12),_mccreeHelperBrowser2=_interopRequireDefault(_mccreeHelperBrowser),_mccreeDemuxerFlv=__webpack_require__(13),_mccreeDemuxerFlv2=_interopRequireDefault(_mccreeDemuxerFlv),_mccreeRemuxerHevc=__webpack_require__(20),_mccreeRemuxerHevc2=_interopRequireDefault(_mccreeRemuxerHevc),_mccreeRemuxerMp4live=__webpack_require__(24),_mccreeRemuxerMp4live2=_interopRequireDefault(_mccreeRemuxerMp4live),_mccreePluginMse=__webpack_require__(26),_mccreePluginMse2=_interopRequireDefault(_mccreePluginMse),_mccreePluginMseHevc=__webpack_require__(27),_mccreePluginMseHevc2=_interopRequireDefault(_mccreePluginMseHevc),PandaMccreeLive=exports.PandaMccreeLive=function(e){function r(e,t){_classCallCheck(this,r);var o=_mccreeHelperBrowser2.default.uaMatch(navigator.userAgent),i=null;i=o.mozilla?new _mccreeLoaderMozXhr2.default:new _mccreeLoaderFetch2.default;var n=new _mccreeDemuxerFlv2.default,c=null;c=t.useHEVC?new _mccreeRemuxerHevc2.default:new _mccreeRemuxerMp4live2.default,t=t||{},t.autoReload||(t.autoReload=6e3),t.loaderBufferLimit=t.loaderBufferLimit||5e7;var l=null;e.logger&&(l=e.logger);var a=_possibleConstructorReturn(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,{logger:l,loader:i,demux:n,remux:c},t));a.TAG="panda-mccree-live",a.logger.debug(a.TAG,"Live initialization");var u=a;return a.observer.on("METADATA_CHANGED",function(){u.reloading||u.reload.call(u)}),a.initStatistic(),a.version="1.1.1-0",a.logger.info(a.TAG,"Current version: "+a.version),a.config.useHEVC?a.mseController=new _mccreePluginMseHevc2.default:a.mseController=new _mccreePluginMse2.default,a.mseController.init(a),a.on=a.observer.on,a}return _inherits(r,e),_createClass(r,[{key:"isSupport",value:function(){return!0}},{key:"checkState",value:function(){this.reloading||this.mseController.checkState()}},{key:"clearBuffer",value:function(){this.mseController.clearBuffer()}},{key:"load",value:function(e){this.logger.info(this.TAG,"loadurl "+e),this.originUrl=e,this.loader.load(e)}},{key:"play",value:function(){this.mediaElement.play()}},{key:"destroy",value:function(){var e=this,r=this;this.logger.debug(r.TAG,"Live destroying"),this.off();var t=new Promise(function(t,o){clearInterval(r.statisticTimmer),r.statisticTimmer=null,r.unload().then(function(o){return e.mediaSource&&e.asourceBuffer&&e.vsourceBuffer?(r.mseController.destroy(),r.detachMedia(),e.media=null,r.cdnip=null,r.loader=null,r.remux=null,r.demux=null,r.logger.debug(r.TAG,"Live destroyed"),void t("destroyed")):void t("already destroyed")}).catch(function(e){t("destroyed")})});return t}},{key:"pause",value:function(){this.mseController.pause()}},{key:"reload",value:function(){var e=this.originUrl,r=this.getMediaElement(),t=this;return t.reloading=!0,new Promise(function(o,i){t.loader.unload().then(function(i){t.mseController.detachMediaElement(),t.media.tracks={},t.remuxBuffer={audio:[],video:[]},t.loaderBuffer.clear(),t.demux.reset(),t.remux.destroy(),t.mseController.removeSourceBuffer(),t.mseController.attachMediaElement(r),t.loader.load(e),t.reloading=!1,o()}).catch(function(e){t.reloading=!1,o()})})}},{key:"getMediaElement",value:function(){return this.mseController.mediaElement}},{key:"initStatistic",value:function(){this.loadbytes=0,this.droppedFrames=0,this.decodedFrames=0;var e=this;this.observer.on(this.events.events.FRAG_LOADED,function(r){e.loadbytes+=r}),this.observer.on("MEDIA_SEGMENT_REMUXED",function(r){r&&(e.decodedFrames+=r)}),this.observer.on("FRAME_DROPPED",function(r){r&&(e.droppedFrames+=r)}),this.statisticTimmer=setInterval(this._onStatistic.bind(this),1e3)}},{key:"_onStatistic",value:function(){try{this.statisticTimmer&&(this.observer.trigger("statistics_info",{droppedFrames:this.droppedFrames,decodedFrames:this.decodedFrames+this.droppedFrames,speed:Math.floor(this.loadbytes/1e3)}),this.loadbytes=0)}catch(e){}}},{key:"attachMediaElement",value:function(e){e&&this.mseController.attachMediaElement(e)}},{key:"recordStartTime",value:function(){this.startTime||(this.startTime=(new Date).getTime())}},{key:"detachMediaElement",value:function(){this.mseController.detachMediaElement()}}]),r}(_mccreeCore2.default);exports.default=PandaMccreeLive;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeHelperLogger = __webpack_require__(3);

	var _mccreeHelperLogger2 = _interopRequireDefault(_mccreeHelperLogger);

	var _events = __webpack_require__(4);

	var _events2 = _interopRequireDefault(_events);

	var _media = __webpack_require__(5);

	var _media2 = _interopRequireDefault(_media);

	var _events3 = __webpack_require__(6);

	var _events4 = _interopRequireDefault(_events3);

	var _mccreeCoreLoaderbuffer = __webpack_require__(7);

	var _mccreeCoreLoaderbuffer2 = _interopRequireDefault(_mccreeCoreLoaderbuffer);

	var _mccreeHelperUtils = __webpack_require__(8);

	var _mccreeHelperUtils2 = _interopRequireDefault(_mccreeHelperUtils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The main class to create an decoder.
	 */
	var Mccree = function () {
	  /**
	   * The constructor.
	   */
	  function Mccree(modules, config, plugins) {
	    _classCallCheck(this, Mccree);

	    if (!modules) {
	      modules = {};
	    }

	    this.TAG = 'Mccree-core';

	    this.config = config ? config : {};

	    this.debug = config && config.debug || false;

	    this.plugins = plugins || [];

	    this.url = null;

	    this.time = 0;

	    this.events = _events4.default;

	    this.logMsgs = _events4.default.logMsgs;

	    Object.assign(this.logMsgs, this.config.logMessages || {});

	    this._initLogger(modules.logger);

	    this.initObserver();

	    // Use default when options do not defined.
	    this.loaderBuffer = new _mccreeCoreLoaderbuffer2.default();
	    this.remuxBuffer = {};
	    this.initSegment = {};

	    this._createModules(modules);
	    this._initModules();

	    var media = new _media2.default();

	    this.attachMedia(media);
	  }

	  /**
	    * The function to destroy mccree.
	    */


	  _createClass(Mccree, [{
	    key: 'destroy',
	    value: function destroy() {
	      var _this = this;

	      // Destroy timer
	      clearInterval(this.timmer);
	      this.timmer = null;
	      return this.unload().then(function (res) {
	        _this.observer = null;
	        _this.detachMedia();
	        _this.media = null;
	        _this.logger.debug(_this.TAG, _this.logMsgs.DESTROY);
	      });
	    }

	    /**
	     * Use to attach the media profile.
	     */

	  }, {
	    key: 'attachMedia',
	    value: function attachMedia(media) {
	      this.detachMedia();
	      this.media = media;
	    }

	    /** 
	     * Use to detach the Media.
	     */

	  }, {
	    key: 'detachMedia',
	    value: function detachMedia() {
	      this.media = null;
	    }

	    /**
	     * Use to attach media element.
	     */

	  }, {
	    key: 'attachMediaElement',
	    value: function attachMediaElement(media) {
	      this.detachMedia();
	      this.mediaElement = media;
	    }

	    /** 
	     * Use to detach  the Media Element.
	     */

	  }, {
	    key: 'detachMediaElement',
	    value: function detachMediaElement() {
	      this.mediaElement = null;
	    }
	    /** 
	     * Load the resource.
	     *
	     * @param {string} url - The resource url.
	     */

	  }, {
	    key: 'load',
	    value: function load(url) {
	      this.logger.inf(this.TAG, 'loadurl ' + url);
	      this.originUrl = url;
	      this.loader.load(url);
	    }

	    /**
	     * Unload the resource.
	     */

	  }, {
	    key: 'unload',
	    value: function unload() {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this2.loader) {
	          _this2.logger.debug(_this2.TAG, _this2.logMsgs.UNLOADING);
	          _this2.loader.unload().then(function (res) {
	            resolve();
	          }).catch(function (res) {
	            reject(res);
	          });
	        } else {
	          resolve();
	        }
	      });
	    }

	    /**
	     * Initialize the logger for mccree.
	     * 
	     * @param {object} logger - The js object which has required functions for recording logs.
	     */

	  }, {
	    key: '_initLogger',
	    value: function _initLogger(logger) {
	      // init the logger;
	      if (logger && _mccreeHelperLogger2.default.isValid(logger)) {
	        this.logger = new _mccreeHelperLogger2.default(logger, false, this.debug);
	        this.logger.debug(this.TAG, this.logMsgs.INIT_LOGGER_CUSTOM);
	      } else {
	        this.logger = new _mccreeHelperLogger2.default(null, false, this.debug);
	        this.logger.debug(this.TAG, this.logMsgs.INIT_LOGGER_INTERNAL);
	      }
	    }

	    /**
	     * Initialize the eventemitter for the mccree.
	     */

	  }, {
	    key: 'initObserver',
	    value: function initObserver() {
	      // init eventEmitter;
	      var that = this;
	      this.observer = new _events2.default();

	      this.observer.trigger = function trigger(event) {
	        for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          data[_key - 1] = arguments[_key];
	        }

	        if (event !== 'error') {
	          var _that$observer;

	          (_that$observer = that.observer).emit.apply(_that$observer, [event].concat(data));
	        } else {
	          var _that$observer2;

	          (_that$observer2 = that.observer).emit.apply(_that$observer2, ['internalError'].concat(data));
	        }
	      };

	      this.observer.on = function on(event, listener) {
	        if (event !== 'error') {
	          that.observer.addListener(event, listener);
	        } else {
	          that.observer.addListener('internalError', listener);
	        }
	      };

	      this.observer.off = function off(event, cb) {
	        if (!cb) {
	          cb = function cb() {};
	        }
	        if (!event) {
	          that.observer.removeAllListeners();
	          cb();
	        } else if (event !== 'error') {
	          that.observer.removeListener(event, cb);
	        } else {
	          that.observer.removeListener('internalError', cb);
	        }
	      };

	      this.logger.debug(this.TAG, this.logMsgs.INIT_OBSERVER);

	      this.on = this.observer.on.bind(this.observer);
	      this.off = this.observer.off.bind(this.observer);
	      this.trigger = this.observer.trigger.bind(this.observer);
	    }

	    /**
	     * Load and check the loader, demux and remux modules for mccree.
	     *
	     * @params {Object} modules - The js object contains loader, demux and remux objects.
	     */

	  }, {
	    key: '_createModules',
	    value: function _createModules(modules) {
	      if (modules.loader) {
	        this.loader = modules.loader;
	        this.logger.debug(this.TAG, this.logMsgs.INIT_LOADER);
	      } else {
	        this.logger.error(this.TAG, this.logMsgs.INIT_LOADER_FAIL);
	      }

	      if (modules.demux) {
	        this.demux = modules.demux;
	        this.logger.debug(this.TAG, this.logMsgs.INIT_DEMUXER);
	      } else {
	        this.logger.error(this.TAG, this.logMsgs.INIT_DEMUXER_FAILED);
	      }

	      if (modules.remux) {
	        this.remux = modules.remux;
	        this.logger.debug(this.TAG, this.logMsgs.INIT_REMUXER);
	      } else {
	        this.logger.error(this.TAG, this.logMsgs.INIT_REMUXER_FAILED);
	      }
	    }

	    /**
	     * Call the init functions of loader, demux, remux.
	     */

	  }, {
	    key: '_initModules',
	    value: function _initModules() {
	      this.loader && this.loader.init(this);
	      this.demux && this.demux.init(this);
	      this.remux && this.remux.init(this);
	    }
	  }]);

	  return Mccree;
	}();

	exports.default = Mccree;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Logger = function () {
	  /**
	   * A class to manage logger.
	   * 
	   * @class Logger
	   * @param {Object} logger - The customer logger object. 
	   * @param {boolean} disable - If the logger is disabled by default 
	   */
	  function Logger(logger, disable, debuging) {
	    _classCallCheck(this, Logger);

	    this.disabled = disable;
	    this.debuging = debuging;
	    this._logger = logger;
	  }

	  /**
	   * The debug function, it will use window.console.debug() by default.
	   * Level 1
	   * 
	   * @param {string} tag - The tag string. 
	   * @param {string} message - The debug message.
	   */


	  _createClass(Logger, [{
	    key: 'debug',
	    value: function debug(tag, message) {

	      if (this.disabled) {
	        return;
	      }

	      if (!this.debuging) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.debug(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.debug('[' + time + '][' + tag + '] debug: ' + message);
	      }
	    }

	    /**
	     * The log function, it will use window.console.log() by default.
	     * Level 2
	     * 
	     * @param {string} tag - The tag string. 
	     * @param {string} message - The log message.
	     */

	  }, {
	    key: 'log',
	    value: function log(tag, message) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.log(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.log('[' + time + '][' + tag + '] log: ' + message);
	      }
	    }

	    /**
	     * The info function, it will use window.console.info() by default.
	     * Level 3
	     * 
	     * @param {string} tag - The tag string. 
	     * @param {string} message - The info message.
	     */

	  }, {
	    key: 'info',
	    value: function info(tag, message) {

	      if (this.disabled) {
	        return;
	      }
	      if (this._logger) {
	        this._logger.info(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.info('[' + time + '][' + tag + '] info: ' + message);
	      }
	    }
	  }, {
	    key: 'warn',
	    value: function warn(tag, message) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.warn(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.warn('[' + time + '][' + tag + '] warn: ' + message);
	      }
	    }

	    /**
	     * The error function, it will use window.console.error() by default.
	     * Level 4
	     * 
	     * @param {string} tag - The tag string. 
	     * @param {string} message - The error message.
	     */

	  }, {
	    key: 'error',
	    value: function error(tag, message) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.error(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.debug('[' + time + '][' + tag + '] error: ' + message);
	      }
	    }

	    /**
	     * The function to see if the customer logger is valid.
	     * 
	     * @return {boolean} -  If the logger is valid return true, otherwise return false. 
	     */

	  }], [{
	    key: 'isValid',
	    value: function isValid(logger) {
	      return !!logger && !!logger.info && !!logger.log && !!logger.debug && !!logger.error && !!logger.warn;
	    }
	  }]);

	  return Logger;
	}();

	exports.default = Logger;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';
	/**
	 * The data struct
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Media = function () {
	  /**
	   * Media include trucks and media informations.
	   * 
	   * @class Media
	   * @param {Object} mccree - mccree object. 
	   * @param {Object} tracks - tracks.
	   */
	  function Media(config, tracks) {
	    _classCallCheck(this, Media);

	    this.TAG = 'MccreeMedia';

	    this.config = config || {};

	    this.level = null;

	    this.tracks = tracks || {};

	    this.mediaInfo = {};
	    this.videoDuration = 0;
	    this.audioDuration = 0;
	  }

	  /**
	   * Initailize all tracks.
	   */


	  _createClass(Media, [{
	    key: 'initTracks',
	    value: function initTracks() {
	      for (var i = 0; i < this.tracks.length; i++) {
	        this.tracks[Object.keys(this.tracks)[i]].reset();
	      }
	    }
	    /**
	     * reset all tracks.
	     */

	  }, {
	    key: 'resetTracks',
	    value: function resetTracks() {
	      for (var i = 0; i < this.tracks.length; i++) {
	        this.tracks[Object.keys(this.tracks)[i]].reset();
	      }
	    }

	    /**
	     * get a track.
	     *
	     * @param {number} key - the key of track.
	     */

	  }, {
	    key: 'getTrack',
	    value: function getTrack(key) {
	      return this.tracks[key];
	    }

	    /**
	     * destory all tracks.
	     */

	  }, {
	    key: 'destoryTracks',
	    value: function destoryTracks() {
	      for (var i = 0; i < this.tracks.length; i++) {
	        this.tracks[Object.keys(this.tracks)[i]].destroy();
	      }
	    }
	  }]);

	  return Media;
	}();

	exports.default = Media;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ev = {
	  UNLOAD: 'unload',
	  DESTROY: 'destroy',

	  // mccree-core 
	  MEDIA_ATTACHING: 'mediaAttaching',
	  MEDIA_ATTACHED: 'mediaAttached',
	  MEDIA_DETACHING: 'mediaDetaching',
	  MEDIA_DETACHED: 'mediaDetached',

	  NOT_FOUND: 'notFound',
	  FORBIDDEN: 'forbidden',
	  CONNECTED: 'connected',
	  FRAG_LOADED: 'fragLoaded',
	  FRAG_PARSED: 'fragParsed',
	  FPS_DROP: 'fpsDrop',
	  BUFFER_APPENDING: 'bufferAppending',
	  BUFFER_APPENDED: 'bufferAppended',
	  BUFFER_EOS: 'bufferEos',
	  BUFFER_FLUSHING: 'bufferFlushing',
	  BUFFER_FLUSHED: 'bufferFlushed',

	  // demuxer
	  DEMUXER_MISSMATCH: 'demuxerMissmatch',
	  NO_MEDIA_ATTACHED: 'noMeidaAttached',

	  // remuxer
	  ERROR: 'error'
	};

	var errorTypes = {
	  NETWORK_ERROR: 'NetworkError',
	  MEDIA_ERROR: 'MediaError',
	  MUX_ERROR: 'MuxError',
	  OTHER_ERROR: 'OtherError'
	};

	var errorDetails = {
	  NOT_INITED: 'notInited',

	  NOT_FOUND: 'notFound',
	  FORBIDDEN: 'forbidden',
	  UNKNOWN: 'unknown',

	  DATA_LENGTH_MISSMATCH: 'dataLengthMissMatch'
	};

	var logMessages = {
	  NOT_INITED: 'This module is not init yet',

	  CONNECTED: 'Connected to the source',

	  //Error Messages
	  NOT_FOUND: 'The source is not founded',
	  FORBIDDEN: 'forbidden',
	  UNKNOWN: 'unknown',

	  DESTROY: 'Destroy mccree',
	  UNLOADING: 'Unloading',

	  INIT_OBSERVER: 'Observer initialized',

	  INIT_LOGGER_CUSTOM: 'Logger initialized, use the customer logger',
	  INIT_LOGGER_INTERNAL: 'Logger initialized, use the internal logger',

	  INIT_LOADER: 'Loader initialized',
	  INIT_LOADER_FAIL: 'Loader can not be initialized',

	  INIT_DEMUXER: 'Demuxer initialized',
	  INIT_DEMUXER_FAILED: 'Demuxer can not be initialized',

	  INIT_REMUXER: 'Remuxer initialized',
	  INIT_REMUXER_FAILED: 'Remuxer can not be initialized'
	};

	var events = {
	  events: ev,
	  errorTypes: errorTypes,
	  errorDetails: errorDetails,
	  logMsgs: logMessages
	};

	exports.default = events;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/**
	 * Copyright [2017] [Shanghai Panda Interactive Entertainment And Culture Company Limited]
	 * 
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * 
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var LoaderBuffer = function () {
	  /**
	   * A buffer to store loaded data.
	   * 
	   * @class LoaderBuffer
	   * @param {number} length - Optional the buffer size 
	   */
	  function LoaderBuffer(length) {
	    _classCallCheck(this, LoaderBuffer);

	    this.length = length ? length : 0;
	    this.array = [];
	    this.offset = 0;
	  }

	  /**
	   * The function to push data.
	   * 
	   * @param {number} data - The data to push into the buffer
	   */


	  _createClass(LoaderBuffer, [{
	    key: 'push',
	    value: function push(data) {
	      this.array.push(data);
	      this.length += data.byteLength;
	    }

	    /**
	     * The function to shift data.
	     * 
	     * @param {number} length - The size of shift.
	     */

	  }, {
	    key: 'shift',
	    value: function shift(length) {
	      if (this.array.length < 1) {
	        return new Uint8Array(0);
	      } else {
	        if (this.offset + length === this.array[0].length) {
	          var _ret = this.array[0].slice(this.offset, this.offset + length);
	          this.offset = 0;
	          this.array.shift();
	          this.length -= length;
	          return _ret;
	        }

	        if (this.offset + length < this.array[0].length) {
	          var _ret2 = this.array[0].slice(this.offset, this.offset + length);
	          this.offset += length;
	          this.length -= length;
	          return _ret2;
	        }

	        var ret = new Uint8Array(length);
	        var tmpoff = 0;
	        while (this.array.length > 0 && length > 0) {
	          if (this.offset + length < this.array[0].length) {
	            var tmp = this.array[0].slice(this.offset, this.offset + length);
	            ret.set(tmp, tmpoff);
	            this.offset += length;
	            this.length -= length;
	            length = 0;
	            break;
	          } else {
	            var templength = this.array[0].length - this.offset;
	            ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);
	            this.array.shift();
	            this.offset = 0;
	            tmpoff += templength;
	            this.length -= templength;
	            length -= templength;
	          }
	        }
	        return ret;
	      }
	    }

	    /**
	     * Function to clear the buffer.
	     */

	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.array = [];
	      this.length = 0;
	      this.offset = 0;
	    }

	    /**
	     * Function to shift one unit8Array.
	     */

	  }, {
	    key: 'shiftBuffer',
	    value: function shiftBuffer() {
	      if (this.array.length > 0) {
	        this.length -= this.array[0].length;
	        this.array.shift();
	        this.offset = 0;
	      }
	    }

	    /**
	     * Convert uint8 data to number.
	     * 
	     * @param {number} start - the start postion.
	     * @param {number} length - the length of data.
	     */

	  }, {
	    key: 'toInt',
	    value: function toInt(start, length) {
	      var retInt = 0;
	      var i = this.offset + start;
	      while (i < this.offset + length + start) {
	        if (i < this.array[0].length) {
	          retInt = retInt * 256 + this.array[0][i];
	        } else if (this.array[1]) {
	          retInt = retInt * 256 + this.array[1][i - this.array[0].length];
	        }

	        i++;
	      }
	      return retInt;
	    }
	  }]);

	  return LoaderBuffer;
	}();

	exports.default = LoaderBuffer;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	/**
	 * Copyright [2017] [Shanghai Panda Interactive Entertainment And Culture Company Limited]
	 * 
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * 
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Utils = exports.Utils = function () {
	  function Utils() {
	    _classCallCheck(this, Utils);
	  }

	  _createClass(Utils, null, [{
	    key: 'getUint',

	    /**
	     * returns a number which is equal to the input.
	     * 返回一个数字，值与输入的UInt8Array相等。
	     * 
	     * @param {Uint8array} uint8array - the Uint8array object.
	     *
	     * @return {Number} - the value of the input. 
	     */
	    value: function getUint(uint8array) {
	      var total = 0;
	      var i = 0;
	      while (i < uint8array.length) {
	        total = total * 256 + uint8array[i];
	        i++;
	      }

	      return total;
	    }

	    /**
	     * This function is called when loader intializing, must bind(this).
	     * 当loader初始化的时候进行调用。必须将this指向绑定。
	     * 
	     * @param {Object} mccree - the mccree core.
	     */

	  }, {
	    key: 'initMccree',
	    value: function initMccree(mccree) {
	      if (!mccree) {
	        throw new Error('mccree is not defined');
	      }
	      if (!mccree.events) {
	        throw new Error('mccree events is not defined');
	      }
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events.events;
	      this.errorTypes = mccree.events.errorTypes;
	      this.errorDetails = mccree.events.errorDetails;
	      this.logMsgs = mccree.events.logMsgs;
	    }

	    /**
	     * The first object will be extend by the following objects.
	     * 将第一个对象，根据后传入的对象进行扩展。
	     * 
	     * @param {Object} objects - one or more objects.
	     */

	  }, {
	    key: 'extend',
	    value: function extend() {
	      for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {
	        objects[_key] = arguments[_key];
	      }

	      if (objects.length < 1) {
	        return;
	      }

	      for (var i = 1, len = objects.length; i < len; i++) {
	        var objectKeys = Object.keys(objects[i]);
	        for (var j = 0, length = objectKeys.length; j < length; j++) {
	          objects[0][objectKeys[j]] = objects[i][objectKeys[j]];
	        }
	      }
	    }
	  }]);

	  return Utils;
	}();

	exports.default = Utils;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeControllerLoader = __webpack_require__(10);

	var _mccreeControllerLoader2 = _interopRequireDefault(_mccreeControllerLoader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FetchLoader = function () {
	  _createClass(FetchLoader, null, [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return !!(self.fetch && self.ReadableStream && Uint8Array);
	    }

	    /**
	     * @constructs
	     *
	     * @param {Object} configs - configs (optional) 设置（可选）。
	     */

	  }]);

	  function FetchLoader(configs) {
	    _classCallCheck(this, FetchLoader);

	    this.TAG = 'Mccree-loader-fetch';
	    this.type = 'loader';
	    this.configs = configs || {};

	    this.status = 0;
	    this.error = null;
	    this._reader = null;
	  }

	  /**
	   * This function is called when loader intializing.
	   * 当loader初始化的时候进行调用。
	   * 
	   * @param {Object} mccree - the mccree core. 麦克雷内核对象。
	   */


	  _createClass(FetchLoader, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.controller = new _mccreeControllerLoader2.default(this);
	      this.controller.init.call(this, mccree);
	    }

	    /**
	     * This function is to load video stream from a source address.
	     * 拉取整段视频流。
	     *
	     * @param {String} source - the source address. 拉流地址。
	     * @param {String} opt - the fetch options. fetch接口拉流属性。
	     * @param {String} range - the stream range. 流片段区间。
	     */

	  }, {
	    key: 'load',
	    value: function load(source, opt, range) {
	      // unload if the loader is loading data.
	      // 如果loader正在获取数据，先进行unload操作。
	      // Declear condition to improve preformance.
	      // 声明清楚执行条件，以提高执行效率。
	      if (this.loading === true) {
	        this.unload();
	      }

	      // clear the loader buffer
	      // 清空loaderbuffer。
	      this.mccree.loaderBuffer.clear();
	      this.loadPartail(source, {
	        start: -1,
	        end: -1
	      }, opt);
	    }

	    /**
	     * This function is to load video stream partially from a source address.
	     * 拉取部分视频流。
	     *
	     * @param {String} source - the source address. 拉流地址。
	     * @param {String} opt - the fetch options. fetch接口拉流属性。
	     * @param {String} range - the stream range. 流片段区间。
	     */

	  }, {
	    key: 'loadPartail',
	    value: function loadPartail(source, range, opts) {
	      // Declear condition to improve preformance.
	      // 声明清楚执行条件，以提高执行效率。
	      if (this.mccree === undefined) {
	        this.logger.warn(this.TAG, 'Live is not init yet');
	        return;
	      }

	      this.source = source;

	      var params = this._getParams(range, opts);
	      var fetchPromise = self.fetch(source, params);
	      var that = this;
	      // fetch is returns a promise in Browsers. resolve when connected or error occured.
	      // fetch 返回一个Promise。当拉到流或异常时释放
	      fetchPromise.then(function (response) {
	        that._status = response.status;
	        that.loading = true;
	        return that._onFetchResponse.call(that, response);
	      }).catch(this._onFetchException.bind(this));
	    }

	    /**
	     * Unload from the current source.
	     * 从当前视频源断流。
	     * 
	     * @return {Promise} - Resolve when disconnected. 断链时释放。
	     */

	  }, {
	    key: 'unload',
	    value: function unload() {
	      var _this = this;

	      var that = this;
	      return new Promise(function (resolve, reject) {
	        if (!that.loading) {
	          resolve();
	        }
	        that.loading = false;
	        that.mccree.loaderBuffer.clear();

	        // declear conditions to improve proformance.
	        // 声明清楚条件，有助于提高执行效率
	        if (that._reader !== undefined) {
	          that._reader.cancel().then(function () {
	            that.loading = false;
	            resolve();
	          });
	        } else {
	          that.loading = false;
	          resolve();
	        }

	        _this.destroyResolve = resolve;
	      });
	    }

	    /**
	     * Construct fetch params.
	     * 构造fetch参数。
	     *
	     * @param {String} opt - the fetch options. fetch接口拉流属性。
	     * @param {String} range - the stream range. 流片段区间。
	     */

	  }, {
	    key: '_getParams',
	    value: function _getParams(range, opts) {
	      var options = opts || {};
	      var headers = new self.Headers();

	      var params = {
	        method: 'GET',
	        headers: headers,
	        mode: 'cors',
	        cache: 'default'
	      };

	      // add custmor headers
	      // 添加自定义头
	      if (_typeof(this.configs.headers) === 'object') {
	        var configHeaders = this.configs.headers;
	        for (var key in configHeaders) {
	          if (configHeaders.hasOwnProperty(key)) {
	            headers.append(key, configHeaders[key]);
	          }
	        }
	      }

	      if (options.cors === false) {
	        params.mode = 'same-origin';
	      }

	      // withCredentials is disabled by default
	      // withCredentials 在默认情况下不被使用。
	      if (options.withCredentials) {
	        params.credentials = 'include';
	      }

	      return params;
	    }

	    /**
	     * Called when fetch has a response.
	     * fetch返回时的回调。
	     *
	     * @param {Object} response - the response. 返回。
	     */

	  }, {
	    key: '_onFetchResponse',
	    value: function _onFetchResponse(response) {
	      this.mccree.url = response.url || this.mccree.url;
	      if (response.ok === true) {
	        this.controller.onConnected.call(this, response);
	        return this._onReader.call(this, response.body.getReader());
	      } else if (response.status == 404) {
	        this.controller.onNotfound.call(this, response);
	      } else if (response.status == 403) {
	        this.controller.onForbidden.call(this, response);
	      } else {
	        this.controller.onUnknownError.call(this, response);
	      }
	    }

	    /**
	     * Called when catches excptions.
	     * 发生异常时的回调。
	     *
	     * @param {Object} error - the error. 错误对象。
	     */

	  }, {
	    key: '_onFetchException',
	    value: function _onFetchException(error) {
	      this.logger.error(this.TAG, this.logMsgs.UNKNOWN);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, error);
	      return;
	    }

	    /**
	     * The data pumper.
	     * 数据泵。
	     *
	     * @param {Object} reader - the reader. reader对象。
	     */

	  }, {
	    key: '_onReader',
	    value: function _onReader(reader) {
	      this._reader = reader;
	      if (this.loading === false) {
	        return;
	      }

	      var that = this;
	      // reader read function returns a Promise. get data when callback and has value.done when disconnected.
	      // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。
	      this._reader && this._reader.read().then(function (val) {
	        // IMPORTANT: declear conditions to improve proformance.
	        // 重要：声明清楚条件，有助于提高执行效率
	        if (that !== undefined && val.done === true) {
	          that.loading = false;
	          that.logger.debug(that.TAG, 'Loading Finished');
	          if (that.destroyResolve !== undefined) {
	            that.destroyResolve();
	            that.destroyResolve = undefined;
	          } else {
	            that.observer.trigger('error', that.errorTypes.NETWORK_ERROR, that.errorDetails.NOT_FOUND);
	          }

	          return;
	        }

	        that.mccree.loaderBuffer.push(val.value);
	        that.observer.trigger(that.events.FRAG_LOADED, val.value.byteLength);
	        return that._onReader(reader);
	      }).catch(function (error) {
	        that.observer.trigger('error', that.errorTypes.NETWORK_ERROR, error.message);
	      });
	    }
	  }]);

	  return FetchLoader;
	}();

	exports.default = FetchLoader;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * This class is to provide a controller for loaders.
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var LoaderController = function () {
	  /**
	   * @constructs
	   */
	  function LoaderController(loader) {
	    _classCallCheck(this, LoaderController);

	    this.loader = loader;
	    this.loader.loading = false;
	    this.loader.connected = false;

	    this.loader.source = null;
	    this.loader.responseUrl = null;
	    this.loader.cdnip = null;
	  }

	  /**
	   * This function is called when loader intializing, must bind(this).
	   * 当loader初始化的时候进行调用。必须将this指向绑定。
	   * 
	   * @param {Object} mccree - the mccree core.
	   */


	  _createClass(LoaderController, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events.events;
	      this.errorTypes = mccree.events.errorTypes;
	      this.errorDetails = mccree.events.errorDetails;
	      this.logMsgs = mccree.events.logMsgs;
	    }

	    /**
	     * This function is called when connected.
	     */

	  }, {
	    key: 'onConnected',
	    value: function onConnected() {
	      if (!this.connected) {
	        this.logger.debug(this.TAG, this.logMsgs.CONNECTED);
	      }
	      this.connected = true;
	    }

	    /**
	     * This function is called when data loaded.
	     *
	     * @param {data} the server response.
	     */

	  }, {
	    key: 'onLoadData',
	    value: function onLoadData(data) {
	      this.connected = true;
	      this.loading = true;
	      this.observer.trigger(this.events.FRAG_LOADED, data);
	    }

	    /**
	     * This function is called when the resource is not found.
	     *
	     * @param {response} the server response.
	     */

	  }, {
	    key: 'onNotfound',
	    value: function onNotfound(response) {
	      this.connected = false;
	      this.loading = false;
	      this.logger.error(this.TAG, this.logMsgs.NOT_FOUND);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, this.errorDetails.NOTFOUND, response);
	    }

	    /**
	     * This function is called when return forbidden.
	     *
	     * @param {response} the server response.
	     */

	  }, {
	    key: 'onForbidden',
	    value: function onForbidden(response) {
	      this.connected = false;
	      this.loading = false;
	      this.logger.error(this.TAG, this.logMsgs.FORBIDDEN);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, this.errorDetails.NOTFOUND, response);
	    }
	    /**
	     * This function is called when can not conneced.
	     *
	     * @param {response} the server response.
	     */

	  }, {
	    key: 'onUnknownError',
	    value: function onUnknownError(response) {
	      this.connected = false;
	      this.loading = false;
	      this.logger.error(this.loader.TAG, this.logMsgs.NOT_FOUND);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, this.errorDetails.NOTFOUND, response);
	    }
	  }]);

	  return LoaderController;
	}();

	exports.default = LoaderController;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeControllerLoader = __webpack_require__(10);

	var _mccreeControllerLoader2 = _interopRequireDefault(_mccreeControllerLoader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MozXhrLoader = function () {
	  _createClass(MozXhrLoader, null, [{
	    key: 'isSupported',
	    value: function isSupported() {}
	  }]);

	  function MozXhrLoader(config) {
	    _classCallCheck(this, MozXhrLoader);

	    this.TAG = 'Mccree-loader-moz-xhr';
	    this.type = 'loader';
	    this.config = config || {};
	  }

	  _createClass(MozXhrLoader, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.controller = new _mccreeControllerLoader2.default(this);
	      this.controller.init.call(this, mccree);
	    }
	  }, {
	    key: 'load',
	    value: function load(source, opt) {
	      this._cleanLoaderBuffer();
	      this.loadPartail(source, {
	        start: -1,
	        end: -1
	      }, opt);
	    }
	  }, {
	    key: 'loadPartail',
	    value: function loadPartail(source, range, opts) {
	      var _this = this;

	      if (!this.mccree) {
	        this.logger.warn(this.TAG, 'Live is not init yet');
	        return;
	      }

	      this.source = source;
	      this._loading = false;

	      this.xhr = new XMLHttpRequest();
	      var that = this;
	      this.xhr.open("get", source, true);
	      this.xhr.responseType = 'moz-chunked-arraybuffer';
	      this.xhr.onreadystatechange = function (e) {
	        if (_this.status === 200) {
	          that.controller.onConnected.call(that, e);
	        } else if (_this.status === 404) {
	          that.controller.onNotfound.call(that, e);
	        }
	      };
	      this.xhr.onprogress = function (e) {
	        that.mccree.url = _this.xhr.response.url || that.mccree.url;
	        var chunk = e.target.response;
	        that.mccree.loaderBuffer.push(new Uint8Array(chunk));
	        that.observer.trigger(that.events.FRAG_LOADED, chunk.byteLength);
	      };
	      this.xhr.send();
	    }
	  }, {
	    key: 'unload',
	    value: function unload() {
	      var _this2 = this;

	      var that = this;
	      return new Promise(function (resolve, reject) {
	        that._loading = false;
	        that._cleanLoaderBuffer();
	        _this2.xhr.onprogress = null;
	        _this2.xhr.abort();
	        resolve();
	      });
	    }
	  }, {
	    key: '_cleanLoaderBuffer',
	    value: function _cleanLoaderBuffer() {
	      this.mccree.loaderBuffer.clear();
	    }
	  }]);

	  return MozXhrLoader;
	}();

	window.MozXhrLoader = MozXhrLoader;
	exports.default = MozXhrLoader;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Browser = function () {
	  function Browser() {
	    _classCallCheck(this, Browser);
	  }

	  _createClass(Browser, null, [{
	    key: "uaMatch",
	    value: function uaMatch(ua) {
	      // If an UA is not provided, default to the current browser UA.
	      if (ua === undefined) {
	        ua = window.navigator.userAgent;
	      }
	      ua = ua.toLowerCase();

	      var match = /(edge)\/([\w.]+)/.exec(ua) || /(opr)[\/]([\w.]+)/.exec(ua) || /(chrome)[ \/]([\w.]+)/.exec(ua) || /(iemobile)[\/]([\w.]+)/.exec(ua) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];

	      var platform_match = /(ipad)/.exec(ua) || /(ipod)/.exec(ua) || /(windows phone)/.exec(ua) || /(iphone)/.exec(ua) || /(kindle)/.exec(ua) || /(silk)/.exec(ua) || /(android)/.exec(ua) || /(win)/.exec(ua) || /(mac)/.exec(ua) || /(linux)/.exec(ua) || /(cros)/.exec(ua) || /(playbook)/.exec(ua) || /(bb)/.exec(ua) || /(blackberry)/.exec(ua) || [];

	      var browser = {},
	          matched = {
	        browser: match[5] || match[3] || match[1] || "",
	        version: match[2] || match[4] || "0",
	        versionNumber: match[4] || match[2] || "0",
	        platform: platform_match[0] || ""
	      };

	      if (matched.browser) {
	        browser[matched.browser] = true;
	        browser.version = matched.version;
	        browser.versionNumber = parseInt(matched.versionNumber, 10);
	      }

	      if (matched.platform) {
	        browser[matched.platform] = true;
	      }

	      // These are all considered mobile platforms, meaning they run a mobile browser
	      if (browser.android || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser["windows phone"]) {
	        browser.mobile = true;
	      }

	      // These are all considered desktop platforms, meaning they run a desktop browser
	      if (browser.cros || browser.mac || browser.linux || browser.win) {
	        browser.desktop = true;
	      }

	      // Chrome, Opera 15+ and Safari are webkit based browsers
	      if (browser.chrome || browser.opr || browser.safari) {
	        browser.webkit = true;
	      }

	      // IE11 has a new token so we will assign it msie to avoid breaking changes
	      if (browser.rv || browser.iemobile) {
	        var ie = "msie";

	        matched.browser = ie;
	        browser[ie] = true;
	      }

	      // Edge is officially known as Microsoft Edge, so rewrite the key to match
	      if (browser.edge) {
	        delete browser.edge;
	        var msedge = "msedge";

	        matched.browser = msedge;
	        browser[msedge] = true;
	      }

	      // Blackberry browsers are marked as Safari on BlackBerry
	      if (browser.safari && browser.blackberry) {
	        var blackberry = "blackberry";

	        matched.browser = blackberry;
	        browser[blackberry] = true;
	      }

	      // Playbook browsers are marked as Safari on Playbook
	      if (browser.safari && browser.playbook) {
	        var playbook = "playbook";

	        matched.browser = playbook;
	        browser[playbook] = true;
	      }

	      // BB10 is a newer OS version of BlackBerry
	      if (browser.bb) {
	        var bb = "blackberry";

	        matched.browser = bb;
	        browser[bb] = true;
	      }

	      // Opera 15+ are identified as opr
	      if (browser.opr) {
	        var opera = "opera";

	        matched.browser = opera;
	        browser[opera] = true;
	      }

	      // Stock Android browsers are marked as Safari on Android.
	      if (browser.safari && browser.android) {
	        var android = "android";

	        matched.browser = android;
	        browser[android] = true;
	      }

	      // Kindle browsers are marked as Safari on Kindle
	      if (browser.safari && browser.kindle) {
	        var kindle = "kindle";

	        matched.browser = kindle;
	        browser[kindle] = true;
	      }

	      // Kindle Silk browsers are marked as Safari on Kindle
	      if (browser.safari && browser.silk) {
	        var silk = "silk";

	        matched.browser = silk;
	        browser[silk] = true;
	      }

	      // Assign the name and platform variable
	      browser.name = matched.browser;
	      browser.platform = matched.platform;
	      return browser;
	    }
	  }]);

	  return Browser;
	}();

	exports.default = Browser;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeCoreTrack = __webpack_require__(14);

	var _mccreeHelperSpsparser = __webpack_require__(15);

	var _mccreeHelperSpsparser2 = _interopRequireDefault(_mccreeHelperSpsparser);

	var _defaultVideoConfig = __webpack_require__(17);

	var _defaultVideoConfig2 = _interopRequireDefault(_defaultVideoConfig);

	var _defaultAudioConfig = __webpack_require__(18);

	var _defaultAudioConfig2 = _interopRequireDefault(_defaultAudioConfig);

	var _amfParser = __webpack_require__(19);

	var _amfParser2 = _interopRequireDefault(_amfParser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FLVDemuxer = function () {
	  /**
	   * Constructor
	   */
	  function FLVDemuxer(config) {
	    _classCallCheck(this, FLVDemuxer);

	    this.TAG = 'mccree-demuxer-flv:index';
	    this.type = 'demuxer';
	    this._isFlv = false;
	    this._config = config || {};
	    this._firstFragLoaded = false;
	    this._hasScript = false;
	    this._hasAudioSequence = false;
	    this._hasVideoSequence = false;
	    this._tracknum = 0;
	  }

	  _createClass(FLVDemuxer, [{
	    key: 'reset',
	    value: function reset() {
	      this._isReseting = true;
	      this._isFlv = false;
	      this._firstFragLoaded = false;
	      this._hasScript = false;
	      this._hasAudioSequence = false;
	      this._hasVideoSequence = false;
	      this._tracknum = 0;
	    }

	    /**
	     * Initailize the demux module.
	     */

	  }, {
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events.events;
	      this.errorTypes = mccree.events.errorTypes;
	      this.errorDetails = mccree.events.errorDetails;
	      this.logMsgs = mccree.events.logMsgs;
	      this.observer.on(this.events.FRAG_LOADED, this._fragLoaded.bind(this));
	    }

	    /**
	     * Analyse and appand data when the fragment data is arrival.
	     */

	  }, {
	    key: '_fragLoaded',
	    value: function _fragLoaded() {
	      if (!this._firstFragLoaded) {
	        if (this.mccree.loaderBuffer.length < 13) {
	          return;
	        }
	        var playType = this._config.playType;
	        var data = this.mccree.loaderBuffer.shift(13);
	        this._parseFlvHeader(data, playType);
	        this._fragLoaded();
	      } else {
	        if (this.mccree.loaderBuffer.length < 11) {
	          return;
	        }
	        var chunk = this._parseFlvTag();
	        if (chunk) {
	          if (chunk !== -1) {
	            this.logger.error(this.TAG, 'chunk error');
	          }
	          this._fragLoaded();
	        }
	      }
	    }

	    /**
	     * Parse the flv header.
	     */

	  }, {
	    key: '_parseFlvHeader',
	    value: function _parseFlvHeader(data, playType) {
	      var offset = 0;
	      if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {
	        this.observer.trigger(this.events.demux.DEMUXER_MISSMATCH, data);
	        this._fragLoaded();
	      } else {
	        this._firstFragLoaded = true;
	        offset += 4;
	        var trackInfo = this._switchPlayType(data[offset], playType);
	        if (trackInfo & 0x01 > 0) {
	          this._tracknum++;
	          var videoTrack = new _mccreeCoreTrack.VideoTrack();
	          this.mccree.media.tracks.videoTrack = videoTrack;
	          this._setDefaultVideoConfig();
	        }

	        if (trackInfo & 0x04 > 0) {
	          this._tracknum++;
	          var audioTrack = new _mccreeCoreTrack.AudioTrack();
	          this.mccree.media.tracks.audioTrack = audioTrack;
	          this._setDefaultAudioConfig();
	        }
	        this._fragLoaded();
	      }
	    }

	    /**
	     * If the stream has audio or video. 
	     * @param {numeber} streamFlag - Data from the stream which is define whether the audio / video track is exist. 
	     * @param {String} playType - Defined by the customer. Optional. 
	     */

	  }, {
	    key: '_switchPlayType',
	    value: function _switchPlayType(streamFlag, playType) {
	      var trackInfo = 0x05;
	      switch (playType) {
	        case 'audio':
	          trackInfo = 0x04;
	          break;
	        case 'video':
	          trackInfo = 0x05;
	          break;
	        default:
	          streamFlag ? trackInfo = streamFlag : trackInfo = 0x05;
	          break;
	      }
	      return trackInfo;
	    }

	    /** 
	     * Set the default video configurations. 
	     */

	  }, {
	    key: '_setDefaultVideoConfig',
	    value: function _setDefaultVideoConfig() {
	      var videoTrack = this.mccree.media.tracks.videoTrack;
	      videoTrack.meta = _defaultVideoConfig2.default;
	      videoTrack.id = videoTrack.meta.id = this._tracknum;
	    }

	    /** 
	     * Set the default video configurations. 
	     */

	  }, {
	    key: '_setDefaultAudioConfig',
	    value: function _setDefaultAudioConfig() {
	      var audioTrack = this.mccree.media.tracks.audioTrack;
	      audioTrack.meta = _defaultAudioConfig2.default;
	      audioTrack.id = audioTrack.meta.id = this._tracknum;
	    }

	    /**
	     * Package the data as the following data structure
	     * {
	     *    data: Uint8Array. the Stream data.
	     *    info: The first byte info of the Tag.
	     *    tagType: 8、9、18
	     *    timeStamp: the timestemp;
	     * }
	     */

	  }, {
	    key: '_parseFlvTag',
	    value: function _parseFlvTag() {
	      if (this.mccree.loaderBuffer.length < 11) {
	        return null;
	      }
	      var chunk = this._parseFlvTagHeader();
	      if (chunk) {
	        this._processChunk(chunk);
	      }
	    }

	    /** 
	     * Parse the 11 byte tag Header
	     */

	  }, {
	    key: '_parseFlvTagHeader',
	    value: function _parseFlvTagHeader() {
	      var chunk = {};
	      var tagType = this.mccree.loaderBuffer.toInt(0, 1);

	      // 2 bit FMS reserved, 1 bit filtered, 5 bit tag type
	      chunk.filtered = (tagType & 32) >>> 5;
	      chunk.tagType = tagType & 31;

	      // 3 Byte datasize
	      chunk.datasize = this.mccree.loaderBuffer.toInt(1, 3);
	      if (chunk.tagType !== 8 && chunk.tagType !== 9 && chunk.tagType !== 11 && chunk.tagType !== 18 || this.mccree.loaderBuffer.toInt(8, 3) !== 0) {
	        if (this.loaderBuffer && this.loaderBuffer.length > 0) {
	          this.loaderBuffer.shift(1);
	        }
	        this.logger.warn(this.TAG, 'tagType ' + chunk.tagType);
	        return null;
	      }

	      if (this.mccree.loaderBuffer.length < chunk.datasize + 15) {
	        return null;
	      }

	      // read the data.
	      this.mccree.loaderBuffer.shift(4);

	      // 3 Byte timestamp
	      var timestamp = this.mccree.loaderBuffer.toInt(0, 3);
	      this.mccree.loaderBuffer.shift(3);

	      // 1 Byte timestampExt
	      var timestampExt = this.mccree.loaderBuffer.shift(1)[0];
	      if (timestampExt > 0) {
	        timestamp += timestampExt * 0x1000000;
	      }

	      chunk.timestamp = timestamp;

	      // streamId 
	      this.mccree.loaderBuffer.shift(3);
	      return chunk;
	    }
	  }, {
	    key: '_processChunk',
	    value: function _processChunk(chunk) {
	      switch (chunk.tagType) {
	        case 18:
	          this._parseScriptData(chunk);
	          break;
	        case 8:
	          this._parseAACData(chunk);
	          break;
	        case 9:
	          this._parseAVCData(chunk);
	          break;
	        case 11:
	          // for some CDN that did not process the currect RTMP messages
	          this.mccree.loaderBuffer.shift(3);
	          break;
	        default:
	          this.mccree.loaderBuffer.shift(1);
	          break;
	      }
	      this._fragLoaded();
	    }
	  }, {
	    key: '_clearBuffer',
	    value: function _clearBuffer() {
	      this.logger.debug(this.TAG, 'Cache clear');
	    }
	  }, {
	    key: '_parseScriptData',
	    value: function _parseScriptData(chunk) {
	      var audioTrack = this.mccree.media.tracks.audioTrack;
	      var videoTrack = this.mccree.media.tracks.videoTrack;

	      var data = this.mccree.loaderBuffer.shift(chunk.datasize);
	      var mediaInfo = this.mccree.media.mediaInfo = new _amfParser2.default(data).parseMetadata();
	      var validate = this._datasizeValidator(chunk.datasize);
	      if (validate) {
	        this._hasScript = true;
	      }

	      // Edit default meta.
	      if (audioTrack && !audioTrack.hasSpecificConfig) {
	        var meta = audioTrack.meta;
	        if (mediaInfo.audiosamplerate) {
	          meta.audioSampleRate = mediaInfo.audiosamplerate;
	        }

	        if (mediaInfo.audiochannels) {
	          meta.channelCount = mediaInfo.audiochannels;
	        }

	        switch (mediaInfo.audiosamplerate) {
	          case 44100:
	            meta.sampleRateIndex = 4;
	            break;
	          case 22050:
	            meta.sampleRateIndex = 7;
	            break;
	          case 11025:
	            meta.sampleRateIndex = 10;
	            break;
	        }
	      }
	      if (videoTrack && !videoTrack.hasSpecificConfig) {
	        var _meta = videoTrack.meta;
	        if (typeof mediaInfo.framerate === 'number') {
	          var fps_num = Math.floor(mediaInfo.framerate * 1000);
	          if (fps_num > 0) {
	            var fps = fps_num / 1000;
	            if (!_meta.frameRate) {
	              _meta.frameRate = {};
	            }
	            _meta.frameRate.fixed = true;
	            _meta.frameRate.fps = fps;
	            _meta.frameRate.fps_num = fps_num;
	            _meta.frameRate.fps_den = 1000;
	          }
	        }
	      }
	    }
	  }, {
	    key: '_parseAACData',
	    value: function _parseAACData(chunk) {
	      var track = this.mccree.media.tracks.audioTrack;
	      if (!track) {
	        return;
	      }

	      var meta = track.meta;

	      if (!meta) {
	        meta = _defaultAudioConfig2.default;
	      }

	      var info = this.mccree.loaderBuffer.shift(1)[0];

	      chunk.data = this.mccree.loaderBuffer.shift(chunk.datasize - 1);

	      var format = (info & 240) >>> 4;

	      track.format = format;

	      if (format !== 10) {
	        this.observer.trigger('error', this.mccree.events.MEDIA_ERROR, {});
	      }

	      if (format === 10 && !this._hasAudioSequence) {
	        meta.audioSampleRate = this._switchAudioSamplingFrequency(info);
	        meta.sampleRateIndex = (info & 12) >>> 2;
	        meta.frameLenth = (info & 2) >>> 1;
	        meta.channelCount = info & 1;
	        meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);
	      }

	      var audioSampleRate = meta.audioSampleRate;
	      var audioSampleRateIndex = meta.sampleRateIndex;
	      var refSampleDuration = meta.refSampleDuration;

	      delete chunk.tagType;
	      var validate = this._datasizeValidator(chunk.datasize);

	      if (chunk.data[0] === 0) {
	        var ret = this._aacSequenceHeaderParser(chunk.data);
	        audioSampleRate = ret.audiosamplerate || meta.audioSampleRate;
	        audioSampleRateIndex = ret.sampleRateIndex || meta.sampleRateIndex;
	        refSampleDuration = Math.floor(1024 / audioSampleRate * meta.timescale);
	        meta.channelCount = ret.channelCount;
	        meta.audioSampleRate = audioSampleRate;
	        meta.sampleRateIndex = audioSampleRateIndex;
	        meta.refSampleDuration = refSampleDuration;
	        if (this._hasScript && !this._hasAudioSequence && (!this.mccree.media.tracks.videoTrack || this._hasVideoSequence)) {
	          this.observer.trigger('METADATA_PARSED');
	        } else if (this._hasScript && this._hasAudioSequence) {
	          this.observer.trigger('METADATA_CHANGED');
	        }
	        ;
	        this._hasAudioSequence = true;
	      } else {
	        chunk.data = chunk.data.slice(1, chunk.data.length);
	        this.observer.trigger('AUDIODATA_PARSED');
	        track.samples.push(chunk);
	      }

	      if (!validate) {
	        this.logger.warn(this.TAG, 'TAG length error at ' + chunk.datasize);
	      }
	    }
	  }, {
	    key: '_parseHevcData',
	    value: function _parseHevcData(chunk) {
	      // header
	      var info = this.mccree.loaderBuffer.shift(1)[0];
	      chunk.frameType = (info & 0xf0) >>> 4;
	      var tempCodecID = this.mccree.media.tracks.videoTrack.codecID;
	      var codecID = info & 0x0f;
	      this.mccree.media.tracks.videoTrack.codecID = codecID;

	      //hevc和avc的header解析方式一样
	      chunk.avcPacketType = this.mccree.loaderBuffer.shift(1)[0];
	      chunk.compositionTime = this.mccree.loaderBuffer.toInt(0, 3);
	      this.mccree.loaderBuffer.shift(3);

	      // hevc is 12, avc is 7
	      if (codecID === 12) {
	        var data = this.mccree.loaderBuffer.shift(chunk.datasize - 5);
	        chunk.data = data;

	        if (chunk.avcPacketType != 0) {
	          if (!this._datasizeValidator(chunk.datasize)) {
	            this.logger.warn(this.TAG, this.logMsgs.TAG_LENGTH_ERROR + chunk.datasize);
	          }
	          var nalu = {};
	          var r = 0;
	          nalu.compositionTime = chunk.compositionTime;
	          nalu.timestamp = chunk.timestamp;
	          while (chunk.data.length > r) {
	            var sizes = chunk.data.slice(0 + r, 4 + r);
	            nalu.size = sizes[3];
	            nalu.size += sizes[2] * 256;
	            nalu.size += sizes[1] * 256 * 256;
	            nalu.size += sizes[0] * 256 * 256 * 256;
	            r += 4;
	            nalu.data = chunk.data.slice(0 + r, nalu.size + r);
	            r += nalu.size;
	            this.mccree.media.tracks.videoTrack.samples.push(nalu);
	            this.observer.trigger('VIDEO_PARSED');
	          }
	        } else if (chunk.avcPacketType == 0) {
	          if (!this._datasizeValidator(chunk.datasize)) {
	            this.logger.warn(this.TAG, this.logMsgs.TAG_LENGTH_ERROR + chunk.datasize);
	          } else {
	            this.observer.trigger('METADATA_PARSED');
	          }
	        }
	      } else if (codecID === 7) {
	        var data = this.mccree.loaderBuffer.shift(chunk.datasize - 5);
	        data = this._parseNaLu(data);
	        if (data[4] === 0 && data[5] === 0 && data[6] === 0 && data[7] === 1) {
	          var avcclength = 0;
	          for (var i = 0; i < 4; i++) {
	            avcclength = avcclength * 256 + data[i];
	          }
	          avcclength -= 4;
	          data = data.slice(4, data.length);
	          data[3] = avcclength % 256;
	          avcclength = (avcclength - data[3]) / 256;
	          data[2] = avcclength % 256;
	          avcclength = (avcclength - data[2]) / 256;
	          data[1] = avcclength % 256;
	          data[0] = (avcclength - data[1]) / 256;
	        }

	        chunk.data = data;
	        // If it is AVC sequece Header.
	        if (chunk.avcPacketType === 0) {
	          var tempMeta = Object.assign({}, this.mccree.media.tracks.videoTrack.meta);
	          AvcSequenceHeaderParser.parse.call(this, chunk.data);
	          this._avcSequenceHeaderChanged = this._hasVideoSequence && AvcSequenceHeaderParser.avcInfoChanged(this.mccree.media.tracks.videoTrack.meta, tempMeta, codecID, tempCodecID);
	          var validate = this._datasizeValidator(chunk.datasize);
	          if (validate) {
	            if (this._hasScript && !this._hasVideoSequence && (!this.mccree.media.tracks.audioTrack || this._hasAudioSequence)) {
	              this.observer.trigger('METADATA_PARSED');
	            } else if (this._hasScript && this._hasVideoSequence && this._hasAudioSequence && (this._aacSequenceHeaderChanged && this._avcSequenceHeaderChanged || this._scriptDataChanged)) {
	              if (this.hasFramerate || !this._avcSequenceHeaderChanged) {
	                this._aacSequenceHeaderChanged = false;
	                this._avcSequenceHeaderChanged = false;
	                this._scriptDataChanged = false;
	                this.observer.trigger('METADATA_CHANGED');
	              }
	            }
	            this._hasVideoSequence = true;
	          }
	        } else {
	          if (!this._datasizeValidator(chunk.datasize)) {
	            this.logger.warn(this.TAG, this.logMsgs.TAG_LENGTH_ERROR + chunk.datasize);
	          }
	          this.observer.trigger('VIDEODATA_PARSED');
	          this.mccree.media.tracks.videoTrack.samples.push(chunk);
	        }
	      } else {
	        this.logger.warn(this.TAG, 'codeid is ' + codecID);
	        chunk.data = this.mccree.loaderBuffer.shift(chunk.datasize - 1);
	        if (!this._datasizeValidator(chunk.datasize)) {
	          this.logger.warn(this.TAG, this.logMsgs.TAG_LENGTH_ERROR + chunk.datasize);
	        }
	        this.observer.trigger('VIDEODATA_PARSED');
	        this.mccree.media.tracks.videoTrack.samples.push(chunk);
	      }
	      delete chunk.tagType;
	    }
	  }, {
	    key: '_datasizeValidator',
	    value: function _datasizeValidator(datasize) {
	      var datasizeConfirm = this.mccree.loaderBuffer.toInt(0, 4);
	      this.mccree.loaderBuffer.shift(4);
	      var validate = datasizeConfirm === datasize + 11;
	      return validate;
	    }
	  }, {
	    key: '_switchAudioSamplingFrequency',
	    value: function _switchAudioSamplingFrequency(info) {
	      var samplingFrequencyIndex = (info & 12) >>> 2;
	      var samplingFrequencyList = [5500, 11025, 22050, 44100];
	      return samplingFrequencyList[samplingFrequencyIndex];
	    }
	  }, {
	    key: '_switchAudioChannel',
	    value: function _switchAudioChannel(info) {
	      var sampleTrackNumIndex = info & 1;
	      var sampleTrackNumList = [1, 2];
	      return sampleTrackNumList[sampleTrackNumIndex];
	    }
	  }, {
	    key: '_aacSequenceHeaderParser',
	    value: function _aacSequenceHeaderParser(data) {
	      var ret = {};
	      ret.hasSpecificConfig = true;
	      ret.objectType = data[1] >>> 3;
	      ret.sampleRateIndex = (data[1] & 7) << 1 | data[2] >>> 7;
	      ret.audiosamplerate = this._switchAudioSampleRate(ret.sampleRateIndex);
	      ret.channelCount = (data[2] & 120) >>> 3;
	      ret.frameLength = (data[2] & 4) >>> 2;
	      ret.dependsOnCoreCoder = (data[2] & 2) >>> 1;
	      ret.extensionFlagIndex = data[2] & 1;
	      return ret;
	    }
	  }, {
	    key: '_switchAudioSampleRate',
	    value: function _switchAudioSampleRate(samplingFrequencyIndex) {
	      var samplingFrequencyList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
	      return samplingFrequencyList[samplingFrequencyIndex];
	    }
	  }, {
	    key: '_avcSequenceHeaderParser',
	    value: function _avcSequenceHeaderParser(data) {
	      var track = this.mccree.media.tracks.videoTrack;

	      if (!track) {
	        return;
	      }

	      var offset = 0;

	      if (!track.meta) {
	        track.meta = _defaultVideoConfig2.default;
	      }
	      var meta = track.meta;

	      meta.configurationVersion = data[0];
	      meta.avcProfileIndication = data[1];
	      meta.profileCompatibility = data[2];
	      meta.avcLevelIndication = data[3] / 10;
	      meta.nalUnitLength = (data[4] & 0x03) + 1;

	      var numOfSps = data[5] & 0x1f;
	      offset = 6;
	      var config = {};

	      // parse SPS
	      for (var i = 0; i < numOfSps; i++) {
	        var size = data[offset] * 255 + data[offset + 1];
	        offset += 2;

	        var sps = new Uint8Array(size);
	        for (var _j = 0; _j < size; _j++) {
	          sps[_j] = data[offset + _j];
	        }

	        // codec string
	        var codecString = 'avc1.';
	        for (var j = 1; j < 4; j++) {
	          var h = sps[j].toString(16);
	          if (h.length < 2) {
	            h = '0' + h;
	          }
	          codecString += h;
	        }

	        meta.codec = codecString;

	        offset += size;
	        config = _mccreeHelperSpsparser2.default.parseSPS(sps);
	      }

	      var numOfPps = data[offset];
	      offset++;
	      for (var _i = 0; _i < numOfPps; _i++) {
	        var _size = data[offset] * 255 + data[offset + 1];
	        offset += 2;
	        var pps = new Uint8Array(_size);
	        for (var _j2 = 0; _j2 < _size; _j2++) {
	          pps[_j2] = data[offset + _j2];
	        }
	        offset += _size;
	        this.mccree.media.tracks.videoTrack.pps = pps;
	      }

	      if (config && config.codec_size) {
	        meta.codecWidth = config.codec_size.width;
	        meta.codecHeight = config.codec_size.height;
	        meta.presentWidth = config.present_size.width;
	        meta.presentHeight = config.present_size.height;
	      }

	      meta.profile = config.profile_string || meta.profile;
	      meta.level = config.level_string || meta.level;
	      meta.bitDepth = config.bit_depth || meta.bitDepth;
	      meta.chromaFormat = config.chroma_format || meta.chromaFormat;

	      if (meta.sarRatio) {
	        meta.sarRatio.width = config.sar_ratio.width;
	        meta.sarRatio.height = config.sar_ratio.height;
	      }

	      if (meta.frameRate && config.frame_rate.fixed && config.frame_rate.fps_num > 0 && config.frame_rate.fps_den > 0) {
	        meta.frameRate = config.frame_rate;
	      }

	      var fps_den = meta.frameRate.fps_den;
	      var fps_num = meta.frameRate.fps_num;
	      meta.refSampleDuration = Math.floor(meta.timescale * (fps_den / fps_num));

	      meta.avcc = new Uint8Array(data.length);
	      meta.avcc.set(data);
	      track.meta = meta;
	    }
	  }]);

	  return FLVDemuxer;
	}();

	exports.default = FLVDemuxer;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Track = function () {
	  /**
	   * The constructor.
	   */
	  function Track() {
	    _classCallCheck(this, Track);

	    this.TAG = "Track";
	    this.id = -1;
	    this.sequenceNumber = 0;
	    this.samples = [];
	    this.length = 0;
	  }

	  /**
	   * Reset the track.
	   */


	  _createClass(Track, [{
	    key: "reset",
	    value: function reset() {
	      this.sequenceNumber = 0;
	      this.samples = [];
	      this.length = 0;
	    }
	    /**
	     * destroy the track.
	     */

	  }, {
	    key: "distroy",
	    value: function distroy() {
	      this.reset();
	      this.id = -1;
	    }
	  }]);

	  return Track;
	}();

	exports.default = Track;

	var AudioTrack = exports.AudioTrack = function (_Track) {
	  _inherits(AudioTrack, _Track);

	  /**
	   * The constructor for audio track.
	   */
	  function AudioTrack() {
	    _classCallCheck(this, AudioTrack);

	    var _this = _possibleConstructorReturn(this, (AudioTrack.__proto__ || Object.getPrototypeOf(AudioTrack)).call(this));

	    _this.TAG = "AudioTrack";
	    _this.type = 'audio';
	    return _this;
	  }

	  return AudioTrack;
	}(Track);

	var VideoTrack = exports.VideoTrack = function (_Track2) {
	  _inherits(VideoTrack, _Track2);

	  /**
	   * The constructor for video track.
	   */
	  function VideoTrack() {
	    _classCallCheck(this, VideoTrack);

	    var _this2 = _possibleConstructorReturn(this, (VideoTrack.__proto__ || Object.getPrototypeOf(VideoTrack)).call(this));

	    _this2.TAG = "VideoTrack";
	    _this2.type = 'video';
	    _this2.dropped = 0;
	    return _this2;
	  }
	  /**
	   * reset the video track.
	   */


	  _createClass(VideoTrack, [{
	    key: "reset",
	    value: function reset() {
	      this.sequenceNumber = 0;
	      this.samples = [];
	      this.length = 0;
	      this.dropped = 0;
	    }
	  }]);

	  return VideoTrack;
	}(Track);

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeHelperGolomb = __webpack_require__(16);

	var _mccreeHelperGolomb2 = _interopRequireDefault(_mccreeHelperGolomb);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *
	 *
	 */
	var SPSParser = function () {
	    function SPSParser() {
	        _classCallCheck(this, SPSParser);
	    }

	    _createClass(SPSParser, null, [{
	        key: '_ebsp2rbsp',
	        value: function _ebsp2rbsp(uint8array) {
	            var src = uint8array;
	            var srcLength = src.byteLength;
	            var dst = new Uint8Array(srcLength);
	            var dstIdx = 0;

	            for (var i = 0; i < srcLength; i++) {
	                if (i >= 2) {
	                    if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
	                        continue;
	                    }
	                }
	                dst[dstIdx] = src[i];
	                dstIdx++;
	            }

	            return new Uint8Array(dst.buffer, 0, dstIdx);
	        }
	    }, {
	        key: 'parseSPS',
	        value: function parseSPS(uint8array) {
	            var rbsp = SPSParser._ebsp2rbsp(uint8array);
	            var gb = new _mccreeHelperGolomb2.default(rbsp);

	            gb.readByte();
	            var profileIdc = gb.readByte();
	            gb.readByte();
	            var levelIdc = gb.readByte();
	            gb.readUEG();

	            var profile_string = SPSParser.getProfileString(profileIdc);
	            var level_string = SPSParser.getLevelString(levelIdc);
	            var chroma_format_idc = 1;
	            var chroma_format = 420;
	            var chroma_format_table = [0, 420, 422, 444];
	            var bit_depth = 8;

	            if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {

	                chroma_format_idc = gb.readUEG();
	                if (chroma_format_idc === 3) {
	                    gb.readBits(1);
	                }
	                if (chroma_format_idc <= 3) {
	                    chroma_format = chroma_format_table[chroma_format_idc];
	                }

	                bit_depth = gb.readUEG() + 8;
	                gb.readUEG();
	                gb.readBits(1);
	                if (gb.readBool()) {
	                    var scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;
	                    for (var i = 0; i < scaling_list_count; i++) {
	                        if (gb.readBool()) {
	                            if (i < 6) {
	                                SPSParser._skipScalingList(gb, 16);
	                            } else {
	                                SPSParser._skipScalingList(gb, 64);
	                            }
	                        }
	                    }
	                }
	            }
	            gb.readUEG();
	            var pic_order_cnt_type = gb.readUEG();
	            if (pic_order_cnt_type === 0) {
	                gb.readUEG();4;
	            } else if (pic_order_cnt_type === 1) {
	                gb.readBits(1);
	                gb.readSEG();
	                gb.readSEG();
	                var num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();
	                for (var _i = 0; _i < num_ref_frames_in_pic_order_cnt_cycle; _i++) {
	                    gb.readSEG();
	                }
	            }
	            gb.readUEG();
	            gb.readBits(1);

	            var pic_width_in_mbs_minus1 = gb.readUEG();
	            var pic_height_in_map_units_minus1 = gb.readUEG();

	            var frame_mbs_only_flag = gb.readBits(1);
	            if (frame_mbs_only_flag === 0) {
	                gb.readBits(1);
	            }
	            gb.readBits(1);

	            var frame_crop_left_offset = 0;
	            var frame_crop_right_offset = 0;
	            var frame_crop_top_offset = 0;
	            var frame_crop_bottom_offset = 0;

	            var frame_cropping_flag = gb.readBool();
	            if (frame_cropping_flag) {
	                frame_crop_left_offset = gb.readUEG();
	                frame_crop_right_offset = gb.readUEG();
	                frame_crop_top_offset = gb.readUEG();
	                frame_crop_bottom_offset = gb.readUEG();
	            }

	            var sar_width = 1,
	                sar_height = 1;
	            var fps = 0,
	                fps_fixed = true,
	                fps_num = 0,
	                fps_den = 0;

	            var vui_parameters_present_flag = gb.readBool();
	            if (vui_parameters_present_flag) {
	                if (gb.readBool()) {
	                    // aspect_ratio_info_present_flag
	                    var aspect_ratio_idc = gb.readByte();
	                    var sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];
	                    var sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];

	                    if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
	                        sar_width = sar_w_table[aspect_ratio_idc - 1];
	                        sar_height = sar_h_table[aspect_ratio_idc - 1];
	                    } else if (aspect_ratio_idc === 255) {
	                        sar_width = gb.readByte() << 8 | gb.readByte();
	                        sar_height = gb.readByte() << 8 | gb.readByte();
	                    }
	                }

	                if (gb.readBool()) {
	                    gb.readBool();
	                }
	                if (gb.readBool()) {
	                    gb.readBits(4);
	                    if (gb.readBool()) {
	                        gb.readBits(24);
	                    }
	                }
	                if (gb.readBool()) {
	                    gb.readUEG();
	                    gb.readUEG();
	                }
	                if (gb.readBool()) {
	                    var num_units_in_tick = gb.readBits(32);
	                    var time_scale = gb.readBits(32);
	                    fps_fixed = gb.readBool();

	                    fps_num = time_scale;
	                    fps_den = num_units_in_tick * 2;
	                    fps = fps_num / fps_den;
	                }
	            }

	            var sarScale = 1;
	            if (sar_width !== 1 || sar_height !== 1) {
	                sarScale = sar_width / sar_height;
	            }

	            var crop_unit_x = 0,
	                crop_unit_y = 0;
	            if (chroma_format_idc === 0) {
	                crop_unit_x = 1;
	                crop_unit_y = 2 - frame_mbs_only_flag;
	            } else {
	                var sub_wc = chroma_format_idc === 3 ? 1 : 2;
	                var sub_hc = chroma_format_idc === 1 ? 2 : 1;
	                crop_unit_x = sub_wc;
	                crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);
	            }

	            var codec_width = (pic_width_in_mbs_minus1 + 1) * 16;
	            var codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);

	            codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;
	            codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;

	            var present_width = Math.ceil(codec_width * sarScale);

	            gb.destroy();
	            gb = null;

	            return {
	                profile_string: profile_string,
	                level_string: level_string,
	                bit_depth: bit_depth,
	                chroma_format: chroma_format,
	                chroma_format_string: SPSParser.getChromaFormatString(chroma_format),

	                frame_rate: {
	                    fixed: fps_fixed,
	                    fps: fps,
	                    fps_den: fps_den,
	                    fps_num: fps_num
	                },

	                sar_ratio: {
	                    width: sar_width,
	                    height: sar_height
	                },

	                codec_size: {
	                    width: codec_width,
	                    height: codec_height
	                },

	                present_size: {
	                    width: present_width,
	                    height: codec_height
	                }
	            };
	        }
	    }, {
	        key: '_skipScalingList',
	        value: function _skipScalingList(gb, count) {
	            var last_scale = 8,
	                next_scale = 8;
	            var delta_scale = 0;
	            for (var i = 0; i < count; i++) {
	                if (next_scale !== 0) {
	                    delta_scale = gb.readSEG();
	                    next_scale = (last_scale + delta_scale + 256) % 256;
	                }
	                last_scale = next_scale === 0 ? last_scale : next_scale;
	            }
	        }
	    }, {
	        key: 'getProfileString',
	        value: function getProfileString(profileIdc) {
	            switch (profileIdc) {
	                case 66:
	                    return 'Baseline';
	                case 77:
	                    return 'Main';
	                case 88:
	                    return 'Extended';
	                case 100:
	                    return 'High';
	                case 110:
	                    return 'High10';
	                case 122:
	                    return 'High422';
	                case 244:
	                    return 'High444';
	                default:
	                    return 'Unknown';
	            }
	        }
	    }, {
	        key: 'getLevelString',
	        value: function getLevelString(levelIdc) {
	            return (levelIdc / 10).toFixed(1);
	        }
	    }, {
	        key: 'getChromaFormatString',
	        value: function getChromaFormatString(chroma) {
	            switch (chroma) {
	                case 420:
	                    return '4:2:0';
	                case 422:
	                    return '4:2:2';
	                case 444:
	                    return '4:4:4';
	                default:
	                    return 'Unknown';
	            }
	        }
	    }]);

	    return SPSParser;
	}();

	exports.default = SPSParser;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Exponential-Golomb buffer decoder
	var Golomb = function () {
	    function Golomb(uint8array) {
	        _classCallCheck(this, Golomb);

	        this.TAG = 'Golomb';
	        this._buffer = uint8array;
	        this._bufferIndex = 0;
	        this._totalBytes = uint8array.byteLength;
	        this._totalBits = uint8array.byteLength * 8;
	        this._currentWord = 0;
	        this._currentWordBitsLeft = 0;
	    }

	    _createClass(Golomb, [{
	        key: 'destroy',
	        value: function destroy() {
	            this._buffer = null;
	        }
	    }, {
	        key: '_fillCurrentWord',
	        value: function _fillCurrentWord() {
	            var bufferBytesLeft = this._totalBytes - this._bufferIndex;
	            if (bufferBytesLeft <= 0) {
	                // TODO 异常处理
	            }

	            var bytesRead = Math.min(4, bufferBytesLeft);
	            var word = new Uint8Array(4);
	            word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
	            this._currentWord = new DataView(word.buffer).getUint32(0, false);

	            this._bufferIndex += bytesRead;
	            this._currentWordBitsLeft = bytesRead * 8;
	        }
	    }, {
	        key: 'readBits',
	        value: function readBits(bits) {
	            if (bits > 32) {
	                // TODO
	            }

	            if (bits <= this._currentWordBitsLeft) {
	                var _result = this._currentWord >>> 32 - bits;
	                this._currentWord <<= bits;
	                this._currentWordBitsLeft -= bits;
	                return _result;
	            }

	            var result = this._currentWordBitsLeft ? this._currentWord : 0;
	            result >>> 32 - this._currentWordBitsLeft;
	            var bitsNeedLeft = bits - this._currentWordBitsLeft;

	            this._fillCurrentWord();
	            var bitsReadNext = Math.min(bitsNeedLeft, this._currentWordBitsLeft);

	            var result2 = this._currentWord >>> 32 - bitsReadNext;
	            this._currentWord <<= bitsReadNext;
	            this._currentWordBitsLeft -= bitsReadNext;

	            result = result << bitsReadNext | result2;
	            return result;
	        }
	    }, {
	        key: 'readBool',
	        value: function readBool() {
	            return this.readBits(1) === 1;
	        }
	    }, {
	        key: 'readByte',
	        value: function readByte() {
	            return this.readBits(8);
	        }
	    }, {
	        key: '_skipLeadingZero',
	        value: function _skipLeadingZero() {
	            var zeroCount = void 0;
	            for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
	                if (0 !== (this._currentWord & 0x80000000 >>> zeroCount)) {
	                    this._currentWord <<= zeroCount;
	                    this._currentWordBitsLeft -= zeroCount;
	                    return zeroCount;
	                }
	            }
	            this._fillCurrentWord();
	            return zeroCount + this._skipLeadingZero();
	        }
	    }, {
	        key: 'readUEG',
	        value: function readUEG() {
	            // unsigned exponential golomb
	            var leadingZeros = this._skipLeadingZero();
	            return this.readBits(leadingZeros + 1) - 1;
	        }
	    }, {
	        key: 'readSEG',
	        value: function readSEG() {
	            // signed exponential golomb
	            var value = this.readUEG();
	            if (value & 0x01) {
	                return value + 1 >>> 1;
	            } else {
	                return -1 * (value >>> 1);
	            }
	        }
	    }]);

	    return Golomb;
	}();

	exports.default = Golomb;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var defaultVideoConfig = {
	  avcc: null,
	  chromaFormat: 420,
	  codec: 'avc1.640020',
	  codecHeight: 720,
	  codecWidth: 1280,
	  duration: 0,
	  frameRate: {
	    fixed: true,
	    fps: 25,
	    fps_num: 25000,
	    fps_den: 1000
	  },
	  id: 1,
	  level: "3.2",
	  presentHeight: 720,
	  presentWidth: 1280,
	  profile: "High",
	  refSampleDuration: 40,
	  sarRatio: {
	    height: 1,
	    width: 1
	  },
	  timescale: 1000,
	  type: "video"
	};
	exports.default = defaultVideoConfig;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var defaultAudioConfig = {
	  audioSampleRate: 48000,
	  channelCount: 2,
	  codec: "mp4a.40.2",
	  config: [41, 401, 136, 0],
	  duration: 0,
	  id: 2,
	  refSampleDuration: 21,
	  sampleRateIndex: 3,
	  timescale: 1000,
	  type: "audio"
	};

	exports.default = defaultAudioConfig;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AmfParser = function () {
	  function AmfParser(data) {
	    _classCallCheck(this, AmfParser);

	    this.offset = 0;
	    this.data = data;
	  }

	  _createClass(AmfParser, [{
	    key: 'parseMetadata',
	    value: function parseMetadata() {
	      var metadata = {};
	      try {
	        var scriptData = this.parseAMF();
	        for (var i = 0; i < scriptData.length - 1; i++) {
	          if (typeof scriptData[i] === 'string' && scriptData[i] === 'onMetaData' && _typeof(scriptData[i + 1]) === 'object') {
	            metadata = scriptData[i + 1];
	          }
	        }
	      } catch (e) {
	        // TODO: 异常处理
	      }
	      return metadata;
	    }
	  }, {
	    key: 'parseAMF',
	    value: function parseAMF() {
	      var result = [];

	      // find on metadata 
	      while (this.offset < this.data.length) {
	        var type = this.data[this.offset];
	        this.offset++;
	        var value = this._switchAmfType(type);
	        result.push(value);
	      }
	      return result;
	    }
	    // TODO: implement XML etc.

	  }, {
	    key: '_switchAmfType',
	    value: function _switchAmfType(type) {
	      var value = null;
	      switch (type) {
	        case 0x00:
	          value = this._parseNum();
	          break;
	        case 0x01:
	          value = this._parseBoolean();
	          break;
	        case 0x02:
	          value = this._parseString();
	          break;
	        case 0x03:
	          value = this._parseObject();
	          break;
	        case 0x04:
	          value = 'MovieClip'; //reserved, not supported
	          this.offset++;
	          break;
	        case 0x05:
	          value = null; //reserved, not supported
	          this.offset++;
	          break;
	        case 0x06:
	          value = undefined; //reserved, not supported
	          this.offset++;
	          break;
	        case 0x08:
	          value = this._parseECMAArrary();
	          break;
	      }
	      return value;
	    }
	  }, {
	    key: '_parseNum',
	    value: function _parseNum() {
	      var numData = this.data.slice(this.offset, this.offset + 8);
	      this.offset += 8;
	      return new DataView(numData.buffer).getFloat64(0);
	    }
	  }, {
	    key: '_parseString',
	    value: function _parseString() {
	      var lengthData = this.data.slice(this.offset, this.offset + 2);
	      var length = lengthData[0] * 256 + lengthData[1];
	      this.offset += 2;
	      var stringData = this.data.slice(this.offset, this.offset + length);
	      this.offset += length;
	      var string = new TextDecoder("utf-8").decode(stringData);
	      return string;
	    }
	  }, {
	    key: '_parseObject',
	    value: function _parseObject() {
	      var val = {};
	      while (this.offset < this.data.length - 2 && this.data[this.offset + 2] !== 0x09) {
	        var key = this._parseString();
	        var valueType = this.data[this.offset];
	        this.offset++;
	        var value = this._switchAmfType(valueType);
	        val[key] = value;
	      }
	      this.offset += 3;
	      return val;
	    }
	  }, {
	    key: '_parseECMAArrary',
	    value: function _parseECMAArrary() {
	      // let lengthData = this.data.slice(this.offset, this.offset + 4);
	      // let length = new DataView(lengthData.buffer).getUint32(0);
	      this.offset += 4;
	      return this._parseObject();
	    }
	  }, {
	    key: '_parseBoolean',
	    value: function _parseBoolean() {
	      this.offset++;
	      return !(this.data[0] === 0x00);
	    }
	  }]);

	  return AmfParser;
	}();

	exports.default = AmfParser;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mp4Generator = __webpack_require__(21);

	var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

	var _yuvrenderMin = __webpack_require__(22);

	var _yuvrenderMin2 = _interopRequireDefault(_yuvrenderMin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var HevcDecoder = function () {
	    function HevcDecoder(config) {
	        _classCallCheck(this, HevcDecoder);

	        this.TAG = 'mccree-remuxer-hevc';
	        this.type = 'remuxer';
	        this._config = config || {};
	        this._isLive = this._config.isLive;
	        this._dtsBase = 0;
	        this._dtsBaseInited = false;
	        this._audioDtsBase = Infinity;
	        this._videoDtsBase = Infinity;
	        this._audioNextDts = undefined;
	        this._videoNextDts = undefined;
	        this._audioMeta = null;
	        this._videoMeta = null;
	        this.canvas = null;
	        this.images = [];
	        this.needWait = true;
	        this.frame = null;
	        this.inits = false;
	        this.ifDecodeTime = -1;
	        this.worker = null;
	        this.webGLCanvas = null;
	        this.ylen = 0;
	        this.uvlen = 0;
	    }

	    _createClass(HevcDecoder, [{
	        key: 'init',
	        value: function init(mccree) {
	            this.mccree = mccree;
	            this.logger = mccree.logger;
	            this.observer = mccree.observer;
	            this.events = mccree.events;
	            this.onMediaSegment = mccree.onMediaSegment;
	            this.mccree.initSegment = {};
	            this.mccree.remuxBuffer = {
	                audio: [],
	                video: []
	            };
	            this.canvas = document.getElementById(this.mccree.config.canvasid);
	            this.initHevcDecoder.call(this);
	        }
	    }, {
	        key: 'initHevcDecoder',
	        value: function initHevcDecoder() {
	            var workerText = 'function EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError(\'n must be a positive number\');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled \'error\' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error(\'Uncaught, unspecified "error" event. (\' + er + \')\');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError(\'listener must be a function\');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === "newListener"! Before\n  // adding it to the listeners, first emit "newListener".\n  if (this._events.newListener)\n    this.emit(\'newListener\', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error(\'(node) warning: possible EventEmitter memory \' +\n                    \'leak detected. %d listeners added. \' +\n                    \'Use emitter.setMaxListeners() to increase limit.\',\n                    this._events[type].length);\n      if (typeof console.trace === \'function\') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError(\'listener must be a function\');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a \'removeListener\' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError(\'listener must be a function\');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit(\'removeListener\', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit(\'removeListener\', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === \'removeListener\') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners(\'removeListener\');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === \'function\';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === \'number\';\n}\n\nfunction isObject(arg) {\n  return typeof arg === \'object\' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\nvar Module = {\n    print: function(text) {\n        text = Array.prototype.slice.call(arguments).join(\' \');\n        console.log(text);\n    },\n    printErr: function(text) {\n        text = Array.prototype.slice.call(arguments).join(\' \');\n        console.error(text);\n    },\n    canvas: {},\n    noInitialRun: true\n};\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it, and do the work to get that through\n// closure compiler if necessary. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to do an eval in order to handle the closure compiler\n// case, where this code here is minified but Module was defined\n// elsewhere (e.g. case 4 above). We also need to check if Module\n// already exists (e.g. case 3 above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module;\nif (!Module) Module = (typeof Module !== \'undefined\' ? Module : null) || {};\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment\'s defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nfor (var key in Module) {\n    if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n    }\n}\n\n// The environment setup code below is customized to use Module.\n// *** Environment setup code ***\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\nif (Module[\'ENVIRONMENT\']) {\n    if (Module[\'ENVIRONMENT\'] === \'WEB\') {\n        ENVIRONMENT_IS_WEB = true;\n    } else if (Module[\'ENVIRONMENT\'] === \'WORKER\') {\n        ENVIRONMENT_IS_WORKER = true;\n    } else if (Module[\'ENVIRONMENT\'] === \'NODE\') {\n        ENVIRONMENT_IS_NODE = true;\n    } else if (Module[\'ENVIRONMENT\'] === \'SHELL\') {\n        ENVIRONMENT_IS_SHELL = true;\n    } else {\n        throw new Error(\'The provided Module[\\\'ENVIRONMENT\\\'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.\');\n    }\n} else {\n    ENVIRONMENT_IS_WEB = typeof window === \'object\';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \'function\';\n    ENVIRONMENT_IS_NODE = typeof process === \'object\' && typeof require === \'function\' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n}\n\n\nif (ENVIRONMENT_IS_NODE) {\n    // Expose functionality in the same simple way that the shells work\n    // Note that we pollute the global namespace here, otherwise we break in node\n    if (!Module[\'print\']) Module[\'print\'] = console.log;\n    if (!Module[\'printErr\']) Module[\'printErr\'] = console.warn;\n\n    var nodeFS;\n    var nodePath;\n\n    Module[\'read\'] = function shell_read(filename, binary) {\n        if (!nodeFS) nodeFS = require(\'fs\');\n        if (!nodePath) nodePath = require(\'path\');\n        filename = nodePath[\'normalize\'](filename);\n        var ret = nodeFS[\'readFileSync\'](filename);\n        return binary ? ret : ret.toString();\n    };\n\n    Module[\'readBinary\'] = function readBinary(filename) {\n        var ret = Module[\'read\'](filename, true);\n        if (!ret.buffer) {\n            ret = new Uint8Array(ret);\n        }\n        assert(ret.buffer);\n        return ret;\n    };\n\n    Module[\'load\'] = function load(f) {\n        globalEval(read(f));\n    };\n\n    if (!Module[\'thisProgram\']) {\n        if (process[\'argv\'].length > 1) {\n            Module[\'thisProgram\'] = process[\'argv\'][1].replace(/\\\\/g, \'/\');\n        } else {\n            Module[\'thisProgram\'] = \'unknown-program\';\n        }\n    }\n\n    Module[\'arguments\'] = process[\'argv\'].slice(2);\n\n    if (typeof module !== \'undefined\') {\n        module[\'exports\'] = Module;\n    }\n\n    process[\'on\'](\'uncaughtException\', function(ex) {\n        // suppress ExitStatus exceptions from showing an error\n        if (!(ex instanceof ExitStatus)) {\n            throw ex;\n        }\n    });\n\n    Module[\'inspect\'] = function () { return \'[Emscripten Module object]\'; };\n}\nelse if (ENVIRONMENT_IS_SHELL) {\n    if (!Module[\'print\']) Module[\'print\'] = print;\n    if (typeof printErr != \'undefined\') Module[\'printErr\'] = printErr; // not present in v8 or older sm\n\n    if (typeof read != \'undefined\') {\n        Module[\'read\'] = read;\n    } else {\n        Module[\'read\'] = function shell_read() { throw \'no read() available\' };\n    }\n\n    Module[\'readBinary\'] = function readBinary(f) {\n        if (typeof readbuffer === \'function\') {\n            return new Uint8Array(readbuffer(f));\n        }\n        var data = read(f, \'binary\');\n        assert(typeof data === \'object\');\n        return data;\n    };\n\n    if (typeof scriptArgs != \'undefined\') {\n        Module[\'arguments\'] = scriptArgs;\n    } else if (typeof arguments != \'undefined\') {\n        Module[\'arguments\'] = arguments;\n    }\n\n    if (typeof quit === \'function\') {\n        Module[\'quit\'] = function(status, toThrow) {\n            quit(status);\n        }\n    }\n\n}\nelse if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    Module[\'read\'] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\'GET\', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n    };\n\n    if (ENVIRONMENT_IS_WORKER) {\n        Module[\'readBinary\'] = function readBinary(url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\'GET\', url, false);\n            xhr.responseType = \'arraybuffer\';\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n        };\n    }\n\n    Module[\'readAsync\'] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\'GET\', url, true);\n        xhr.responseType = \'arraybuffer\';\n        xhr.onload = function xhr_onload() {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n                onload(xhr.response);\n            } else {\n                onerror();\n            }\n        };\n        xhr.onerror = onerror;\n        xhr.send(null);\n    };\n\n    if (typeof arguments != \'undefined\') {\n        Module[\'arguments\'] = arguments;\n    }\n\n    if (typeof console !== \'undefined\') {\n        if (!Module[\'print\']) Module[\'print\'] = function shell_print(x) {\n            console.log(x);\n        };\n        if (!Module[\'printErr\']) Module[\'printErr\'] = function shell_printErr(x) {\n            console.warn(x);\n        };\n    } else {\n        // Probably a worker, and without console.log. We can do very little here...\n        var TRY_USE_DUMP = false;\n        if (!Module[\'print\']) Module[\'print\'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {\n            dump(x);\n        }) : (function(x) {\n            // self.postMessage(x); // enable this if you want stdout to be sent as messages\n        }));\n    }\n\n    if (ENVIRONMENT_IS_WORKER) {\n        Module[\'load\'] = importScripts;\n    }\n\n    if (typeof Module[\'setWindowTitle\'] === \'undefined\') {\n        Module[\'setWindowTitle\'] = function(title) { document.title = title };\n    }\n}\nelse {\n    // Unreachable because SHELL is dependant on the others\n    throw \'Unknown runtime environment. Where are we?\';\n}\n\nfunction globalEval(x) {\n    eval.call(null, x);\n}\nif (!Module[\'load\'] && Module[\'read\']) {\n    Module[\'load\'] = function load(f) {\n        globalEval(Module[\'read\'](f));\n    };\n}\nif (!Module[\'print\']) {\n    Module[\'print\'] = function(){};\n}\nif (!Module[\'printErr\']) {\n    Module[\'printErr\'] = Module[\'print\'];\n}\nif (!Module[\'arguments\']) {\n    Module[\'arguments\'] = [];\n}\nif (!Module[\'thisProgram\']) {\n    Module[\'thisProgram\'] = \'./this.program\';\n}\nif (!Module[\'quit\']) {\n    Module[\'quit\'] = function(status, toThrow) {\n        throw toThrow;\n    }\n}\n\n// *** Environment setup code ***\n\n// Closure helpers\nModule.print = Module[\'print\'];\nModule.printErr = Module[\'printErr\'];\n\n// Callbacks\nModule[\'preRun\'] = [];\nModule[\'postRun\'] = [];\n\n// Merge back in the overrides\nfor (var key in moduleOverrides) {\n    if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n    }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = undefined;\n\n\n\n// {{PREAMBLE_ADDITIONS}}\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n//========================================\n// Runtime code shared with compiler\n//========================================\n\nvar Runtime = {\n    setTempRet0: function (value) {\n        tempRet0 = value;\n        return value;\n    },\n    getTempRet0: function () {\n        return tempRet0;\n    },\n    stackSave: function () {\n        return STACKTOP;\n    },\n    stackRestore: function (stackTop) {\n        STACKTOP = stackTop;\n    },\n    getNativeTypeSize: function (type) {\n        switch (type) {\n            case \'i1\': case \'i8\': return 1;\n            case \'i16\': return 2;\n            case \'i32\': return 4;\n            case \'i64\': return 8;\n            case \'float\': return 4;\n            case \'double\': return 8;\n            default: {\n                if (type[type.length-1] === \'*\') {\n                    return Runtime.QUANTUM_SIZE; // A pointer\n                } else if (type[0] === \'i\') {\n                    var bits = parseInt(type.substr(1));\n                    assert(bits % 8 === 0);\n                    return bits/8;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    },\n    getNativeFieldSize: function (type) {\n        return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);\n    },\n    STACK_ALIGN: 16,\n    prepVararg: function (ptr, type) {\n        if (type === \'double\' || type === \'i64\') {\n            // move so the load is aligned\n            if (ptr & 7) {\n                assert((ptr & 7) === 4);\n                ptr += 4;\n            }\n        } else {\n            assert((ptr & 3) === 0);\n        }\n        return ptr;\n    },\n    getAlignSize: function (type, size, vararg) {\n        // we align i64s and doubles on 64-bit boundaries, unlike x86\n        if (!vararg && (type == \'i64\' || type == \'double\')) return 8;\n        if (!type) return Math.min(size, 8); // align structures internally to 64 bits\n        return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);\n    },\n    dynCall: function (sig, ptr, args) {\n        if (args && args.length) {\n            return Module[\'dynCall_\' + sig].apply(null, [ptr].concat(args));\n        } else {\n            return Module[\'dynCall_\' + sig].call(null, ptr);\n        }\n    },\n    functionPointers: [],\n    addFunction: function (func) {\n        for (var i = 0; i < Runtime.functionPointers.length; i++) {\n            if (!Runtime.functionPointers[i]) {\n                Runtime.functionPointers[i] = func;\n                return 2*(1 + i);\n            }\n        }\n        throw \'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.\';\n    },\n    removeFunction: function (index) {\n        Runtime.functionPointers[(index-2)/2] = null;\n    },\n    warnOnce: function (text) {\n        if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};\n        if (!Runtime.warnOnce.shown[text]) {\n            Runtime.warnOnce.shown[text] = 1;\n            Module.printErr(text);\n        }\n    },\n    funcWrappers: {},\n    getFuncWrapper: function (func, sig) {\n        assert(sig);\n        if (!Runtime.funcWrappers[sig]) {\n            Runtime.funcWrappers[sig] = {};\n        }\n        var sigCache = Runtime.funcWrappers[sig];\n        if (!sigCache[func]) {\n            // optimize away arguments usage in common cases\n            if (sig.length === 1) {\n                sigCache[func] = function dynCall_wrapper() {\n                    return Runtime.dynCall(sig, func);\n                };\n            } else if (sig.length === 2) {\n                sigCache[func] = function dynCall_wrapper(arg) {\n                    return Runtime.dynCall(sig, func, [arg]);\n                };\n            } else {\n                // general case\n                sigCache[func] = function dynCall_wrapper() {\n                    return Runtime.dynCall(sig, func, Array.prototype.slice.call(arguments));\n                };\n            }\n        }\n        return sigCache[func];\n    },\n    getCompilerSetting: function (name) {\n        throw \'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work\';\n    },\n    stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16); return ret; },\n    staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },\n    dynamicAlloc: function (size) { var ret = HEAP32[DYNAMICTOP_PTR>>2];var end = (((ret + size + 15)|0) & -16);HEAP32[DYNAMICTOP_PTR>>2] = end;if (end >= TOTAL_MEMORY) {var success = enlargeMemory();if (!success) {HEAP32[DYNAMICTOP_PTR>>2] = ret;return 0;}}return ret;},\n    alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },\n    makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*(+4294967296))) : ((+((low>>>0)))+((+((high|0)))*(+4294967296)))); return ret; },\n    GLOBAL_BASE: 1024,\n    QUANTUM_SIZE: 4,\n    __dummy__: 0\n}\n\n\n\nModule["Runtime"] = Runtime;\n\n\n\n//========================================\n// Runtime essentials\n//========================================\n\nvar ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n    if (!condition) {\n        abort(\'Assertion failed: \' + text);\n    }\n}\n\nvar globalScope = this;\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n    var func = Module[\'_\' + ident]; // closure exported function\n    if (!func) {\n        try { func = eval(\'_\' + ident); } catch(e) {}\n    }\n    assert(func, \'Cannot call unknown function \' + ident + \' (perhaps LLVM optimizations or closure removed it?)\');\n    return func;\n}\n\nvar cwrap, ccall;\n(function(){\n    var JSfuncs = {\n        // Helpers for cwrap -- it can\'t refer to Runtime directly because it might\n        // be renamed by closure, instead it calls JSfuncs[\'stackSave\'].body to find\n        // out what the minified function name is.\n        \'stackSave\': function() {\n            Runtime.stackSave()\n        },\n        \'stackRestore\': function() {\n            Runtime.stackRestore()\n        },\n        // type conversion from js to c\n        \'arrayToC\' : function(arr) {\n            var ret = Runtime.stackAlloc(arr.length);\n            writeArrayToMemory(arr, ret);\n            return ret;\n        },\n        \'stringToC\' : function(str) {\n            var ret = 0;\n            if (str !== null && str !== undefined && str !== 0) { // null string\n                // at most 4 bytes per UTF-8 code point, +1 for the trailing \'\\0\'\n                var len = (str.length << 2) + 1;\n                ret = Runtime.stackAlloc(len);\n                stringToUTF8(str, ret, len);\n            }\n            return ret;\n        }\n    };\n    // For fast lookup of conversion functions\n    var toC = {\'string\' : JSfuncs[\'stringToC\'], \'array\' : JSfuncs[\'arrayToC\']};\n\n    // C calling interface.\n    ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {\n        var func = getCFunc(ident);\n        var cArgs = [];\n        var stack = 0;\n        if (args) {\n            for (var i = 0; i < args.length; i++) {\n                var converter = toC[argTypes[i]];\n                if (converter) {\n                    if (stack === 0) stack = Runtime.stackSave();\n                    cArgs[i] = converter(args[i]);\n                } else {\n                    cArgs[i] = args[i];\n                }\n            }\n        }\n        var ret = func.apply(null, cArgs);\n        if (returnType === \'string\') ret = Pointer_stringify(ret);\n        if (stack !== 0) {\n            if (opts && opts.async) {\n                EmterpreterAsync.asyncFinalizers.push(function() {\n                    Runtime.stackRestore(stack);\n                });\n                return;\n            }\n            Runtime.stackRestore(stack);\n        }\n        return ret;\n    }\n\n    var sourceRegex = /^function\\s*[a-zA-Z$_0-9]*\\s*\\(([^)]*)\\)\\s*{\\s*([^*]*?)[\\s;]*(?:return\\s*(.*?)[;\\s]*)?}$/;\n    function parseJSFunc(jsfunc) {\n        // Match the body and the return value of a javascript function source\n        var parsed = jsfunc.toString().match(sourceRegex).slice(1);\n        return {arguments : parsed[0], body : parsed[1], returnValue: parsed[2]}\n    }\n\n    // sources of useful functions. we create this lazily as it can trigger a source decompression on this entire file\n    var JSsource = null;\n    function ensureJSsource() {\n        if (!JSsource) {\n            JSsource = {};\n            for (var fun in JSfuncs) {\n                if (JSfuncs.hasOwnProperty(fun)) {\n                    // Elements of toCsource are arrays of three items:\n                    // the code, and the return value\n                    JSsource[fun] = parseJSFunc(JSfuncs[fun]);\n                }\n            }\n        }\n    }\n\n    cwrap = function cwrap(ident, returnType, argTypes) {\n        argTypes = argTypes || [];\n        var cfunc = getCFunc(ident);\n        // When the function takes numbers and returns a number, we can just return\n        // the original function\n        var numericArgs = argTypes.every(function(type){ return type === \'number\'});\n        var numericRet = (returnType !== \'string\');\n        if ( numericRet && numericArgs) {\n            return cfunc;\n        }\n        // Creation of the arguments list (["$1","$2",...,"$nargs"])\n        var argNames = argTypes.map(function(x,i){return \'$\'+i});\n        var funcstr = "(function(" + argNames.join(\',\') + ") {";\n        var nargs = argTypes.length;\n        if (!numericArgs) {\n            // Generate the code needed to convert the arguments from javascript\n            // values to pointers\n            ensureJSsource();\n            funcstr += \'var stack = \' + JSsource[\'stackSave\'].body + \';\';\n            for (var i = 0; i < nargs; i++) {\n                var arg = argNames[i], type = argTypes[i];\n                if (type === \'number\') continue;\n                var convertCode = JSsource[type + \'ToC\']; // [code, return]\n                funcstr += \'var \' + convertCode.arguments + \' = \' + arg + \';\';\n                funcstr += convertCode.body + \';\';\n                funcstr += arg + \'=(\' + convertCode.returnValue + \');\';\n            }\n        }\n\n        // When the code is compressed, the name of cfunc is not literally \'cfunc\' anymore\n        var cfuncname = parseJSFunc(function(){return cfunc}).returnValue;\n        // Call the function\n        funcstr += \'var ret = \' + cfuncname + \'(\' + argNames.join(\',\') + \');\';\n        if (!numericRet) { // Return type can only by \'string\' or \'number\'\n            // Convert the result to a string\n            var strgfy = parseJSFunc(function(){return Pointer_stringify}).returnValue;\n            funcstr += \'ret = \' + strgfy + \'(ret);\';\n        }\n        if (!numericArgs) {\n            // If we had a stack, restore it\n            ensureJSsource();\n            funcstr += JSsource[\'stackRestore\'].body.replace(\'()\', \'(stack)\') + \';\';\n        }\n        funcstr += \'return ret})\';\n        return eval(funcstr);\n    };\n})();\nModule["ccall"] = ccall;\nModule["cwrap"] = cwrap;\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n    type = type || \'i8\';\n    if (type.charAt(type.length-1) === \'*\') type = \'i32\'; // pointers are 32-bit\n    switch(type) {\n        case \'i1\': HEAP8[((ptr)>>0)]=value; break;\n        case \'i8\': HEAP8[((ptr)>>0)]=value; break;\n        case \'i16\': HEAP16[((ptr)>>1)]=value; break;\n        case \'i32\': HEAP32[((ptr)>>2)]=value; break;\n        case \'i64\': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n        case \'float\': HEAPF32[((ptr)>>2)]=value; break;\n        case \'double\': HEAPF64[((ptr)>>3)]=value; break;\n        default: abort(\'invalid type for setValue: \' + type);\n    }\n}\nModule["setValue"] = setValue;\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n    type = type || \'i8\';\n    if (type.charAt(type.length-1) === \'*\') type = \'i32\'; // pointers are 32-bit\n    switch(type) {\n        case \'i1\': return HEAP8[((ptr)>>0)];\n        case \'i8\': return HEAP8[((ptr)>>0)];\n        case \'i16\': return HEAP16[((ptr)>>1)];\n        case \'i32\': return HEAP32[((ptr)>>2)];\n        case \'i64\': return HEAP32[((ptr)>>2)];\n        case \'float\': return HEAPF32[((ptr)>>2)];\n        case \'double\': return HEAPF64[((ptr)>>3)];\n        default: abort(\'invalid type for setValue: \' + type);\n    }\n    return null;\n}\nModule["getValue"] = getValue;\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_STATIC = 2; // Cannot be freed\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 4; // Do not allocate\nModule["ALLOC_NORMAL"] = ALLOC_NORMAL;\nModule["ALLOC_STACK"] = ALLOC_STACK;\nModule["ALLOC_STATIC"] = ALLOC_STATIC;\nModule["ALLOC_DYNAMIC"] = ALLOC_DYNAMIC;\nModule["ALLOC_NONE"] = ALLOC_NONE;\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n    var zeroinit, size;\n    if (typeof slab === \'number\') {\n        zeroinit = true;\n        size = slab;\n    } else {\n        zeroinit = false;\n        size = slab.length;\n    }\n\n    var singleType = typeof types === \'string\' ? types : null;\n\n    var ret;\n    if (allocator == ALLOC_NONE) {\n        ret = ptr;\n    } else {\n        ret = [typeof _malloc === \'function\' ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n    }\n\n    if (zeroinit) {\n        var ptr = ret, stop;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n        for (; ptr < stop; ptr += 4) {\n            HEAP32[((ptr)>>2)]=0;\n        }\n        stop = ret + size;\n        while (ptr < stop) {\n            HEAP8[((ptr++)>>0)]=0;\n        }\n        return ret;\n    }\n\n    if (singleType === \'i8\') {\n        if (slab.subarray || slab.slice) {\n            HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n        } else {\n            HEAPU8.set(new Uint8Array(slab), ret);\n        }\n        return ret;\n    }\n\n    var i = 0, type, typeSize, previousType;\n    while (i < size) {\n        var curr = slab[i];\n\n        if (typeof curr === \'function\') {\n            curr = Runtime.getFunctionIndex(curr);\n        }\n\n        type = singleType || types[i];\n        if (type === 0) {\n            i++;\n            continue;\n        }\n\n        if (type == \'i64\') type = \'i32\'; // special case: we have one i32 here, and one i32 later\n\n        setValue(ret+i, curr, type);\n\n        // no need to look up size unless type changes, so cache it\n        if (previousType !== type) {\n            typeSize = Runtime.getNativeTypeSize(type);\n            previousType = type;\n        }\n        i += typeSize;\n    }\n\n    return ret;\n}\nModule["allocate"] = allocate;\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n    if (!staticSealed) return Runtime.staticAlloc(size);\n    if (!runtimeInitialized) return Runtime.dynamicAlloc(size);\n    return _malloc(size);\n}\nModule["getMemory"] = getMemory;\n\n/** @type {function(number, number=)} */\nfunction Pointer_stringify(ptr, length) {\n    if (length === 0 || !ptr) return \'\';\n    // TODO: use TextDecoder\n    // Find the length, and check for UTF while doing so\n    var hasUtf = 0;\n    var t;\n    var i = 0;\n    while (1) {\n        t = HEAPU8[(((ptr)+(i))>>0)];\n        hasUtf |= t;\n        if (t == 0 && !length) break;\n        i++;\n        if (length && i == length) break;\n    }\n    if (!length) length = i;\n\n    var ret = \'\';\n\n    if (hasUtf < 128) {\n        var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n        var curr;\n        while (length > 0) {\n            curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n            ret = ret ? ret + curr : curr;\n            ptr += MAX_CHUNK;\n            length -= MAX_CHUNK;\n        }\n        return ret;\n    }\n    return Module[\'UTF8ToString\'](ptr);\n}\nModule["Pointer_stringify"] = Pointer_stringify;\n\n// Given a pointer \'ptr\' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n    var str = \'\';\n    while (1) {\n        var ch = HEAP8[((ptr++)>>0)];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n    }\n}\nModule["AsciiToString"] = AsciiToString;\n\n// Copies the given Javascript String object \'str\' to the emscripten HEAP at address \'outPtr\',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n    return writeAsciiToMemory(str, outPtr, false);\n}\nModule["stringToAscii"] = stringToAscii;\n\n// Given a pointer \'ptr\' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== \'undefined\' ? new TextDecoder(\'utf8\') : undefined;\nfunction UTF8ArrayToString(u8Array, idx) {\n    var endPtr = idx;\n    // TextDecoder needs to know the byte length in advance, it doesn\'t stop on null terminator by itself.\n    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n    while (u8Array[endPtr]) ++endPtr;\n\n    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n    } else {\n        var u0, u1, u2, u3, u4, u5;\n\n        var str = \'\';\n        while (1) {\n            // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n            u0 = u8Array[idx++];\n            if (!u0) return str;\n            if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n            u1 = u8Array[idx++] & 63;\n            if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n            u2 = u8Array[idx++] & 63;\n            if ((u0 & 0xF0) == 0xE0) {\n                u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n            } else {\n                u3 = u8Array[idx++] & 63;\n                if ((u0 & 0xF8) == 0xF0) {\n                    u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n                } else {\n                    u4 = u8Array[idx++] & 63;\n                    if ((u0 & 0xFC) == 0xF8) {\n                        u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\n                    } else {\n                        u5 = u8Array[idx++] & 63;\n                        u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\n                    }\n                }\n            }\n            if (u0 < 0x10000) {\n                str += String.fromCharCode(u0);\n            } else {\n                var ch = u0 - 0x10000;\n                str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n            }\n        }\n    }\n}\nModule["UTF8ArrayToString"] = UTF8ArrayToString;\n\n// Given a pointer \'ptr\' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ToString(ptr) {\n    return UTF8ArrayToString(HEAPU8,ptr);\n}\nModule["UTF8ToString"] = UTF8ToString;\n\n// Copies the given Javascript String object \'str\' to the given byte array at address \'outIdx\',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n    if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don\'t write out any bytes.\n        return 0;\n\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n    for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n        if (u <= 0x7F) {\n            if (outIdx >= endIdx) break;\n            outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n            if (outIdx + 1 >= endIdx) break;\n            outU8Array[outIdx++] = 0xC0 | (u >> 6);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xFFFF) {\n            if (outIdx + 2 >= endIdx) break;\n            outU8Array[outIdx++] = 0xE0 | (u >> 12);\n            outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0x1FFFFF) {\n            if (outIdx + 3 >= endIdx) break;\n            outU8Array[outIdx++] = 0xF0 | (u >> 18);\n            outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n            outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0x3FFFFFF) {\n            if (outIdx + 4 >= endIdx) break;\n            outU8Array[outIdx++] = 0xF8 | (u >> 24);\n            outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n            outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n            outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        } else {\n            if (outIdx + 5 >= endIdx) break;\n            outU8Array[outIdx++] = 0xFC | (u >> 30);\n            outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\n            outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n            outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n            outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        }\n    }\n    // Null-terminate the pointer to the buffer.\n    outU8Array[outIdx] = 0;\n    return outIdx - startIdx;\n}\nModule["stringToUTF8Array"] = stringToUTF8Array;\n\n// Copies the given Javascript String object \'str\' to the emscripten HEAP at address \'outPtr\',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n    return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\nModule["stringToUTF8"] = stringToUTF8;\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF8(str) {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n        if (u <= 0x7F) {\n            ++len;\n        } else if (u <= 0x7FF) {\n            len += 2;\n        } else if (u <= 0xFFFF) {\n            len += 3;\n        } else if (u <= 0x1FFFFF) {\n            len += 4;\n        } else if (u <= 0x3FFFFFF) {\n            len += 5;\n        } else {\n            len += 6;\n        }\n    }\n    return len;\n}\nModule["lengthBytesUTF8"] = lengthBytesUTF8;\n\n// Given a pointer \'ptr\' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== \'undefined\' ? new TextDecoder(\'utf-16le\') : undefined;\nfunction UTF16ToString(ptr) {\n    var endPtr = ptr;\n    // TextDecoder needs to know the byte length in advance, it doesn\'t stop on null terminator by itself.\n    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n    var idx = endPtr >> 1;\n    while (HEAP16[idx]) ++idx;\n    endPtr = idx << 1;\n\n    if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n    } else {\n        var i = 0;\n\n        var str = \'\';\n        while (1) {\n            var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n            if (codeUnit == 0) return str;\n            ++i;\n            // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n            str += String.fromCharCode(codeUnit);\n        }\n    }\n}\n\n\n// Copies the given Javascript String object \'str\' to the emscripten HEAP at address \'outPtr\',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n    // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n    if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n    }\n    if (maxBytesToWrite < 2) return 0;\n    maxBytesToWrite -= 2; // Null terminator.\n    var startPtr = outPtr;\n    var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n    for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n        HEAP16[((outPtr)>>1)]=codeUnit;\n        outPtr += 2;\n    }\n    // Null-terminate the pointer to the HEAP.\n    HEAP16[((outPtr)>>1)]=0;\n    return outPtr - startPtr;\n}\n\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n    return str.length*2;\n}\n\n\nfunction UTF32ToString(ptr) {\n    var i = 0;\n\n    var str = \'\';\n    while (1) {\n        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n        if (utf32 == 0)\n            return str;\n        ++i;\n        // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        if (utf32 >= 0x10000) {\n            var ch = utf32 - 0x10000;\n            str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n        } else {\n            str += String.fromCharCode(utf32);\n        }\n    }\n}\n\n\n// Copies the given Javascript String object \'str\' to the emscripten HEAP at address \'outPtr\',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n    // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n    if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n    }\n    if (maxBytesToWrite < 4) return 0;\n    var startPtr = outPtr;\n    var endPtr = startPtr + maxBytesToWrite - 4;\n    for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n            var trailSurrogate = str.charCodeAt(++i);\n            codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n        }\n        HEAP32[((outPtr)>>2)]=codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n    }\n    // Null-terminate the pointer to the HEAP.\n    HEAP32[((outPtr)>>2)]=0;\n    return outPtr - startPtr;\n}\n\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n        len += 4;\n    }\n\n    return len;\n}\n\n\nfunction demangle(func) {\n    var __cxa_demangle_func = Module[\'___cxa_demangle\'] || Module[\'__cxa_demangle\'];\n    if (__cxa_demangle_func) {\n        try {\n            var s =\n                func.substr(1);\n            var len = lengthBytesUTF8(s)+1;\n            var buf = _malloc(len);\n            stringToUTF8(s, buf, len);\n            var status = _malloc(4);\n            var ret = __cxa_demangle_func(buf, 0, 0, status);\n            if (getValue(status, \'i32\') === 0 && ret) {\n                return Pointer_stringify(ret);\n            }\n            // otherwise, libcxxabi failed\n        } catch(e) {\n            // ignore problems here\n        } finally {\n            if (buf) _free(buf);\n            if (status) _free(status);\n            if (ret) _free(ret);\n        }\n        // failure when using libcxxabi, don\'t demangle\n        return func;\n    }\n    Runtime.warnOnce(\'warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\');\n    return func;\n}\n\nfunction demangleAll(text) {\n    var regex =\n        /__Z[\\w\\d_]+/g;\n    return text.replace(regex,\n        function(x) {\n            var y = demangle(x);\n            return x === y ? x : (x + \' [\' + y + \']\');\n        });\n}\n\nfunction jsStackTrace() {\n    var err = new Error();\n    if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n            throw new Error(0);\n        } catch(e) {\n            err = e;\n        }\n        if (!err.stack) {\n            return \'(no stack trace available)\';\n        }\n    }\n    return err.stack.toString();\n}\n\nfunction stackTrace() {\n    var js = jsStackTrace();\n    if (Module[\'extraStackTrace\']) js += \'\\n\' + Module[\'extraStackTrace\']();\n    return demangleAll(js);\n}\nModule["stackTrace"] = stackTrace;\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n    if (x % multiple > 0) {\n        x += multiple - (x % multiple);\n    }\n    return x;\n}\n\nvar HEAP,\n    /** @type {ArrayBuffer} */\n    buffer,\n    /** @type {Int8Array} */\n    HEAP8,\n    /** @type {Uint8Array} */\n    HEAPU8,\n    /** @type {Int16Array} */\n    HEAP16,\n    /** @type {Uint16Array} */\n    HEAPU16,\n    /** @type {Int32Array} */\n    HEAP32,\n    /** @type {Uint32Array} */\n    HEAPU32,\n    /** @type {Float32Array} */\n    HEAPF32,\n    /** @type {Float64Array} */\n    HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n    Module[\'buffer\'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n    Module[\'HEAP8\'] = HEAP8 = new Int8Array(buffer);\n    Module[\'HEAP16\'] = HEAP16 = new Int16Array(buffer);\n    Module[\'HEAP32\'] = HEAP32 = new Int32Array(buffer);\n    Module[\'HEAPU8\'] = HEAPU8 = new Uint8Array(buffer);\n    Module[\'HEAPU16\'] = HEAPU16 = new Uint16Array(buffer);\n    Module[\'HEAPU32\'] = HEAPU32 = new Uint32Array(buffer);\n    Module[\'HEAPF32\'] = HEAPF32 = new Float32Array(buffer);\n    Module[\'HEAPF64\'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\nSTATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\nstaticSealed = false;\n\n\n\nfunction abortOnCannotGrowMemory() {\n    abort(\'Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \' + TOTAL_MEMORY + \', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \');\n}\n\nif (!Module[\'reallocBuffer\']) Module[\'reallocBuffer\'] = function(size) {\n    var ret;\n    try {\n        if (ArrayBuffer.transfer) {\n            ret = ArrayBuffer.transfer(buffer, size);\n        } else {\n            var oldHEAP8 = HEAP8;\n            ret = new ArrayBuffer(size);\n            var temp = new Int8Array(ret);\n            temp.set(oldHEAP8);\n        }\n    } catch(e) {\n        return false;\n    }\n    var success = _emscripten_replace_memory(ret);\n    if (!success) return false;\n    return ret;\n};\n\nfunction enlargeMemory() {\n    // TOTAL_MEMORY is the current size of the actual array, and DYNAMICTOP is the new top.\n\n\n    var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n    var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\n\n    if (HEAP32[DYNAMICTOP_PTR>>2] > LIMIT) {\n        return false;\n    }\n\n    var OLD_TOTAL_MEMORY = TOTAL_MEMORY;\n    TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\n\n    while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR>>2]) { // Keep incrementing the heap size as long as it\'s less than what is requested.\n        if (TOTAL_MEMORY <= 536870912) {\n            TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\n        } else {\n            TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT); // ..., but after that, add smaller increments towards 2GB, which we cannot reach\n        }\n    }\n\n\n    var replacement = Module[\'reallocBuffer\'](TOTAL_MEMORY);\n    if (!replacement || replacement.byteLength != TOTAL_MEMORY) {\n        // restore the state to before this call, we failed\n        TOTAL_MEMORY = OLD_TOTAL_MEMORY;\n        return false;\n    }\n\n    // everything worked\n\n    updateGlobalBuffer(replacement);\n    updateGlobalBufferViews();\n\n    return true;\n}\n\nvar byteLength;\ntry {\n    byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \'byteLength\').get);\n    byteLength(new ArrayBuffer(4)); // can fail on older ie\n} catch(e) { // can fail on older node/v8\n    byteLength = function(buffer) { return buffer.byteLength; };\n}\n\nvar TOTAL_STACK = Module[\'TOTAL_STACK\'] || 5242880;\nvar TOTAL_MEMORY = Module[\'TOTAL_MEMORY\'] || 16777216;\nif (TOTAL_MEMORY < TOTAL_STACK) Module.printErr(\'TOTAL_MEMORY should be larger than TOTAL_STACK, was \' + TOTAL_MEMORY + \'! (TOTAL_STACK=\' + TOTAL_STACK + \')\');\n\n// Initialize the runtime\'s memory\n\n\n// Use a provided buffer, if there is one, or else allocate a new one\nif (Module[\'buffer\']) {\n    buffer = Module[\'buffer\'];\n} else {\n    // Use a WebAssembly memory where available\n    if (typeof WebAssembly === \'object\' && typeof WebAssembly.Memory === \'function\') {\n        Module[\'wasmMemory\'] = new WebAssembly.Memory({ \'initial\': TOTAL_MEMORY / WASM_PAGE_SIZE });\n        buffer = Module[\'wasmMemory\'].buffer;\n    } else\n    {\n        buffer = new ArrayBuffer(TOTAL_MEMORY);\n    }\n}\nupdateGlobalBufferViews();\n\n\nfunction getTotalMemory() {\n    return TOTAL_MEMORY;\n}\n\n// Endianness check (note: assumes compiler arch was little-endian)\nHEAP32[0] = 0x63736d65; /* \'emsc\' */\nHEAP16[1] = 0x6373;\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw \'Runtime error: expected the system to be little-endian!\';\n\nModule[\'HEAP\'] = HEAP;\nModule[\'buffer\'] = buffer;\nModule[\'HEAP8\'] = HEAP8;\nModule[\'HEAP16\'] = HEAP16;\nModule[\'HEAP32\'] = HEAP32;\nModule[\'HEAPU8\'] = HEAPU8;\nModule[\'HEAPU16\'] = HEAPU16;\nModule[\'HEAPU32\'] = HEAPU32;\nModule[\'HEAPF32\'] = HEAPF32;\nModule[\'HEAPF64\'] = HEAPF64;\n\nfunction callRuntimeCallbacks(callbacks) {\n    while(callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == \'function\') {\n            callback();\n            continue;\n        }\n        var func = callback.func;\n        if (typeof func === \'number\') {\n            if (callback.arg === undefined) {\n                Module[\'dynCall_v\'](func);\n            } else {\n                Module[\'dynCall_vi\'](func, callback.arg);\n            }\n        } else {\n            func(callback.arg === undefined ? null : callback.arg);\n        }\n    }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the runtime has exited\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n    // compatibility - merge in anything from Module[\'preRun\'] at this time\n    if (Module[\'preRun\']) {\n        if (typeof Module[\'preRun\'] == \'function\') Module[\'preRun\'] = [Module[\'preRun\']];\n        while (Module[\'preRun\'].length) {\n            addOnPreRun(Module[\'preRun\'].shift());\n        }\n    }\n    callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n    if (runtimeInitialized) return;\n    runtimeInitialized = true;\n    callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n    callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n    callRuntimeCallbacks(__ATEXIT__);\n    runtimeExited = true;\n}\n\nfunction postRun() {\n    // compatibility - merge in anything from Module[\'postRun\'] at this time\n    if (Module[\'postRun\']) {\n        if (typeof Module[\'postRun\'] == \'function\') Module[\'postRun\'] = [Module[\'postRun\']];\n        while (Module[\'postRun\'].length) {\n            addOnPostRun(Module[\'postRun\'].shift());\n        }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n}\nModule["addOnPreRun"] = addOnPreRun;\n\nfunction addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n}\nModule["addOnInit"] = addOnInit;\n\nfunction addOnPreMain(cb) {\n    __ATMAIN__.unshift(cb);\n}\nModule["addOnPreMain"] = addOnPreMain;\n\nfunction addOnExit(cb) {\n    __ATEXIT__.unshift(cb);\n}\nModule["addOnExit"] = addOnExit;\n\nfunction addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n}\nModule["addOnPostRun"] = addOnPostRun;\n\n// Tools\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array;\n}\nModule["intArrayFromString"] = intArrayFromString;\n\nfunction intArrayToString(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n        if (chr > 0xFF) {\n            chr &= 0xFF;\n        }\n        ret.push(String.fromCharCode(chr));\n    }\n    return ret.join(\'\');\n}\nModule["intArrayToString"] = intArrayToString;\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n    Runtime.warnOnce(\'writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!\');\n\n    var /** @type {number} */ lastChar, /** @type {number} */ end;\n    if (dontAddNull) {\n        // stringToUTF8Array always appends null. If we don\'t want to do that, remember the\n        // character that existed at the location where the null will be placed, and restore\n        // that after the write (below).\n        end = buffer + lengthBytesUTF8(string);\n        lastChar = HEAP8[end];\n    }\n    stringToUTF8(string, buffer, Infinity);\n    if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\nModule["writeStringToMemory"] = writeStringToMemory;\n\nfunction writeArrayToMemory(array, buffer) {\n    HEAP8.set(array, buffer);\n}\nModule["writeArrayToMemory"] = writeArrayToMemory;\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n        HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n    }\n    // Null-terminate the pointer to the HEAP.\n    if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\nModule["writeAsciiToMemory"] = writeAsciiToMemory;\n\nfunction unSign(value, bits, ignore) {\n    if (value >= 0) {\n        return value;\n    }\n    return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n        : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n    if (value <= 0) {\n        return value;\n    }\n    var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n        : Math.pow(2, bits-1);\n    if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don\'t do that\n        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n        // TODO: In i64 mode 1, resign the two parts separately and safely\n        value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n    }\n    return value;\n}\n\n// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )\nif (!Math[\'imul\'] || Math[\'imul\'](0xffffffff, 5) !== -5) Math[\'imul\'] = function imul(a, b) {\n    var ah  = a >>> 16;\n    var al = a & 0xffff;\n    var bh  = b >>> 16;\n    var bl = b & 0xffff;\n    return (al*bl + ((ah*bl + al*bh) << 16))|0;\n};\nMath.imul = Math[\'imul\'];\n\nif (!Math[\'fround\']) {\n    var froundBuffer = new Float32Array(1);\n    Math[\'fround\'] = function(x) { froundBuffer[0] = x; return froundBuffer[0] };\n}\nMath.fround = Math[\'fround\'];\n\nif (!Math[\'clz32\']) Math[\'clz32\'] = function(x) {\n    x = x >>> 0;\n    for (var i = 0; i < 32; i++) {\n        if (x & (1 << (31 - i))) return i;\n    }\n    return 32;\n};\nMath.clz32 = Math[\'clz32\']\n\nif (!Math[\'trunc\']) Math[\'trunc\'] = function(x) {\n    return x < 0 ? Math.ceil(x) : Math.floor(x);\n};\nMath.trunc = Math[\'trunc\'];\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nfunction getUniqueRunDependency(id) {\n    return id;\n}\n\nfunction addRunDependency(id) {\n    runDependencies++;\n    if (Module[\'monitorRunDependencies\']) {\n        Module[\'monitorRunDependencies\'](runDependencies);\n    }\n}\nModule["addRunDependency"] = addRunDependency;\n\nfunction removeRunDependency(id) {\n    runDependencies--;\n    if (Module[\'monitorRunDependencies\']) {\n        Module[\'monitorRunDependencies\'](runDependencies);\n    }\n    if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n            clearInterval(runDependencyWatcher);\n            runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n            var callback = dependenciesFulfilled;\n            dependenciesFulfilled = null;\n            callback(); // can add another dependenciesFulfilled\n        }\n    }\n}\nModule["removeRunDependency"] = removeRunDependency;\n\nModule["preloadedImages"] = {}; // maps url to image data\nModule["preloadedAudios"] = {}; // maps url to audio data\n\n\n\nvar memoryInitializer = null;\n\n\n\n\n\nfunction integrateWasmJS(Module, wasmFilePath, callback) {\n    // wasm.js has several methods for creating the compiled code module here:\n    //  * \'native-wasm\' : use native WebAssembly support in the browser\n    //  * \'interpret-s-expr\': load s-expression code from a .wast and interpret\n    //  * \'interpret-binary\': load binary wasm and interpret\n    //  * \'interpret-asm2wasm\': load asm.js code, translate to wasm, and interpret\n    //  * \'asmjs\': no wasm, just load the asm.js code and use that (good for testing)\n    // The method can be set at compile time (BINARYEN_METHOD), or runtime by setting Module[\'wasmJSMethod\'].\n    // The method can be a comma-separated list, in which case, we will try the\n    // options one by one. Some of them can fail gracefully, and then we can try\n    // the next.\n\n    // inputs\n\n    var method = Module[\'wasmJSMethod\'] || \'native-wasm\';\n    Module[\'wasmJSMethod\'] = method;\n\n    var wasmTextFile = Module[\'wasmTextFile\'] || \'libqydecoder.wast\';\n    var urlPrefix = /^[http|https]/.test(location.href) ?  location.href.substring(0, location.href.lastIndexOf(\'/\') +1): location.href.substring(5, location.href.lastIndexOf(\'/\') +1); //blob:domainName/xxxx\n\n    Module[\'wasmBinaryFile\']  = wasmFilePath;\n    var wasmBinaryFile = Module[\'wasmBinaryFile\'] || urlPrefix  + \'libqydecoder.wasm\';\n    var asmjsCodeFile = Module[\'asmjsCodeFile\'] || \'libqydecoder.temp.asm.js\';\n\n    if (typeof Module[\'locateFile\'] === \'function\') {\n        wasmTextFile = Module[\'locateFile\'](wasmTextFile);\n        wasmBinaryFile = Module[\'locateFile\'](wasmBinaryFile);\n        asmjsCodeFile = Module[\'locateFile\'](asmjsCodeFile);\n    }\n\n    // utilities\n\n    var wasmPageSize = 64*1024;\n\n    var asm2wasmImports = { // special asm2wasm imports\n        "f64-rem": function(x, y) {\n            return x % y;\n        },\n        "f64-to-int": function(x) {\n            return x | 0;\n        },\n        "i32s-div": function(x, y) {\n            return ((x | 0) / (y | 0)) | 0;\n        },\n        "i32u-div": function(x, y) {\n            return ((x >>> 0) / (y >>> 0)) >>> 0;\n        },\n        "i32s-rem": function(x, y) {\n            return ((x | 0) % (y | 0)) | 0;\n        },\n        "i32u-rem": function(x, y) {\n            return ((x >>> 0) % (y >>> 0)) >>> 0;\n        },\n        "debugger": function() {\n            debugger;\n        },\n    };\n\n    var info = {\n        \'global\': null,\n        \'env\': null,\n        \'asm2wasm\': asm2wasmImports,\n        \'parent\': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n    };\n\n    var exports = null;\n\n    function lookupImport(mod, base) {\n        var lookup = info;\n        if (mod.indexOf(\'.\') < 0) {\n            lookup = (lookup || {})[mod];\n        } else {\n            var parts = mod.split(\'.\');\n            lookup = (lookup || {})[parts[0]];\n            lookup = (lookup || {})[parts[1]];\n        }\n        if (base) {\n            lookup = (lookup || {})[base];\n        }\n        if (lookup === undefined) {\n            abort(\'bad lookupImport to (\' + mod + \').\' + base);\n        }\n        return lookup;\n    }\n\n    function mergeMemory(newBuffer) {\n        // The wasm instance creates its memory. But static init code might have written to\n        // buffer already, including the mem init file, and we must copy it over in a proper merge.\n        // TODO: avoid this copy, by avoiding such static init writes\n        // TODO: in shorter term, just copy up to the last static init write\n        var oldBuffer = Module[\'buffer\'];\n        if (newBuffer.byteLength < oldBuffer.byteLength) {\n            Module[\'printErr\'](\'the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here\');\n        }\n        var oldView = new Int8Array(oldBuffer);\n        var newView = new Int8Array(newBuffer);\n\n        // If we have a mem init file, do not trample it\n        if (!memoryInitializer) {\n            oldView.set(newView.subarray(Module[\'STATIC_BASE\'], Module[\'STATIC_BASE\'] + Module[\'STATIC_BUMP\']), Module[\'STATIC_BASE\']);\n        }\n\n        newView.set(oldView);\n        updateGlobalBuffer(newBuffer);\n        updateGlobalBufferViews();\n    }\n\n    var WasmTypes = {\n        none: 0,\n        i32: 1,\n        i64: 2,\n        f32: 3,\n        f64: 4\n    };\n\n    function fixImports(imports) {\n        if (!0) return imports;\n        var ret = {};\n        for (var i in imports) {\n            var fixed = i;\n            if (fixed[0] == \'_\') fixed = fixed.substr(1);\n            ret[fixed] = imports[i];\n        }\n        return ret;\n    }\n\n    function getBinary() {\n        try {\n            var binary;\n            if (Module[\'wasmBinary\']) {\n                binary = Module[\'wasmBinary\'];\n                binary = new Uint8Array(binary);\n            } else if (Module[\'readBinary\']) {\n                binary = Module[\'readBinary\'](wasmBinaryFile);\n            } else {\n                throw "on the web, we need the wasm binary to be preloaded and set on Module[\'wasmBinary\']. emcc.py will do that for you when generating HTML (but not JS)";\n            }\n            return binary;\n        }\n        catch (err) {\n            abort(err);\n        }\n    }\n\n    function getBinaryPromise() {\n        // if we don\'t have the binary yet, and have the Fetch api, use that\n        if (!Module[\'wasmBinary\'] && typeof fetch === \'function\') {\n            return fetch(wasmBinaryFile, { credentials: \'same-origin\' }).then(function(response) {\n                if (!response[\'ok\']) {\n                    throw "failed to load wasm binary file at \'" + wasmBinaryFile + "\'";\n                }\n                return response[\'arrayBuffer\']();\n            });\n        }\n        // Otherwise, getBinary should be able to get it synchronously\n        return new Promise(function(resolve, reject) {\n            resolve(getBinary());\n        });\n    }\n\n    // do-method functions\n\n    function doJustAsm(global, env, providedBuffer) {\n        // if no Module.asm, or it\'s the method handler helper (see below), then apply\n        // the asmjs\n        if (typeof Module[\'asm\'] !== \'function\' || Module[\'asm\'] === methodHandler) {\n            if (!Module[\'asmPreload\']) {\n                // you can load the .asm.js file before this, to avoid this sync xhr and eval\n                eval(Module[\'read\'](asmjsCodeFile)); // set Module.asm\n            } else {\n                Module[\'asm\'] = Module[\'asmPreload\'];\n            }\n        }\n        if (typeof Module[\'asm\'] !== \'function\') {\n            Module[\'printErr\'](\'asm evalling did not set the module properly\');\n            return false;\n        }\n        return Module[\'asm\'](global, env, providedBuffer);\n    }\n\n    function doNativeWasm(global, env, providedBuffer) {\n    \n        if (typeof WebAssembly !== \'object\') {\n            Module[\'printErr\'](\'no native wasm support detected\');\n            return false;\n        }\n        // prepare memory import\n        if (!(Module[\'wasmMemory\'] instanceof WebAssembly.Memory)) {\n            Module[\'printErr\'](\'no native wasm Memory in use\');\n            return false;\n        }\n       \n        env[\'memory\'] = Module[\'wasmMemory\'];\n        // Load the wasm module and create an instance of using native support in the JS engine.\n        info[\'global\'] = {\n            \'NaN\': NaN,\n            \'Infinity\': Infinity\n        };\n        info[\'global.Math\'] = global.Math;\n        info[\'env\'] = env;\n        // handle a generated wasm instance, receiving its exports and\n        // performing other necessary setup\n        function receiveInstance(instance) {\n            exports = instance.exports;\n            if (exports.memory) mergeMemory(exports.memory);\n\n            Module[\'asm\'] = exports;\n            Module["usingWasm"] = true;\n            removeRunDependency(\'wasm-instantiate\');\n            //navigator.WasmIsLoaded = true;\n            callback();\n        }\n\n        addRunDependency(\'wasm-instantiate\'); // we can\'t run yet\n\n        // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n        // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n        // to any other async startup actions they are performing.\n        if (Module[\'instantiateWasm\']) {\n            try {\n                return Module[\'instantiateWasm\'](info, receiveInstance);\n            } catch(e) {\n                Module[\'printErr\'](\'Module.instantiateWasm callback failed with error: \' + e);\n                return false;\n            }\n        }\n\n        getBinaryPromise().then(function(binary) {\n            return WebAssembly.instantiate(binary, info)\n        }).then(function(output) {\n            // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n            receiveInstance(output[\'instance\']);\n        }).catch(function(reason) {\n            Module[\'printErr\'](\'failed to asynchronously prepare wasm: \' + reason);\n            abort(reason);\n        });\n        return {}; // no exports yet; we\'ll fill them in later\n    }\n\n    function doWasmPolyfill(global, env, providedBuffer, method) {\n        if (typeof WasmJS !== \'function\') {\n            Module[\'printErr\'](\'WasmJS not detected - polyfill not bundled?\');\n            return false;\n        }\n\n        // Use wasm.js to polyfill and execute code in a wasm interpreter.\n        var wasmJS = WasmJS({});\n\n        // XXX don\'t be confused. Module here is in the outside program. wasmJS is the inner wasm-js.cpp.\n        wasmJS[\'outside\'] = Module; // Inside wasm-js.cpp, Module[\'outside\'] reaches the outside module.\n\n        // Information for the instance of the module.\n        wasmJS[\'info\'] = info;\n\n        wasmJS[\'lookupImport\'] = lookupImport;\n\n        assert(providedBuffer === Module[\'buffer\']); // we should not even need to pass it as a 3rd arg for wasm, but that\'s the asm.js way.\n\n        info.global = global;\n        info.env = env;\n    \n\n        // polyfill interpreter expects an ArrayBuffer\n        assert(providedBuffer === Module[\'buffer\']);\n        env[\'memory\'] = providedBuffer;\n        assert(env[\'memory\'] instanceof ArrayBuffer);\n\n        wasmJS[\'providedTotalMemory\'] = Module[\'buffer\'].byteLength;\n\n        // Prepare to generate wasm, using either asm2wasm or s-exprs\n        var code;\n        if (method === \'interpret-binary\') {\n            code = getBinary();\n        } else {\n            code = Module[\'read\'](method == \'interpret-asm2wasm\' ? asmjsCodeFile : wasmTextFile);\n        }\n        var temp;\n        if (method == \'interpret-asm2wasm\') {\n            temp = wasmJS[\'_malloc\'](code.length + 1);\n            wasmJS[\'writeAsciiToMemory\'](code, temp);\n            wasmJS[\'_load_asm2wasm\'](temp);\n        } else if (method === \'interpret-s-expr\') {\n            temp = wasmJS[\'_malloc\'](code.length + 1);\n            wasmJS[\'writeAsciiToMemory\'](code, temp);\n            wasmJS[\'_load_s_expr2wasm\'](temp);\n        } else if (method === \'interpret-binary\') {\n            temp = wasmJS[\'_malloc\'](code.length);\n            wasmJS[\'HEAPU8\'].set(code, temp);\n            wasmJS[\'_load_binary2wasm\'](temp, code.length);\n        } else {\n            throw \'what? \' + method;\n        }\n        wasmJS[\'_free\'](temp);\n\n        wasmJS[\'_instantiate\'](temp);\n\n        if (Module[\'newBuffer\']) {\n            mergeMemory(Module[\'newBuffer\']);\n            Module[\'newBuffer\'] = null;\n        }\n\n        exports = wasmJS[\'asmExports\'];\n\n        return exports;\n    }\n\n    // We may have a preloaded value in Module.asm, save it\n    Module[\'asmPreload\'] = Module[\'asm\'];\n\n    // Memory growth integration code\n\n    var asmjsReallocBuffer = Module[\'reallocBuffer\'];\n\n    var wasmReallocBuffer = function(size) {\n        var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n        size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n        var old = Module[\'buffer\'];\n        var oldSize = old.byteLength;\n        if (Module["usingWasm"]) {\n            // native wasm support\n            try {\n                var result = Module[\'wasmMemory\'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n                if (result !== (-1 | 0)) {\n                    // success in native wasm memory growth, get the buffer from the memory\n                    return Module[\'buffer\'] = Module[\'wasmMemory\'].buffer;\n                } else {\n                    return null;\n                }\n            } catch(e) {\n                return null;\n            }\n        } else {\n            // wasm interpreter support\n            exports[\'__growWasmMemory\']((size - oldSize) / wasmPageSize); // tiny wasm method that just does grow_memory\n            // in interpreter, we replace Module.buffer if we allocate\n            return Module[\'buffer\'] !== old ? Module[\'buffer\'] : null; // if it was reallocated, it changed\n        }\n    };\n\n    Module[\'reallocBuffer\'] = function(size) {\n        if (finalMethod === \'asmjs\') {\n            return asmjsReallocBuffer(size);\n        } else {\n            return wasmReallocBuffer(size);\n        }\n    };\n\n    // we may try more than one; this is the final one, that worked and we are using\n    var finalMethod = \'\';\n\n    // Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate\n    // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n    // doesn\'t need to care that it is wasm or olyfilled wasm or asm.js.\n\n    Module[\'asm\'] = function(global, env, providedBuffer) {\n        global = fixImports(global);\n    \n        env = fixImports(env);\n\n        // import table\n        if (!env[\'table\']) {\n            var TABLE_SIZE = Module[\'wasmTableSize\'];\n            if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n            var MAX_TABLE_SIZE = Module[\'wasmMaxTableSize\'];\n            if (typeof WebAssembly === \'object\' && typeof WebAssembly.Table === \'function\') {\n                if (MAX_TABLE_SIZE !== undefined) {\n                    env[\'table\'] = new WebAssembly.Table({ \'initial\': TABLE_SIZE, \'maximum\': MAX_TABLE_SIZE, \'element\': \'anyfunc\' });\n                } else {\n                    env[\'table\'] = new WebAssembly.Table({ \'initial\': TABLE_SIZE, element: \'anyfunc\' });\n                }\n            } else {\n                env[\'table\'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n            }\n            Module[\'wasmTable\'] = env[\'table\'];\n        }\n\n        if (!env[\'memoryBase\']) {\n            env[\'memoryBase\'] = Module[\'STATIC_BASE\']; // tell the memory segments where to place themselves\n        }\n        if (!env[\'tableBase\']) {\n            env[\'tableBase\'] = 0; // table starts at 0 by default, in dynamic linking this will change\n        }\n\n        // try the methods. each should return the exports if it succeeded\n\n        var exports;\n        exports = doNativeWasm(global, env, providedBuffer);\n\n\n        return exports;\n    };\n\n    var methodHandler = Module[\'asm\']; // note our method handler, as we may modify Module[\'asm\'] later\n}\n\n//integrateWasmJS(Module);\n\n// === Body ===\n\nvar ASM_CONSTS = [];\n\n\n\n\nSTATIC_BASE = Runtime.GLOBAL_BASE;\n\nSTATICTOP = STATIC_BASE + 57600;\n/* global initializers */  __ATINIT__.push({ func: function() { __GLOBAL__sub_I_DecParameterSetReader_cpp() } });\n\n\n//memoryInitializer = Module["wasmJSMethod"].indexOf("asmjs") >= 0 || Module["wasmJSMethod"].indexOf("interpret-asm2wasm") >= 0 ? "libqydecoder.js.mem" : null;\n\n\n\n\nvar STATIC_BUMP = 57600;\nModule["STATIC_BASE"] = STATIC_BASE;\nModule["STATIC_BUMP"] = STATIC_BUMP;\n\n/* no memory initializer */\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n\n    HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n    HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n    HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n    HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n}\n\nfunction copyTempDouble(ptr) {\n\n    HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n    HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n    HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n    HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n    HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n\n    HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n\n    HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n\n    HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n\n}\n\n// {{PRE_LIBRARY}}\n\n\n\n\n\n\n\n\n\n\nfunction _pthread_mutexattr_settype() {}\n\nfunction _abort() {\n    Module[\'abort\']();\n}\n\nfunction _pthread_cond_destroy() { return 0; }\n\nfunction _pthread_mutex_destroy() {}\n\nfunction _pthread_once(ptr, func) {\n    if (!_pthread_once.seen) _pthread_once.seen = {};\n    if (ptr in _pthread_once.seen) return;\n    Module[\'dynCall_v\'](func);\n    _pthread_once.seen[ptr] = 1;\n}\n\nfunction _pthread_create() {\n    return 11;\n}\n\nfunction ___lock() {}\n\nfunction ___unlock() {}\n\nfunction _usleep(useconds) {\n    // int usleep(useconds_t useconds);\n    // http://pubs.opengroup.org/onlinepubs/000095399/functions/usleep.html\n    // We\'re single-threaded, so use a busy loop. Super-ugly.\n    var msec = useconds / 1000;\n    if ((ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self[\'performance\'] && self[\'performance\'][\'now\']) {\n        var start = self[\'performance\'][\'now\']();\n        while (self[\'performance\'][\'now\']() - start < msec) {\n            // Do nothing.\n        }\n    } else {\n        var start = Date.now();\n        while (Date.now() - start < msec) {\n            // Do nothing.\n        }\n    }\n    return 0;\n}\n\nfunction _pthread_cond_wait() { return 0; }\n\n\nvar PTHREAD_SPECIFIC={};function _pthread_getspecific(key) {\n    return PTHREAD_SPECIFIC[key] || 0;\n}\n\n\nvar PTHREAD_SPECIFIC_NEXT_KEY=1;\n\nvar ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _pthread_key_create(key, destructor) {\n    if (key == 0) {\n        return ERRNO_CODES.EINVAL;\n    }\n    HEAP32[((key)>>2)]=PTHREAD_SPECIFIC_NEXT_KEY;\n    // values start at 0\n    PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\n    PTHREAD_SPECIFIC_NEXT_KEY++;\n    return 0;\n}\n\nfunction _pthread_mutex_init() {}\n\nvar _tzname=STATICTOP; STATICTOP += 16;;\nvar _daylight=STATICTOP; STATICTOP += 16;;\nvar _timezone=STATICTOP; STATICTOP += 16;;\n\nfunction _tzset() {\n    // TODO: Use (malleable) environment variables instead of system settings.\n    if (_tzset.called) return;\n    _tzset.called = true;\n\n    HEAP32[((_timezone)>>2)]=-(new Date()).getTimezoneOffset() * 60;\n\n    var winter = new Date(2000, 0, 1);\n    var summer = new Date(2000, 6, 1);\n    HEAP32[((_daylight)>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());\n\n    function extractZone(date) {\n      var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\n      return match ? match[1] : "GMT";\n    };\n    var winterName = extractZone(winter);\n    var summerName = extractZone(summer);\n    var winterNamePtr = allocate(intArrayFromString(winterName), \'i8\', ALLOC_NORMAL);\n    var summerNamePtr = allocate(intArrayFromString(summerName), \'i8\', ALLOC_NORMAL);\n    if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {\n      // Northern hemisphere\n      HEAP32[((_tzname)>>2)]=winterNamePtr;\n      HEAP32[(((_tzname)+(4))>>2)]=summerNamePtr;\n    } else {\n      HEAP32[((_tzname)>>2)]=summerNamePtr;\n      HEAP32[(((_tzname)+(4))>>2)]=winterNamePtr;\n    }\n  }\n\nfunction _mktime(tmPtr) {\n    _tzset();\n    var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,\n                        HEAP32[(((tmPtr)+(16))>>2)],\n                        HEAP32[(((tmPtr)+(12))>>2)],\n                        HEAP32[(((tmPtr)+(8))>>2)],\n                        HEAP32[(((tmPtr)+(4))>>2)],\n                        HEAP32[((tmPtr)>>2)],\n                        0);\n\n    // There\'s an ambiguous hour when the time goes back; the tm_isdst field is\n    // used to disambiguate it.  Date() basically guesses, so we fix it up if it\n    // guessed wrong, or fill in tm_isdst with the guess if it\'s -1.\n    var dst = HEAP32[(((tmPtr)+(32))>>2)];\n    var guessedOffset = date.getTimezoneOffset();\n    var start = new Date(date.getFullYear(), 0, 1);\n    var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();\n    var winterOffset = start.getTimezoneOffset();\n    var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South\n    if (dst < 0) {\n      HEAP32[(((tmPtr)+(32))>>2)]=Number(dstOffset == guessedOffset);\n    } else if ((dst > 0) != (dstOffset == guessedOffset)) {\n      var nonDstOffset = Math.max(winterOffset, summerOffset);\n      var trueOffset = dst > 0 ? dstOffset : nonDstOffset;\n      // Don\'t try setMinutes(date.getMinutes() + ...) -- it\'s messed up.\n      date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);\n    }\n\n    HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();\n    var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;\n    HEAP32[(((tmPtr)+(28))>>2)]=yday;\n\n    return (date.getTime() / 1000)|0;\n  }\n\nfunction _pthread_setspecific(key, value) {\n    if (!(key in PTHREAD_SPECIFIC)) {\n        return ERRNO_CODES.EINVAL;\n    }\n    PTHREAD_SPECIFIC[key] = value;\n    return 0;\n}\n\n\n\n\nvar ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can\'t send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};\n\nfunction ___setErrNo(value) {\n    if (Module[\'___errno_location\']) HEAP32[((Module[\'___errno_location\']())>>2)]=value;\n    return value;\n}\n\nvar PATH={splitPath:function (filename) {\n    var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n    return splitPathRe.exec(filename).slice(1);\n},normalizeArray:function (parts, allowAboveRoot) {\n    // if the path tries to go above the root, up ends up > 0\n    var up = 0;\n    for (var i = parts.length - 1; i >= 0; i--) {\n        var last = parts[i];\n        if (last === \'.\') {\n            parts.splice(i, 1);\n        } else if (last === \'..\') {\n            parts.splice(i, 1);\n            up++;\n        } else if (up) {\n            parts.splice(i, 1);\n            up--;\n        }\n    }\n    // if the path is allowed to go above the root, restore leading ..s\n    if (allowAboveRoot) {\n        for (; up; up--) {\n            parts.unshift(\'..\');\n        }\n    }\n    return parts;\n},normalize:function (path) {\n    var isAbsolute = path.charAt(0) === \'/\',\n        trailingSlash = path.substr(-1) === \'/\';\n    // Normalize the path\n    path = PATH.normalizeArray(path.split(\'/\').filter(function(p) {\n        return !!p;\n    }), !isAbsolute).join(\'/\');\n    if (!path && !isAbsolute) {\n        path = \'.\';\n    }\n    if (path && trailingSlash) {\n        path += \'/\';\n    }\n    return (isAbsolute ? \'/\' : \'\') + path;\n},dirname:function (path) {\n    var result = PATH.splitPath(path),\n        root = result[0],\n        dir = result[1];\n    if (!root && !dir) {\n        // No dirname whatsoever\n        return \'.\';\n    }\n    if (dir) {\n        // It has a dirname, strip trailing slash\n        dir = dir.substr(0, dir.length - 1);\n    }\n    return root + dir;\n},basename:function (path) {\n    // EMSCRIPTEN return \'/\'\' for \'/\', not an empty string\n    if (path === \'/\') return \'/\';\n    var lastSlash = path.lastIndexOf(\'/\');\n    if (lastSlash === -1) return path;\n    return path.substr(lastSlash+1);\n},extname:function (path) {\n    return PATH.splitPath(path)[3];\n},join:function () {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    return PATH.normalize(paths.join(\'/\'));\n},join2:function (l, r) {\n    return PATH.normalize(l + \'/\' + r);\n},resolve:function () {\n    var resolvedPath = \'\',\n        resolvedAbsolute = false;\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n        var path = (i >= 0) ? arguments[i] : FS.cwd();\n        // Skip empty and invalid entries\n        if (typeof path !== \'string\') {\n            throw new TypeError(\'Arguments to path.resolve must be strings\');\n        } else if (!path) {\n            return \'\'; // an invalid portion invalidates the whole thing\n        }\n        resolvedPath = path + \'/\' + resolvedPath;\n        resolvedAbsolute = path.charAt(0) === \'/\';\n    }\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    resolvedPath = PATH.normalizeArray(resolvedPath.split(\'/\').filter(function(p) {\n        return !!p;\n    }), !resolvedAbsolute).join(\'/\');\n    return ((resolvedAbsolute ? \'/\' : \'\') + resolvedPath) || \'.\';\n},relative:function (from, to) {\n    from = PATH.resolve(from).substr(1);\n    to = PATH.resolve(to).substr(1);\n    function trim(arr) {\n        var start = 0;\n        for (; start < arr.length; start++) {\n            if (arr[start] !== \'\') break;\n        }\n        var end = arr.length - 1;\n        for (; end >= 0; end--) {\n            if (arr[end] !== \'\') break;\n        }\n        if (start > end) return [];\n        return arr.slice(start, end - start + 1);\n    }\n    var fromParts = trim(from.split(\'/\'));\n    var toParts = trim(to.split(\'/\'));\n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n        if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n        }\n    }\n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n        outputParts.push(\'..\');\n    }\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n    return outputParts.join(\'/\');\n}};\n\nvar TTY={ttys:[],init:function () {\n    // https://github.com/kripken/emscripten/pull/1555\n    // if (ENVIRONMENT_IS_NODE) {\n    //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n    //   // device, it always assumes it\'s a TTY device. because of this, we\'re forcing\n    //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n    //   // with text files until FS.init can be refactored.\n    //   process[\'stdin\'][\'setEncoding\'](\'utf8\');\n    // }\n},shutdown:function () {\n    // https://github.com/kripken/emscripten/pull/1555\n    // if (ENVIRONMENT_IS_NODE) {\n    //   // inolen: any idea as to why node -e \'process.stdin.read()\' wouldn\'t exit immediately (with process.stdin being a tty)?\n    //   // isaacs: because now it\'s reading from the stream, you\'ve expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n    //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n    //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n    //   // isaacs: do process.stdin.pause() and i\'d think it\'d probably close the pending call\n    //   process[\'stdin\'][\'pause\']();\n    // }\n},register:function (dev, ops) {\n    TTY.ttys[dev] = { input: [], output: [], ops: ops };\n    FS.registerDevice(dev, TTY.stream_ops);\n},stream_ops:{open:function (stream) {\n    var tty = TTY.ttys[stream.node.rdev];\n    if (!tty) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n    }\n    stream.tty = tty;\n    stream.seekable = false;\n},close:function (stream) {\n    // flush any pending line data\n    stream.tty.ops.flush(stream.tty);\n},flush:function (stream) {\n    stream.tty.ops.flush(stream.tty);\n},read:function (stream, buffer, offset, length, pos /* ignored */) {\n    if (!stream.tty || !stream.tty.ops.get_char) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n    }\n    var bytesRead = 0;\n    for (var i = 0; i < length; i++) {\n        var result;\n        try {\n            result = stream.tty.ops.get_char(stream.tty);\n        } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        }\n        if (result === undefined && bytesRead === 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n        }\n        if (result === null || result === undefined) break;\n        bytesRead++;\n        buffer[offset+i] = result;\n    }\n    if (bytesRead) {\n        stream.node.timestamp = Date.now();\n    }\n    return bytesRead;\n},write:function (stream, buffer, offset, length, pos) {\n    if (!stream.tty || !stream.tty.ops.put_char) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n    }\n    for (var i = 0; i < length; i++) {\n        try {\n            stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\n        } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        }\n    }\n    if (length) {\n        stream.node.timestamp = Date.now();\n    }\n    return i;\n}},default_tty_ops:{get_char:function (tty) {\n    if (!tty.input.length) {\n        var result = null;\n        if (ENVIRONMENT_IS_NODE) {\n            // we will read data by chunks of BUFSIZE\n            var BUFSIZE = 256;\n            var buf = new Buffer(BUFSIZE);\n            var bytesRead = 0;\n\n            var isPosixPlatform = (process.platform != \'win32\'); // Node doesn\'t offer a direct check, so test by exclusion\n\n            var fd = process.stdin.fd;\n            if (isPosixPlatform) {\n                // Linux and Mac cannot use process.stdin.fd (which isn\'t set up as sync)\n                var usingDevice = false;\n                try {\n                    fd = fs.openSync(\'/dev/stdin\', \'r\');\n                    usingDevice = true;\n                } catch (e) {}\n            }\n\n            try {\n                bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\n            } catch(e) {\n                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\n                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\n                if (e.toString().indexOf(\'EOF\') != -1) bytesRead = 0;\n                else throw e;\n            }\n\n            if (usingDevice) { fs.closeSync(fd); }\n            if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString(\'utf-8\');\n            } else {\n                result = null;\n            }\n\n        } else if (typeof window != \'undefined\' &&\n            typeof window.prompt == \'function\') {\n            // Browser.\n            result = window.prompt(\'Input: \');  // returns null on cancel\n            if (result !== null) {\n                result += \'\\n\';\n            }\n        } else if (typeof readline == \'function\') {\n            // Command line.\n            result = readline();\n            if (result !== null) {\n                result += \'\\n\';\n            }\n        }\n        if (!result) {\n            return null;\n        }\n        tty.input = intArrayFromString(result, true);\n    }\n    return tty.input.shift();\n},put_char:function (tty, val) {\n    if (val === null || val === 10) {\n        Module[\'print\'](UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n    } else {\n        if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n    }\n},flush:function (tty) {\n    if (tty.output && tty.output.length > 0) {\n        Module[\'print\'](UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n    }\n}},default_tty1_ops:{put_char:function (tty, val) {\n    if (val === null || val === 10) {\n        Module[\'printErr\'](UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n    } else {\n        if (val != 0) tty.output.push(val);\n    }\n},flush:function (tty) {\n    if (tty.output && tty.output.length > 0) {\n        Module[\'printErr\'](UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n    }\n}}};\n\nvar MEMFS={ops_table:null,mount:function (mount) {\n    return MEMFS.createNode(null, \'/\', 16384 | 511 /* 0777 */, 0);\n},createNode:function (parent, name, mode, dev) {\n    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n        // no supported\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    if (!MEMFS.ops_table) {\n        MEMFS.ops_table = {\n            dir: {\n                node: {\n                    getattr: MEMFS.node_ops.getattr,\n                    setattr: MEMFS.node_ops.setattr,\n                    lookup: MEMFS.node_ops.lookup,\n                    mknod: MEMFS.node_ops.mknod,\n                    rename: MEMFS.node_ops.rename,\n                    unlink: MEMFS.node_ops.unlink,\n                    rmdir: MEMFS.node_ops.rmdir,\n                    readdir: MEMFS.node_ops.readdir,\n                    symlink: MEMFS.node_ops.symlink\n                },\n                stream: {\n                    llseek: MEMFS.stream_ops.llseek\n                }\n            },\n            file: {\n                node: {\n                    getattr: MEMFS.node_ops.getattr,\n                    setattr: MEMFS.node_ops.setattr\n                },\n                stream: {\n                    llseek: MEMFS.stream_ops.llseek,\n                    read: MEMFS.stream_ops.read,\n                    write: MEMFS.stream_ops.write,\n                    allocate: MEMFS.stream_ops.allocate,\n                    mmap: MEMFS.stream_ops.mmap,\n                    msync: MEMFS.stream_ops.msync\n                }\n            },\n            link: {\n                node: {\n                    getattr: MEMFS.node_ops.getattr,\n                    setattr: MEMFS.node_ops.setattr,\n                    readlink: MEMFS.node_ops.readlink\n                },\n                stream: {}\n            },\n            chrdev: {\n                node: {\n                    getattr: MEMFS.node_ops.getattr,\n                    setattr: MEMFS.node_ops.setattr\n                },\n                stream: FS.chrdev_stream_ops\n            }\n        };\n    }\n    var node = FS.createNode(parent, name, mode, dev);\n    if (FS.isDir(node.mode)) {\n        node.node_ops = MEMFS.ops_table.dir.node;\n        node.stream_ops = MEMFS.ops_table.dir.stream;\n        node.contents = {};\n    } else if (FS.isFile(node.mode)) {\n        node.node_ops = MEMFS.ops_table.file.node;\n        node.stream_ops = MEMFS.ops_table.file.stream;\n        node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n        // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n        // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n        // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n        node.contents = null;\n    } else if (FS.isLink(node.mode)) {\n        node.node_ops = MEMFS.ops_table.link.node;\n        node.stream_ops = MEMFS.ops_table.link.stream;\n    } else if (FS.isChrdev(node.mode)) {\n        node.node_ops = MEMFS.ops_table.chrdev.node;\n        node.stream_ops = MEMFS.ops_table.chrdev.stream;\n    }\n    node.timestamp = Date.now();\n    // add the new node to the parent\n    if (parent) {\n        parent.contents[name] = node;\n    }\n    return node;\n},getFileDataAsRegularArray:function (node) {\n    if (node.contents && node.contents.subarray) {\n        var arr = [];\n        for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n        return arr; // Returns a copy of the original data.\n    }\n    return node.contents; // No-op, the file contents are already in a JS array. Return as-is.\n},getFileDataAsTypedArray:function (node) {\n    if (!node.contents) return new Uint8Array;\n    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n    return new Uint8Array(node.contents);\n},expandFileStorage:function (node, newCapacity) {\n    // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file\n    // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to\n    // increase the size.\n    if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {\n        node.contents = MEMFS.getFileDataAsRegularArray(node);\n        node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.\n    }\n\n    if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n        // Don\'t expand strictly to the given requested limit if it\'s only a very small increase, but instead geometrically grow capacity.\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n        // avoid overshooting the allocation cap by a very large margin.\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n        return;\n    }\n    // Not using a typed array to back the file storage. Use a standard JS array instead.\n    if (!node.contents && newCapacity > 0) node.contents = [];\n    while (node.contents.length < newCapacity) node.contents.push(0);\n},resizeFileStorage:function (node, newSize) {\n    if (node.usedBytes == newSize) return;\n    if (newSize == 0) {\n        node.contents = null; // Fully decommit when requesting a resize to zero.\n        node.usedBytes = 0;\n        return;\n    }\n    if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.\n        if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n        }\n        node.usedBytes = newSize;\n        return;\n    }\n    // Backing with a JS array.\n    if (!node.contents) node.contents = [];\n    if (node.contents.length > newSize) node.contents.length = newSize;\n    else while (node.contents.length < newSize) node.contents.push(0);\n    node.usedBytes = newSize;\n},node_ops:{getattr:function (node) {\n    var attr = {};\n    // device numbers reuse inode numbers.\n    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n    attr.ino = node.id;\n    attr.mode = node.mode;\n    attr.nlink = 1;\n    attr.uid = 0;\n    attr.gid = 0;\n    attr.rdev = node.rdev;\n    if (FS.isDir(node.mode)) {\n        attr.size = 4096;\n    } else if (FS.isFile(node.mode)) {\n        attr.size = node.usedBytes;\n    } else if (FS.isLink(node.mode)) {\n        attr.size = node.link.length;\n    } else {\n        attr.size = 0;\n    }\n    attr.atime = new Date(node.timestamp);\n    attr.mtime = new Date(node.timestamp);\n    attr.ctime = new Date(node.timestamp);\n    // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n    //       but this is not required by the standard.\n    attr.blksize = 4096;\n    attr.blocks = Math.ceil(attr.size / attr.blksize);\n    return attr;\n},setattr:function (node, attr) {\n    if (attr.mode !== undefined) {\n        node.mode = attr.mode;\n    }\n    if (attr.timestamp !== undefined) {\n        node.timestamp = attr.timestamp;\n    }\n    if (attr.size !== undefined) {\n        MEMFS.resizeFileStorage(node, attr.size);\n    }\n},lookup:function (parent, name) {\n    throw FS.genericErrors[ERRNO_CODES.ENOENT];\n},mknod:function (parent, name, mode, dev) {\n    return MEMFS.createNode(parent, name, mode, dev);\n},rename:function (old_node, new_dir, new_name) {\n    // if we\'re overwriting a directory at new_name, make sure it\'s empty.\n    if (FS.isDir(old_node.mode)) {\n        var new_node;\n        try {\n            new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n        }\n        if (new_node) {\n            for (var i in new_node.contents) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n            }\n        }\n    }\n    // do the internal rewiring\n    delete old_node.parent.contents[old_node.name];\n    old_node.name = new_name;\n    new_dir.contents[new_name] = old_node;\n    old_node.parent = new_dir;\n},unlink:function (parent, name) {\n    delete parent.contents[name];\n},rmdir:function (parent, name) {\n    var node = FS.lookupNode(parent, name);\n    for (var i in node.contents) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n    }\n    delete parent.contents[name];\n},readdir:function (node) {\n    var entries = [\'.\', \'..\']\n    for (var key in node.contents) {\n        if (!node.contents.hasOwnProperty(key)) {\n            continue;\n        }\n        entries.push(key);\n    }\n    return entries;\n},symlink:function (parent, newname, oldpath) {\n    var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n    node.link = oldpath;\n    return node;\n},readlink:function (node) {\n    if (!FS.isLink(node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    return node.link;\n}},stream_ops:{read:function (stream, buffer, offset, length, position) {\n    var contents = stream.node.contents;\n    if (position >= stream.node.usedBytes) return 0;\n    var size = Math.min(stream.node.usedBytes - position, length);\n    assert(size >= 0);\n    if (size > 8 && contents.subarray) { // non-trivial, and typed array\n        buffer.set(contents.subarray(position, position + size), offset);\n    } else {\n        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n    }\n    return size;\n},write:function (stream, buffer, offset, length, position, canOwn) {\n    if (!length) return 0;\n    var node = stream.node;\n    node.timestamp = Date.now();\n\n    if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n        if (canOwn) {\n            node.contents = buffer.subarray(offset, offset + length);\n            node.usedBytes = length;\n            return length;\n        } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don\'t need to care about old data.\n            node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\n            node.usedBytes = length;\n            return length;\n        } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n            return length;\n        }\n    }\n\n    // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n    MEMFS.expandFileStorage(node, position+length);\n    if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.\n    else {\n        for (var i = 0; i < length; i++) {\n            node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n        }\n    }\n    node.usedBytes = Math.max(node.usedBytes, position+length);\n    return length;\n},llseek:function (stream, offset, whence) {\n    var position = offset;\n    if (whence === 1) {  // SEEK_CUR.\n        position += stream.position;\n    } else if (whence === 2) {  // SEEK_END.\n        if (FS.isFile(stream.node.mode)) {\n            position += stream.node.usedBytes;\n        }\n    }\n    if (position < 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    return position;\n},allocate:function (stream, offset, length) {\n    MEMFS.expandFileStorage(stream.node, offset + length);\n    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n},mmap:function (stream, buffer, offset, length, position, prot, flags) {\n    if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n    }\n    var ptr;\n    var allocated;\n    var contents = stream.node.contents;\n    // Only make a new copy when MAP_PRIVATE is specified.\n    if ( !(flags & 2) &&\n        (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {\n        // We can\'t emulate MAP_SHARED when the file is not backed by the buffer\n        // we\'re mapping to (e.g. the HEAP buffer).\n        allocated = false;\n        ptr = contents.byteOffset;\n    } else {\n        // Try to avoid unnecessary slices.\n        if (position > 0 || position + length < stream.node.usedBytes) {\n            if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n            } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n            }\n        }\n        allocated = true;\n        ptr = _malloc(length);\n        if (!ptr) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\n        }\n        buffer.set(contents, ptr);\n    }\n    return { ptr: ptr, allocated: allocated };\n},msync:function (stream, buffer, offset, length, mmapFlags) {\n    if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n    }\n    if (mmapFlags & 2) {\n        // MAP_PRIVATE calls need not to be synced back to underlying fs\n        return 0;\n    }\n\n    var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n    // should we check if bytesWritten and length are the same?\n    return 0;\n}}};\n\nvar IDBFS={dbs:{},indexedDB:function () {\n    if (typeof indexedDB !== \'undefined\') return indexedDB;\n    var ret = null;\n    if (typeof window === \'object\') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n    assert(ret, \'IDBFS used, but indexedDB not supported\');\n    return ret;\n},DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {\n    // reuse all of the core MEMFS functionality\n    return MEMFS.mount.apply(null, arguments);\n},syncfs:function (mount, populate, callback) {\n    IDBFS.getLocalSet(mount, function(err, local) {\n        if (err) return callback(err);\n\n        IDBFS.getRemoteSet(mount, function(err, remote) {\n            if (err) return callback(err);\n\n            var src = populate ? remote : local;\n            var dst = populate ? local : remote;\n\n            IDBFS.reconcile(src, dst, callback);\n        });\n    });\n},getDB:function (name, callback) {\n    // check the cache first\n    var db = IDBFS.dbs[name];\n    if (db) {\n        return callback(null, db);\n    }\n\n    var req;\n    try {\n        req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\n    } catch (e) {\n        return callback(e);\n    }\n    if (!req) {\n        return callback("Unable to connect to IndexedDB");\n    }\n    req.onupgradeneeded = function(e) {\n        var db = e.target.result;\n        var transaction = e.target.transaction;\n\n        var fileStore;\n\n        if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\n            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\n        } else {\n            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\n        }\n\n        if (!fileStore.indexNames.contains(\'timestamp\')) {\n            fileStore.createIndex(\'timestamp\', \'timestamp\', { unique: false });\n        }\n    };\n    req.onsuccess = function() {\n        db = req.result;\n\n        // add to the cache\n        IDBFS.dbs[name] = db;\n        callback(null, db);\n    };\n    req.onerror = function(e) {\n        callback(this.error);\n        e.preventDefault();\n    };\n},getLocalSet:function (mount, callback) {\n    var entries = {};\n\n    function isRealDir(p) {\n        return p !== \'.\' && p !== \'..\';\n    };\n    function toAbsolute(root) {\n        return function(p) {\n            return PATH.join2(root, p);\n        }\n    };\n\n    var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n\n    while (check.length) {\n        var path = check.pop();\n        var stat;\n\n        try {\n            stat = FS.stat(path);\n        } catch (e) {\n            return callback(e);\n        }\n\n        if (FS.isDir(stat.mode)) {\n            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));\n        }\n\n        entries[path] = { timestamp: stat.mtime };\n    }\n\n    return callback(null, { type: \'local\', entries: entries });\n},getRemoteSet:function (mount, callback) {\n    var entries = {};\n\n    IDBFS.getDB(mount.mountpoint, function(err, db) {\n        if (err) return callback(err);\n\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], \'readonly\');\n        transaction.onerror = function(e) {\n            callback(this.error);\n            e.preventDefault();\n        };\n\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n        var index = store.index(\'timestamp\');\n\n        index.openKeyCursor().onsuccess = function(event) {\n            var cursor = event.target.result;\n\n            if (!cursor) {\n                return callback(null, { type: \'remote\', db: db, entries: entries });\n            }\n\n            entries[cursor.primaryKey] = { timestamp: cursor.key };\n\n            cursor.continue();\n        };\n    });\n},loadLocalEntry:function (path, callback) {\n    var stat, node;\n\n    try {\n        var lookup = FS.lookupPath(path);\n        node = lookup.node;\n        stat = FS.stat(path);\n    } catch (e) {\n        return callback(e);\n    }\n\n    if (FS.isDir(stat.mode)) {\n        return callback(null, { timestamp: stat.mtime, mode: stat.mode });\n    } else if (FS.isFile(stat.mode)) {\n        // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.\n        // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.\n        node.contents = MEMFS.getFileDataAsTypedArray(node);\n        return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });\n    } else {\n        return callback(new Error(\'node type not supported\'));\n    }\n},storeLocalEntry:function (path, entry, callback) {\n    try {\n        if (FS.isDir(entry.mode)) {\n            FS.mkdir(path, entry.mode);\n        } else if (FS.isFile(entry.mode)) {\n            FS.writeFile(path, entry.contents, { encoding: \'binary\', canOwn: true });\n        } else {\n            return callback(new Error(\'node type not supported\'));\n        }\n\n        FS.chmod(path, entry.mode);\n        FS.utime(path, entry.timestamp, entry.timestamp);\n    } catch (e) {\n        return callback(e);\n    }\n\n    callback(null);\n},removeLocalEntry:function (path, callback) {\n    try {\n        var lookup = FS.lookupPath(path);\n        var stat = FS.stat(path);\n\n        if (FS.isDir(stat.mode)) {\n            FS.rmdir(path);\n        } else if (FS.isFile(stat.mode)) {\n            FS.unlink(path);\n        }\n    } catch (e) {\n        return callback(e);\n    }\n\n    callback(null);\n},loadRemoteEntry:function (store, path, callback) {\n    var req = store.get(path);\n    req.onsuccess = function(event) { callback(null, event.target.result); };\n    req.onerror = function(e) {\n        callback(this.error);\n        e.preventDefault();\n    };\n},storeRemoteEntry:function (store, path, entry, callback) {\n    var req = store.put(entry, path);\n    req.onsuccess = function() { callback(null); };\n    req.onerror = function(e) {\n        callback(this.error);\n        e.preventDefault();\n    };\n},removeRemoteEntry:function (store, path, callback) {\n    var req = store.delete(path);\n    req.onsuccess = function() { callback(null); };\n    req.onerror = function(e) {\n        callback(this.error);\n        e.preventDefault();\n    };\n},reconcile:function (src, dst, callback) {\n    var total = 0;\n\n    var create = [];\n    Object.keys(src.entries).forEach(function (key) {\n        var e = src.entries[key];\n        var e2 = dst.entries[key];\n        if (!e2 || e.timestamp > e2.timestamp) {\n            create.push(key);\n            total++;\n        }\n    });\n\n    var remove = [];\n    Object.keys(dst.entries).forEach(function (key) {\n        var e = dst.entries[key];\n        var e2 = src.entries[key];\n        if (!e2) {\n            remove.push(key);\n            total++;\n        }\n    });\n\n    if (!total) {\n        return callback(null);\n    }\n\n    var errored = false;\n    var completed = 0;\n    var db = src.type === \'remote\' ? src.db : dst.db;\n    var transaction = db.transaction([IDBFS.DB_STORE_NAME], \'readwrite\');\n    var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n\n    function done(err) {\n        if (err) {\n            if (!done.errored) {\n                done.errored = true;\n                return callback(err);\n            }\n            return;\n        }\n        if (++completed >= total) {\n            return callback(null);\n        }\n    };\n\n    transaction.onerror = function(e) {\n        done(this.error);\n        e.preventDefault();\n    };\n\n    // sort paths in ascending order so directory entries are created\n    // before the files inside them\n    create.sort().forEach(function (path) {\n        if (dst.type === \'local\') {\n            IDBFS.loadRemoteEntry(store, path, function (err, entry) {\n                if (err) return done(err);\n                IDBFS.storeLocalEntry(path, entry, done);\n            });\n        } else {\n            IDBFS.loadLocalEntry(path, function (err, entry) {\n                if (err) return done(err);\n                IDBFS.storeRemoteEntry(store, path, entry, done);\n            });\n        }\n    });\n\n    // sort paths in descending order so files are deleted before their\n    // parent directories\n    remove.sort().reverse().forEach(function(path) {\n        if (dst.type === \'local\') {\n            IDBFS.removeLocalEntry(path, done);\n        } else {\n            IDBFS.removeRemoteEntry(store, path, done);\n        }\n    });\n}};\n\nvar NODEFS={isWindows:false,staticInit:function () {\n    NODEFS.isWindows = !!process.platform.match(/^win/);\n},mount:function (mount) {\n    assert(ENVIRONMENT_IS_NODE);\n    return NODEFS.createNode(null, \'/\', NODEFS.getMode(mount.opts.root), 0);\n},createNode:function (parent, name, mode, dev) {\n    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    var node = FS.createNode(parent, name, mode);\n    node.node_ops = NODEFS.node_ops;\n    node.stream_ops = NODEFS.stream_ops;\n    return node;\n},getMode:function (path) {\n    var stat;\n    try {\n        stat = fs.lstatSync(path);\n        if (NODEFS.isWindows) {\n            // On Windows, directories return permission bits \'rw-rw-rw-\', even though they have \'rwxrwxrwx\', so\n            // propagate write bits to execute bits.\n            stat.mode = stat.mode | ((stat.mode & 146) >> 1);\n        }\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n    return stat.mode;\n},realPath:function (node) {\n    var parts = [];\n    while (node.parent !== node) {\n        parts.push(node.name);\n        node = node.parent;\n    }\n    parts.push(node.mount.opts.root);\n    parts.reverse();\n    return PATH.join.apply(null, parts);\n},flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {\n    flags &= ~0x200000 /*O_PATH*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n    flags &= ~0x800 /*O_NONBLOCK*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n    flags &= ~0x8000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n    flags &= ~0x80000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.\n    if (flags in NODEFS.flagsToPermissionStringMap) {\n        return NODEFS.flagsToPermissionStringMap[flags];\n    } else {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n},node_ops:{getattr:function (node) {\n    var path = NODEFS.realPath(node);\n    var stat;\n    try {\n        stat = fs.lstatSync(path);\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n    // node.js v0.10.20 doesn\'t report blksize and blocks on Windows. Fake them with default blksize of 4096.\n    // See http://support.microsoft.com/kb/140365\n    if (NODEFS.isWindows && !stat.blksize) {\n        stat.blksize = 4096;\n    }\n    if (NODEFS.isWindows && !stat.blocks) {\n        stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;\n    }\n    return {\n        dev: stat.dev,\n        ino: stat.ino,\n        mode: stat.mode,\n        nlink: stat.nlink,\n        uid: stat.uid,\n        gid: stat.gid,\n        rdev: stat.rdev,\n        size: stat.size,\n        atime: stat.atime,\n        mtime: stat.mtime,\n        ctime: stat.ctime,\n        blksize: stat.blksize,\n        blocks: stat.blocks\n    };\n},setattr:function (node, attr) {\n    var path = NODEFS.realPath(node);\n    try {\n        if (attr.mode !== undefined) {\n            fs.chmodSync(path, attr.mode);\n            // update the common node structure mode as well\n            node.mode = attr.mode;\n        }\n        if (attr.timestamp !== undefined) {\n            var date = new Date(attr.timestamp);\n            fs.utimesSync(path, date, date);\n        }\n        if (attr.size !== undefined) {\n            fs.truncateSync(path, attr.size);\n        }\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},lookup:function (parent, name) {\n    var path = PATH.join2(NODEFS.realPath(parent), name);\n    var mode = NODEFS.getMode(path);\n    return NODEFS.createNode(parent, name, mode);\n},mknod:function (parent, name, mode, dev) {\n    var node = NODEFS.createNode(parent, name, mode, dev);\n    // create the backing node for this in the fs root as well\n    var path = NODEFS.realPath(node);\n    try {\n        if (FS.isDir(node.mode)) {\n            fs.mkdirSync(path, node.mode);\n        } else {\n            fs.writeFileSync(path, \'\', { mode: node.mode });\n        }\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n    return node;\n},rename:function (oldNode, newDir, newName) {\n    var oldPath = NODEFS.realPath(oldNode);\n    var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\n    try {\n        fs.renameSync(oldPath, newPath);\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},unlink:function (parent, name) {\n    var path = PATH.join2(NODEFS.realPath(parent), name);\n    try {\n        fs.unlinkSync(path);\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},rmdir:function (parent, name) {\n    var path = PATH.join2(NODEFS.realPath(parent), name);\n    try {\n        fs.rmdirSync(path);\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},readdir:function (node) {\n    var path = NODEFS.realPath(node);\n    try {\n        return fs.readdirSync(path);\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},symlink:function (parent, newName, oldPath) {\n    var newPath = PATH.join2(NODEFS.realPath(parent), newName);\n    try {\n        fs.symlinkSync(oldPath, newPath);\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},readlink:function (node) {\n    var path = NODEFS.realPath(node);\n    try {\n        path = fs.readlinkSync(path);\n        path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\n        return path;\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n}},stream_ops:{open:function (stream) {\n    var path = NODEFS.realPath(stream.node);\n    try {\n        if (FS.isFile(stream.node.mode)) {\n            stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));\n        }\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},close:function (stream) {\n    try {\n        if (FS.isFile(stream.node.mode) && stream.nfd) {\n            fs.closeSync(stream.nfd);\n        }\n    } catch (e) {\n        if (!e.code) throw e;\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n},read:function (stream, buffer, offset, length, position) {\n    if (length === 0) return 0; // node errors on 0 length reads\n    // FIXME this is terrible.\n    var nbuffer = new Buffer(length);\n    var res;\n    try {\n        res = fs.readSync(stream.nfd, nbuffer, 0, length, position);\n    } catch (e) {\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n    if (res > 0) {\n        for (var i = 0; i < res; i++) {\n            buffer[offset + i] = nbuffer[i];\n        }\n    }\n    return res;\n},write:function (stream, buffer, offset, length, position) {\n    // FIXME this is terrible.\n    var nbuffer = new Buffer(buffer.subarray(offset, offset + length));\n    var res;\n    try {\n        res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);\n    } catch (e) {\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n    }\n    return res;\n},llseek:function (stream, offset, whence) {\n    var position = offset;\n    if (whence === 1) {  // SEEK_CUR.\n        position += stream.position;\n    } else if (whence === 2) {  // SEEK_END.\n        if (FS.isFile(stream.node.mode)) {\n            try {\n                var stat = fs.fstatSync(stream.nfd);\n                position += stat.size;\n            } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        }\n    }\n\n    if (position < 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n\n    return position;\n}}};\n\nvar WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:function (mount) {\n    assert(ENVIRONMENT_IS_WORKER);\n    if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\n    var root = WORKERFS.createNode(null, \'/\', WORKERFS.DIR_MODE, 0);\n    var createdParents = {};\n    function ensureParent(path) {\n        // return the parent node, creating subdirs as necessary\n        var parts = path.split(\'/\');\n        var parent = root;\n        for (var i = 0; i < parts.length-1; i++) {\n            var curr = parts.slice(0, i+1).join(\'/\');\n            // Issue 4254: Using curr as a node name will prevent the node\n            // from being found in FS.nameTable when FS.open is called on\n            // a path which holds a child of this node,\n            // given that all FS functions assume node names\n            // are just their corresponding parts within their given path,\n            // rather than incremental aggregates which include their parent\'s\n            // directories.\n            if (!createdParents[curr]) {\n                createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);\n            }\n            parent = createdParents[curr];\n        }\n        return parent;\n    }\n    function base(path) {\n        var parts = path.split(\'/\');\n        return parts[parts.length-1];\n    }\n    // We also accept FileList here, by using Array.prototype\n    Array.prototype.forEach.call(mount.opts["files"] || [], function(file) {\n        WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\n    });\n    (mount.opts["blobs"] || []).forEach(function(obj) {\n        WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);\n    });\n    (mount.opts["packages"] || []).forEach(function(pack) {\n        pack[\'metadata\'].files.forEach(function(file) {\n            var name = file.filename.substr(1); // remove initial slash\n            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack[\'blob\'].slice(file.run, file.end));\n        });\n    });\n    return root;\n},createNode:function (parent, name, mode, dev, contents, mtime) {\n    var node = FS.createNode(parent, name, mode);\n    node.mode = mode;\n    node.node_ops = WORKERFS.node_ops;\n    node.stream_ops = WORKERFS.stream_ops;\n    node.timestamp = (mtime || new Date).getTime();\n    assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n    if (mode === WORKERFS.FILE_MODE) {\n        node.size = contents.size;\n        node.contents = contents;\n    } else {\n        node.size = 4096;\n        node.contents = {};\n    }\n    if (parent) {\n        parent.contents[name] = node;\n    }\n    return node;\n},node_ops:{getattr:function (node) {\n    return {\n        dev: 1,\n        ino: undefined,\n        mode: node.mode,\n        nlink: 1,\n        uid: 0,\n        gid: 0,\n        rdev: undefined,\n        size: node.size,\n        atime: new Date(node.timestamp),\n        mtime: new Date(node.timestamp),\n        ctime: new Date(node.timestamp),\n        blksize: 4096,\n        blocks: Math.ceil(node.size / 4096),\n    };\n},setattr:function (node, attr) {\n    if (attr.mode !== undefined) {\n        node.mode = attr.mode;\n    }\n    if (attr.timestamp !== undefined) {\n        node.timestamp = attr.timestamp;\n    }\n},lookup:function (parent, name) {\n    throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n},mknod:function (parent, name, mode, dev) {\n    throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n},rename:function (oldNode, newDir, newName) {\n    throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n},unlink:function (parent, name) {\n    throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n},rmdir:function (parent, name) {\n    throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n},readdir:function (node) {\n    var entries = [\'.\', \'..\'];\n    for (var key in node.contents) {\n        if (!node.contents.hasOwnProperty(key)) {\n            continue;\n        }\n        entries.push(key);\n    }\n    return entries;\n},symlink:function (parent, newName, oldPath) {\n    throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n},readlink:function (node) {\n    throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n}},stream_ops:{read:function (stream, buffer, offset, length, position) {\n    if (position >= stream.node.size) return 0;\n    var chunk = stream.node.contents.slice(position, position + length);\n    var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n    buffer.set(new Uint8Array(ab), offset);\n    return chunk.size;\n},write:function (stream, buffer, offset, length, position) {\n    throw new FS.ErrnoError(ERRNO_CODES.EIO);\n},llseek:function (stream, offset, whence) {\n    var position = offset;\n    if (whence === 1) {  // SEEK_CUR.\n        position += stream.position;\n    } else if (whence === 2) {  // SEEK_END.\n        if (FS.isFile(stream.node.mode)) {\n            position += stream.node.size;\n        }\n    }\n    if (position < 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    return position;\n}}};\n\nvar _stdin=STATICTOP; STATICTOP += 16;;\n\nvar _stdout=STATICTOP; STATICTOP += 16;;\n\nvar _stderr=STATICTOP; STATICTOP += 16;;var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function (e) {\n    if (!(e instanceof FS.ErrnoError)) throw e + \' : \' + stackTrace();\n    return ___setErrNo(e.errno);\n},lookupPath:function (path, opts) {\n    path = PATH.resolve(FS.cwd(), path);\n    opts = opts || {};\n\n    if (!path) return { path: \'\', node: null };\n\n    var defaults = {\n        follow_mount: true,\n        recurse_count: 0\n    };\n    for (var key in defaults) {\n        if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n        }\n    }\n\n    if (opts.recurse_count > 8) {  // max recursive lookup of 8\n        throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\n    }\n\n    // split the path\n    var parts = PATH.normalizeArray(path.split(\'/\').filter(function(p) {\n        return !!p;\n    }), false);\n\n    // start at the root\n    var current = FS.root;\n    var current_path = \'/\';\n\n    for (var i = 0; i < parts.length; i++) {\n        var islast = (i === parts.length-1);\n        if (islast && opts.parent) {\n            // stop resolving\n            break;\n        }\n\n        current = FS.lookupNode(current, parts[i]);\n        current_path = PATH.join2(current_path, parts[i]);\n\n        // jump to the mount\'s root node if this is a mountpoint\n        if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n                current = current.mounted.root;\n            }\n        }\n\n        // by default, lookupPath will not follow a symlink if it is the final path component.\n        // setting opts.follow = true will override this behavior.\n        if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n                var link = FS.readlink(current_path);\n                current_path = PATH.resolve(PATH.dirname(current_path), link);\n\n                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });\n                current = lookup.node;\n\n                if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                    throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\n                }\n            }\n        }\n    }\n\n    return { path: current_path, node: current };\n},getPath:function (node) {\n    var path;\n    while (true) {\n        if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length-1] !== \'/\' ? mount + \'/\' + path : mount + path;\n        }\n        path = path ? node.name + \'/\' + path : node.name;\n        node = node.parent;\n    }\n},hashName:function (parentid, name) {\n    var hash = 0;\n\n\n    for (var i = 0; i < name.length; i++) {\n        hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n    }\n    return ((parentid + hash) >>> 0) % FS.nameTable.length;\n},hashAddNode:function (node) {\n    var hash = FS.hashName(node.parent.id, node.name);\n    node.name_next = FS.nameTable[hash];\n    FS.nameTable[hash] = node;\n},hashRemoveNode:function (node) {\n    var hash = FS.hashName(node.parent.id, node.name);\n    if (FS.nameTable[hash] === node) {\n        FS.nameTable[hash] = node.name_next;\n    } else {\n        var current = FS.nameTable[hash];\n        while (current) {\n            if (current.name_next === node) {\n                current.name_next = node.name_next;\n                break;\n            }\n            current = current.name_next;\n        }\n    }\n},lookupNode:function (parent, name) {\n    var err = FS.mayLookup(parent);\n    if (err) {\n        throw new FS.ErrnoError(err, parent);\n    }\n    var hash = FS.hashName(parent.id, name);\n    for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n        var nodeName = node.name;\n        if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n        }\n    }\n    // if we failed to find it in the cache, call into the VFS\n    return FS.lookup(parent, name);\n},createNode:function (parent, name, mode, rdev) {\n    if (!FS.FSNode) {\n        FS.FSNode = function(parent, name, mode, rdev) {\n            if (!parent) {\n                parent = this;  // root node sets parent to itself\n            }\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n        };\n\n        FS.FSNode.prototype = {};\n\n        // compatibility\n        var readMode = 292 | 73;\n        var writeMode = 146;\n\n        // NOTE we must use Object.defineProperties instead of individual calls to\n        // Object.defineProperty in order to make closure compiler happy\n        Object.defineProperties(FS.FSNode.prototype, {\n            read: {\n                get: function() { return (this.mode & readMode) === readMode; },\n                set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }\n            },\n            write: {\n                get: function() { return (this.mode & writeMode) === writeMode; },\n                set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }\n            },\n            isFolder: {\n                get: function() { return FS.isDir(this.mode); }\n            },\n            isDevice: {\n                get: function() { return FS.isChrdev(this.mode); }\n            }\n        });\n    }\n\n    var node = new FS.FSNode(parent, name, mode, rdev);\n\n    FS.hashAddNode(node);\n\n    return node;\n},destroyNode:function (node) {\n    FS.hashRemoveNode(node);\n},isRoot:function (node) {\n    return node === node.parent;\n},isMountpoint:function (node) {\n    return !!node.mounted;\n},isFile:function (mode) {\n    return (mode & 61440) === 32768;\n},isDir:function (mode) {\n    return (mode & 61440) === 16384;\n},isLink:function (mode) {\n    return (mode & 61440) === 40960;\n},isChrdev:function (mode) {\n    return (mode & 61440) === 8192;\n},isBlkdev:function (mode) {\n    return (mode & 61440) === 24576;\n},isFIFO:function (mode) {\n    return (mode & 61440) === 4096;\n},isSocket:function (mode) {\n    return (mode & 49152) === 49152;\n},flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {\n    var flags = FS.flagModes[str];\n    if (typeof flags === \'undefined\') {\n        throw new Error(\'Unknown file open mode: \' + str);\n    }\n    return flags;\n},flagsToPermissionString:function (flag) {\n    var perms = [\'r\', \'w\', \'rw\'][flag & 3];\n    if ((flag & 512)) {\n        perms += \'w\';\n    }\n    return perms;\n},nodePermissions:function (node, perms) {\n    if (FS.ignorePermissions) {\n        return 0;\n    }\n    // return 0 if any user, group or owner bits are set.\n    if (perms.indexOf(\'r\') !== -1 && !(node.mode & 292)) {\n        return ERRNO_CODES.EACCES;\n    } else if (perms.indexOf(\'w\') !== -1 && !(node.mode & 146)) {\n        return ERRNO_CODES.EACCES;\n    } else if (perms.indexOf(\'x\') !== -1 && !(node.mode & 73)) {\n        return ERRNO_CODES.EACCES;\n    }\n    return 0;\n},mayLookup:function (dir) {\n    var err = FS.nodePermissions(dir, \'x\');\n    if (err) return err;\n    if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;\n    return 0;\n},mayCreate:function (dir, name) {\n    try {\n        var node = FS.lookupNode(dir, name);\n        return ERRNO_CODES.EEXIST;\n    } catch (e) {\n    }\n    return FS.nodePermissions(dir, \'wx\');\n},mayDelete:function (dir, name, isdir) {\n    var node;\n    try {\n        node = FS.lookupNode(dir, name);\n    } catch (e) {\n        return e.errno;\n    }\n    var err = FS.nodePermissions(dir, \'wx\');\n    if (err) {\n        return err;\n    }\n    if (isdir) {\n        if (!FS.isDir(node.mode)) {\n            return ERRNO_CODES.ENOTDIR;\n        }\n        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return ERRNO_CODES.EBUSY;\n        }\n    } else {\n        if (FS.isDir(node.mode)) {\n            return ERRNO_CODES.EISDIR;\n        }\n    }\n    return 0;\n},mayOpen:function (node, flags) {\n    if (!node) {\n        return ERRNO_CODES.ENOENT;\n    }\n    if (FS.isLink(node.mode)) {\n        return ERRNO_CODES.ELOOP;\n    } else if (FS.isDir(node.mode)) {\n        if (FS.flagsToPermissionString(flags) !== \'r\' || // opening for write\n            (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\n            return ERRNO_CODES.EISDIR;\n        }\n    }\n    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n},MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {\n    fd_start = fd_start || 0;\n    fd_end = fd_end || FS.MAX_OPEN_FDS;\n    for (var fd = fd_start; fd <= fd_end; fd++) {\n        if (!FS.streams[fd]) {\n            return fd;\n        }\n    }\n    throw new FS.ErrnoError(ERRNO_CODES.EMFILE);\n},getStream:function (fd) {\n    return FS.streams[fd];\n},createStream:function (stream, fd_start, fd_end) {\n    if (!FS.FSStream) {\n        FS.FSStream = function(){};\n        FS.FSStream.prototype = {};\n        // compatibility\n        Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n                get: function() { return this.node; },\n                set: function(val) { this.node = val; }\n            },\n            isRead: {\n                get: function() { return (this.flags & 2097155) !== 1; }\n            },\n            isWrite: {\n                get: function() { return (this.flags & 2097155) !== 0; }\n            },\n            isAppend: {\n                get: function() { return (this.flags & 1024); }\n            }\n        });\n    }\n    // clone it, so we can return an instance of FSStream\n    var newStream = new FS.FSStream();\n    for (var p in stream) {\n        newStream[p] = stream[p];\n    }\n    stream = newStream;\n    var fd = FS.nextfd(fd_start, fd_end);\n    stream.fd = fd;\n    FS.streams[fd] = stream;\n    return stream;\n},closeStream:function (fd) {\n    FS.streams[fd] = null;\n},chrdev_stream_ops:{open:function (stream) {\n    var device = FS.getDevice(stream.node.rdev);\n    // override node\'s stream ops with the device\'s\n    stream.stream_ops = device.stream_ops;\n    // forward the open call\n    if (stream.stream_ops.open) {\n        stream.stream_ops.open(stream);\n    }\n},llseek:function () {\n    throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n}},major:function (dev) {\n    return ((dev) >> 8);\n},minor:function (dev) {\n    return ((dev) & 0xff);\n},makedev:function (ma, mi) {\n    return ((ma) << 8 | (mi));\n},registerDevice:function (dev, ops) {\n    FS.devices[dev] = { stream_ops: ops };\n},getDevice:function (dev) {\n    return FS.devices[dev];\n},getMounts:function (mount) {\n    var mounts = [];\n    var check = [mount];\n\n    while (check.length) {\n        var m = check.pop();\n\n        mounts.push(m);\n\n        check.push.apply(check, m.mounts);\n    }\n\n    return mounts;\n},syncfs:function (populate, callback) {\n    if (typeof(populate) === \'function\') {\n        callback = populate;\n        populate = false;\n    }\n\n    FS.syncFSRequests++;\n\n    if (FS.syncFSRequests > 1) {\n        console.log(\'warning: \' + FS.syncFSRequests + \' FS.syncfs operations in flight at once, probably just doing extra work\');\n    }\n\n    var mounts = FS.getMounts(FS.root.mount);\n    var completed = 0;\n\n    function doCallback(err) {\n        assert(FS.syncFSRequests > 0);\n        FS.syncFSRequests--;\n        return callback(err);\n    }\n\n    function done(err) {\n        if (err) {\n            if (!done.errored) {\n                done.errored = true;\n                return doCallback(err);\n            }\n            return;\n        }\n        if (++completed >= mounts.length) {\n            doCallback(null);\n        }\n    };\n\n    // sync all mounts\n    mounts.forEach(function (mount) {\n        if (!mount.type.syncfs) {\n            return done(null);\n        }\n        mount.type.syncfs(mount, populate, done);\n    });\n},mount:function (type, opts, mountpoint) {\n    var root = mountpoint === \'/\';\n    var pseudo = !mountpoint;\n    var node;\n\n    if (root && FS.root) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n    } else if (!root && !pseudo) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n        mountpoint = lookup.path;  // use the absolute path\n        node = lookup.node;\n\n        if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n\n        if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n    }\n\n    var mount = {\n        type: type,\n        opts: opts,\n        mountpoint: mountpoint,\n        mounts: []\n    };\n\n    // create a root node for the fs\n    var mountRoot = type.mount(mount);\n    mountRoot.mount = mount;\n    mount.root = mountRoot;\n\n    if (root) {\n        FS.root = mountRoot;\n    } else if (node) {\n        // set as a mountpoint\n        node.mounted = mount;\n\n        // add the new mount to the current mount\'s children\n        if (node.mount) {\n            node.mount.mounts.push(mount);\n        }\n    }\n\n    return mountRoot;\n},unmount:function (mountpoint) {\n    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n    if (!FS.isMountpoint(lookup.node)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n\n    // destroy the nodes for this mount, and all its child mounts\n    var node = lookup.node;\n    var mount = node.mounted;\n    var mounts = FS.getMounts(mount);\n\n    Object.keys(FS.nameTable).forEach(function (hash) {\n        var current = FS.nameTable[hash];\n\n        while (current) {\n            var next = current.name_next;\n\n            if (mounts.indexOf(current.mount) !== -1) {\n                FS.destroyNode(current);\n            }\n\n            current = next;\n        }\n    });\n\n    // no longer a mountpoint\n    node.mounted = null;\n\n    // remove this mount from the child mounts\n    var idx = node.mount.mounts.indexOf(mount);\n    assert(idx !== -1);\n    node.mount.mounts.splice(idx, 1);\n},lookup:function (parent, name) {\n    return parent.node_ops.lookup(parent, name);\n},mknod:function (path, mode, dev) {\n    var lookup = FS.lookupPath(path, { parent: true });\n    var parent = lookup.node;\n    var name = PATH.basename(path);\n    if (!name || name === \'.\' || name === \'..\') {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    var err = FS.mayCreate(parent, name);\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    if (!parent.node_ops.mknod) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    return parent.node_ops.mknod(parent, name, mode, dev);\n},create:function (path, mode) {\n    mode = mode !== undefined ? mode : 438 /* 0666 */;\n    mode &= 4095;\n    mode |= 32768;\n    return FS.mknod(path, mode, 0);\n},mkdir:function (path, mode) {\n    mode = mode !== undefined ? mode : 511 /* 0777 */;\n    mode &= 511 | 512;\n    mode |= 16384;\n    return FS.mknod(path, mode, 0);\n},mkdirTree:function (path, mode) {\n    var dirs = path.split(\'/\');\n    var d = \'\';\n    for (var i = 0; i < dirs.length; ++i) {\n        if (!dirs[i]) continue;\n        d += \'/\' + dirs[i];\n        try {\n            FS.mkdir(d, mode);\n        } catch(e) {\n            if (e.errno != ERRNO_CODES.EEXIST) throw e;\n        }\n    }\n},mkdev:function (path, mode, dev) {\n    if (typeof(dev) === \'undefined\') {\n        dev = mode;\n        mode = 438 /* 0666 */;\n    }\n    mode |= 8192;\n    return FS.mknod(path, mode, dev);\n},symlink:function (oldpath, newpath) {\n    if (!PATH.resolve(oldpath)) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    var lookup = FS.lookupPath(newpath, { parent: true });\n    var parent = lookup.node;\n    if (!parent) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    var newname = PATH.basename(newpath);\n    var err = FS.mayCreate(parent, newname);\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    if (!parent.node_ops.symlink) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    return parent.node_ops.symlink(parent, newname, oldpath);\n},rename:function (old_path, new_path) {\n    var old_dirname = PATH.dirname(old_path);\n    var new_dirname = PATH.dirname(new_path);\n    var old_name = PATH.basename(old_path);\n    var new_name = PATH.basename(new_path);\n    // parents must exist\n    var lookup, old_dir, new_dir;\n    try {\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n    } catch (e) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n    }\n    if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    // need to be part of the same mount\n    if (old_dir.mount !== new_dir.mount) {\n        throw new FS.ErrnoError(ERRNO_CODES.EXDEV);\n    }\n    // source must exist\n    var old_node = FS.lookupNode(old_dir, old_name);\n    // old path should not be an ancestor of the new path\n    var relative = PATH.relative(old_path, new_dirname);\n    if (relative.charAt(0) !== \'.\') {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    // new path should not be an ancestor of the old path\n    relative = PATH.relative(new_path, old_dirname);\n    if (relative.charAt(0) !== \'.\') {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n    }\n    // see if the new path already exists\n    var new_node;\n    try {\n        new_node = FS.lookupNode(new_dir, new_name);\n    } catch (e) {\n        // not fatal\n    }\n    // early out if nothing needs to change\n    if (old_node === new_node) {\n        return;\n    }\n    // we\'ll need to delete the old entry\n    var isdir = FS.isDir(old_node.mode);\n    var err = FS.mayDelete(old_dir, old_name, isdir);\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    // need delete permissions if we\'ll be overwriting.\n    // need create permissions if new doesn\'t already exist.\n    err = new_node ?\n        FS.mayDelete(new_dir, new_name, isdir) :\n        FS.mayCreate(new_dir, new_name);\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    if (!old_dir.node_ops.rename) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n    }\n    // if we are going to change the parent, check write permissions\n    if (new_dir !== old_dir) {\n        err = FS.nodePermissions(old_dir, \'w\');\n        if (err) {\n            throw new FS.ErrnoError(err);\n        }\n    }\n    try {\n        if (FS.trackingDelegate[\'willMovePath\']) {\n            FS.trackingDelegate[\'willMovePath\'](old_path, new_path);\n        }\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'willMovePath\'](\'"+old_path+"\', \'"+new_path+"\') threw an exception: " + e.message);\n    }\n    // remove the node from the lookup hash\n    FS.hashRemoveNode(old_node);\n    // do the underlying fs rename\n    try {\n        old_dir.node_ops.rename(old_node, new_dir, new_name);\n    } catch (e) {\n        throw e;\n    } finally {\n        // add the node back to the hash (in case node_ops.rename\n        // changed its name)\n        FS.hashAddNode(old_node);\n    }\n    try {\n        if (FS.trackingDelegate[\'onMovePath\']) FS.trackingDelegate[\'onMovePath\'](old_path, new_path);\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'onMovePath\'](\'"+old_path+"\', \'"+new_path+"\') threw an exception: " + e.message);\n    }\n},rmdir:function (path) {\n    var lookup = FS.lookupPath(path, { parent: true });\n    var parent = lookup.node;\n    var name = PATH.basename(path);\n    var node = FS.lookupNode(parent, name);\n    var err = FS.mayDelete(parent, name, true);\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    if (!parent.node_ops.rmdir) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n    }\n    try {\n        if (FS.trackingDelegate[\'willDeletePath\']) {\n            FS.trackingDelegate[\'willDeletePath\'](path);\n        }\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'willDeletePath\'](\'"+path+"\') threw an exception: " + e.message);\n    }\n    parent.node_ops.rmdir(parent, name);\n    FS.destroyNode(node);\n    try {\n        if (FS.trackingDelegate[\'onDeletePath\']) FS.trackingDelegate[\'onDeletePath\'](path);\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'onDeletePath\'](\'"+path+"\') threw an exception: " + e.message);\n    }\n},readdir:function (path) {\n    var lookup = FS.lookupPath(path, { follow: true });\n    var node = lookup.node;\n    if (!node.node_ops.readdir) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n    }\n    return node.node_ops.readdir(node);\n},unlink:function (path) {\n    var lookup = FS.lookupPath(path, { parent: true });\n    var parent = lookup.node;\n    var name = PATH.basename(path);\n    var node = FS.lookupNode(parent, name);\n    var err = FS.mayDelete(parent, name, false);\n    if (err) {\n        // According to POSIX, we should map EISDIR to EPERM, but\n        // we instead do what Linux does (and we must, as we use\n        // the musl linux libc).\n        throw new FS.ErrnoError(err);\n    }\n    if (!parent.node_ops.unlink) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n    }\n    try {\n        if (FS.trackingDelegate[\'willDeletePath\']) {\n            FS.trackingDelegate[\'willDeletePath\'](path);\n        }\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'willDeletePath\'](\'"+path+"\') threw an exception: " + e.message);\n    }\n    parent.node_ops.unlink(parent, name);\n    FS.destroyNode(node);\n    try {\n        if (FS.trackingDelegate[\'onDeletePath\']) FS.trackingDelegate[\'onDeletePath\'](path);\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'onDeletePath\'](\'"+path+"\') threw an exception: " + e.message);\n    }\n},readlink:function (path) {\n    var lookup = FS.lookupPath(path);\n    var link = lookup.node;\n    if (!link) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    if (!link.node_ops.readlink) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n},stat:function (path, dontFollow) {\n    var lookup = FS.lookupPath(path, { follow: !dontFollow });\n    var node = lookup.node;\n    if (!node) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    if (!node.node_ops.getattr) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    return node.node_ops.getattr(node);\n},lstat:function (path) {\n    return FS.stat(path, true);\n},chmod:function (path, mode, dontFollow) {\n    var node;\n    if (typeof path === \'string\') {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        node = lookup.node;\n    } else {\n        node = path;\n    }\n    if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    node.node_ops.setattr(node, {\n        mode: (mode & 4095) | (node.mode & ~4095),\n        timestamp: Date.now()\n    });\n},lchmod:function (path, mode) {\n    FS.chmod(path, mode, true);\n},fchmod:function (fd, mode) {\n    var stream = FS.getStream(fd);\n    if (!stream) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    }\n    FS.chmod(stream.node, mode);\n},chown:function (path, uid, gid, dontFollow) {\n    var node;\n    if (typeof path === \'string\') {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        node = lookup.node;\n    } else {\n        node = path;\n    }\n    if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    node.node_ops.setattr(node, {\n        timestamp: Date.now()\n        // we ignore the uid / gid for now\n    });\n},lchown:function (path, uid, gid) {\n    FS.chown(path, uid, gid, true);\n},fchown:function (fd, uid, gid) {\n    var stream = FS.getStream(fd);\n    if (!stream) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    }\n    FS.chown(stream.node, uid, gid);\n},truncate:function (path, len) {\n    if (len < 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    var node;\n    if (typeof path === \'string\') {\n        var lookup = FS.lookupPath(path, { follow: true });\n        node = lookup.node;\n    } else {\n        node = path;\n    }\n    if (!node.node_ops.setattr) {\n        throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    if (FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n    }\n    if (!FS.isFile(node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    var err = FS.nodePermissions(node, \'w\');\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    node.node_ops.setattr(node, {\n        size: len,\n        timestamp: Date.now()\n    });\n},ftruncate:function (fd, len) {\n    var stream = FS.getStream(fd);\n    if (!stream) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    }\n    if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    FS.truncate(stream.node, len);\n},utime:function (path, atime, mtime) {\n    var lookup = FS.lookupPath(path, { follow: true });\n    var node = lookup.node;\n    node.node_ops.setattr(node, {\n        timestamp: Math.max(atime, mtime)\n    });\n},open:function (path, flags, mode, fd_start, fd_end) {\n    if (path === "") {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    flags = typeof flags === \'string\' ? FS.modeStringToFlags(flags) : flags;\n    mode = typeof mode === \'undefined\' ? 438 /* 0666 */ : mode;\n    if ((flags & 64)) {\n        mode = (mode & 4095) | 32768;\n    } else {\n        mode = 0;\n    }\n    var node;\n    if (typeof path === \'object\') {\n        node = path;\n    } else {\n        path = PATH.normalize(path);\n        try {\n            var lookup = FS.lookupPath(path, {\n                follow: !(flags & 131072)\n            });\n            node = lookup.node;\n        } catch (e) {\n            // ignore\n        }\n    }\n    // perhaps we need to create the node\n    var created = false;\n    if ((flags & 64)) {\n        if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if ((flags & 128)) {\n                throw new FS.ErrnoError(ERRNO_CODES.EEXIST);\n            }\n        } else {\n            // node doesn\'t exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n        }\n    }\n    if (!node) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    // can\'t truncate a device\n    if (FS.isChrdev(node.mode)) {\n        flags &= ~512;\n    }\n    // if asked only for a directory, then this must be one\n    if ((flags & 65536) && !FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n    }\n    // check permissions, if this is not a file we just created now (it is ok to\n    // create and write to a file with read-only permissions; it is read-only\n    // for later use)\n    if (!created) {\n        var err = FS.mayOpen(node, flags);\n        if (err) {\n            throw new FS.ErrnoError(err);\n        }\n    }\n    // do truncation if necessary\n    if ((flags & 512)) {\n        FS.truncate(node, 0);\n    }\n    // we\'ve already handled these, don\'t pass down to the underlying vfs\n    flags &= ~(128 | 512);\n\n    // register the stream with the filesystem\n    var stream = FS.createStream({\n        node: node,\n        path: FS.getPath(node),  // we want the absolute path to the node\n        flags: flags,\n        seekable: true,\n        position: 0,\n        stream_ops: node.stream_ops,\n        // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n        ungotten: [],\n        error: false\n    }, fd_start, fd_end);\n    // call the new stream\'s open function\n    if (stream.stream_ops.open) {\n        stream.stream_ops.open(stream);\n    }\n    if (Module[\'logReadFiles\'] && !(flags & 1)) {\n        if (!FS.readFiles) FS.readFiles = {};\n        if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            Module[\'printErr\'](\'read file: \' + path);\n        }\n    }\n    try {\n        if (FS.trackingDelegate[\'onOpenFile\']) {\n            var trackingFlags = 0;\n            if ((flags & 2097155) !== 1) {\n                trackingFlags |= FS.tracking.openFlags.READ;\n            }\n            if ((flags & 2097155) !== 0) {\n                trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n            FS.trackingDelegate[\'onOpenFile\'](path, trackingFlags);\n        }\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'onOpenFile\'](\'"+path+"\', flags) threw an exception: " + e.message);\n    }\n    return stream;\n},close:function (stream) {\n    if (stream.getdents) stream.getdents = null; // free readdir state\n    try {\n        if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n        }\n    } catch (e) {\n        throw e;\n    } finally {\n        FS.closeStream(stream.fd);\n    }\n},llseek:function (stream, offset, whence) {\n    if (!stream.seekable || !stream.stream_ops.llseek) {\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n    }\n    stream.position = stream.stream_ops.llseek(stream, offset, whence);\n    stream.ungotten = [];\n    return stream.position;\n},read:function (stream, buffer, offset, length, position) {\n    if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    }\n    if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n    }\n    if (!stream.stream_ops.read) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    var seeking = true;\n    if (typeof position === \'undefined\') {\n        position = stream.position;\n        seeking = false;\n    } else if (!stream.seekable) {\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n    }\n    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n    if (!seeking) stream.position += bytesRead;\n    return bytesRead;\n},write:function (stream, buffer, offset, length, position, canOwn) {\n    if (length < 0 || position < 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    }\n    if (FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n    }\n    if (!stream.stream_ops.write) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    if (stream.flags & 1024) {\n        // seek to the end before writing in append mode\n        FS.llseek(stream, 0, 2);\n    }\n    var seeking = true;\n    if (typeof position === \'undefined\') {\n        position = stream.position;\n        seeking = false;\n    } else if (!stream.seekable) {\n        throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n    }\n    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n    if (!seeking) stream.position += bytesWritten;\n    try {\n        if (stream.path && FS.trackingDelegate[\'onWriteToFile\']) FS.trackingDelegate[\'onWriteToFile\'](stream.path);\n    } catch(e) {\n        console.log("FS.trackingDelegate[\'onWriteToFile\'](\'"+path+"\') threw an exception: " + e.message);\n    }\n    return bytesWritten;\n},allocate:function (stream, offset, length) {\n    if (offset < 0 || length <= 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n    }\n    if ((stream.flags & 2097155) === 0) {\n        throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    }\n    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n    }\n    if (!stream.stream_ops.allocate) {\n        throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);\n    }\n    stream.stream_ops.allocate(stream, offset, length);\n},mmap:function (stream, buffer, offset, length, position, prot, flags) {\n    // TODO if PROT is PROT_WRITE, make sure we have write access\n    if ((stream.flags & 2097155) === 1) {\n        throw new FS.ErrnoError(ERRNO_CODES.EACCES);\n    }\n    if (!stream.stream_ops.mmap) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n    }\n    return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\n},msync:function (stream, buffer, offset, length, mmapFlags) {\n    if (!stream || !stream.stream_ops.msync) {\n        return 0;\n    }\n    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n},munmap:function (stream) {\n    return 0;\n},ioctl:function (stream, cmd, arg) {\n    if (!stream.stream_ops.ioctl) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);\n    }\n    return stream.stream_ops.ioctl(stream, cmd, arg);\n},readFile:function (path, opts) {\n    opts = opts || {};\n    opts.flags = opts.flags || \'r\';\n    opts.encoding = opts.encoding || \'binary\';\n    if (opts.encoding !== \'utf8\' && opts.encoding !== \'binary\') {\n        throw new Error(\'Invalid encoding type "\' + opts.encoding + \'"\');\n    }\n    var ret;\n    var stream = FS.open(path, opts.flags);\n    var stat = FS.stat(path);\n    var length = stat.size;\n    var buf = new Uint8Array(length);\n    FS.read(stream, buf, 0, length, 0);\n    if (opts.encoding === \'utf8\') {\n        ret = UTF8ArrayToString(buf, 0);\n    } else if (opts.encoding === \'binary\') {\n        ret = buf;\n    }\n    FS.close(stream);\n    return ret;\n},writeFile:function (path, data, opts) {\n    opts = opts || {};\n    opts.flags = opts.flags || \'w\';\n    opts.encoding = opts.encoding || \'utf8\';\n    if (opts.encoding !== \'utf8\' && opts.encoding !== \'binary\') {\n        throw new Error(\'Invalid encoding type "\' + opts.encoding + \'"\');\n    }\n    var stream = FS.open(path, opts.flags, opts.mode);\n    if (opts.encoding === \'utf8\') {\n        var buf = new Uint8Array(lengthBytesUTF8(data)+1);\n        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n        FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);\n    } else if (opts.encoding === \'binary\') {\n        FS.write(stream, data, 0, data.length, 0, opts.canOwn);\n    }\n    FS.close(stream);\n},cwd:function () {\n    return FS.currentPath;\n},chdir:function (path) {\n    var lookup = FS.lookupPath(path, { follow: true });\n    if (lookup.node === null) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n    }\n    if (!FS.isDir(lookup.node.mode)) {\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n    }\n    var err = FS.nodePermissions(lookup.node, \'x\');\n    if (err) {\n        throw new FS.ErrnoError(err);\n    }\n    FS.currentPath = lookup.path;\n},createDefaultDirectories:function () {\n    FS.mkdir(\'/tmp\');\n    FS.mkdir(\'/home\');\n    FS.mkdir(\'/home/web_user\');\n},createDefaultDevices:function () {\n    // create /dev\n    FS.mkdir(\'/dev\');\n    // setup /dev/null\n    FS.registerDevice(FS.makedev(1, 3), {\n        read: function() { return 0; },\n        write: function(stream, buffer, offset, length, pos) { return length; }\n    });\n    FS.mkdev(\'/dev/null\', FS.makedev(1, 3));\n    // setup /dev/tty and /dev/tty1\n    // stderr needs to print output using Module[\'printErr\']\n    // so we register a second tty just for it.\n    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n    FS.mkdev(\'/dev/tty\', FS.makedev(5, 0));\n    FS.mkdev(\'/dev/tty1\', FS.makedev(6, 0));\n    // setup /dev/[u]random\n    var random_device;\n    if (typeof crypto !== \'undefined\') {\n        // for modern web browsers\n        var randomBuffer = new Uint8Array(1);\n        random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\n    } else if (ENVIRONMENT_IS_NODE) {\n        // for nodejs\n        random_device = function() { return require(\'crypto\').randomBytes(1)[0]; };\n    } else {\n        // default for ES5 platforms\n        random_device = function() { return (Math.random()*256)|0; };\n    }\n    FS.createDevice(\'/dev\', \'random\', random_device);\n    FS.createDevice(\'/dev\', \'urandom\', random_device);\n    // we\'re not going to emulate the actual shm device,\n    // just create the tmp dirs that reside in it commonly\n    FS.mkdir(\'/dev/shm\');\n    FS.mkdir(\'/dev/shm/tmp\');\n},createSpecialDirectories:function () {\n    // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)\n    FS.mkdir(\'/proc\');\n    FS.mkdir(\'/proc/self\');\n    FS.mkdir(\'/proc/self/fd\');\n    FS.mount({\n        mount: function() {\n            var node = FS.createNode(\'/proc/self\', \'fd\', 16384 | 511 /* 0777 */, 73);\n            node.node_ops = {\n                lookup: function(parent, name) {\n                    var fd = +name;\n                    var stream = FS.getStream(fd);\n                    if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n                    var ret = {\n                        parent: null,\n                        mount: { mountpoint: \'fake\' },\n                        node_ops: { readlink: function() { return stream.path } }\n                    };\n                    ret.parent = ret; // make it look like a simple root node\n                    return ret;\n                }\n            };\n            return node;\n        }\n    }, {}, \'/proc/self/fd\');\n},createStandardStreams:function () {\n    // TODO deprecate the old functionality of a single\n    // input / output callback and that utilizes FS.createDevice\n    // and instead require a unique set of stream ops\n\n    // by default, we symlink the standard streams to the\n    // default tty devices. however, if the standard streams\n    // have been overwritten we create a unique device for\n    // them instead.\n    if (Module[\'stdin\']) {\n        FS.createDevice(\'/dev\', \'stdin\', Module[\'stdin\']);\n    } else {\n        FS.symlink(\'/dev/tty\', \'/dev/stdin\');\n    }\n    if (Module[\'stdout\']) {\n        FS.createDevice(\'/dev\', \'stdout\', null, Module[\'stdout\']);\n    } else {\n        FS.symlink(\'/dev/tty\', \'/dev/stdout\');\n    }\n    if (Module[\'stderr\']) {\n        FS.createDevice(\'/dev\', \'stderr\', null, Module[\'stderr\']);\n    } else {\n        FS.symlink(\'/dev/tty1\', \'/dev/stderr\');\n    }\n\n    // open default streams for the stdin, stdout and stderr devices\n    var stdin = FS.open(\'/dev/stdin\', \'r\');\n    assert(stdin.fd === 0, \'invalid handle for stdin (\' + stdin.fd + \')\');\n\n    var stdout = FS.open(\'/dev/stdout\', \'w\');\n    assert(stdout.fd === 1, \'invalid handle for stdout (\' + stdout.fd + \')\');\n\n    var stderr = FS.open(\'/dev/stderr\', \'w\');\n    assert(stderr.fd === 2, \'invalid handle for stderr (\' + stderr.fd + \')\');\n},ensureErrnoError:function () {\n    if (FS.ErrnoError) return;\n    FS.ErrnoError = function ErrnoError(errno, node) {\n        //Module.printErr(stackTrace()); // useful for debugging\n        this.node = node;\n        this.setErrno = function(errno) {\n            this.errno = errno;\n            for (var key in ERRNO_CODES) {\n                if (ERRNO_CODES[key] === errno) {\n                    this.code = key;\n                    break;\n                }\n            }\n        };\n        this.setErrno(errno);\n        this.message = ERRNO_MESSAGES[errno];\n    };\n    FS.ErrnoError.prototype = new Error();\n    FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n    // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n    [ERRNO_CODES.ENOENT].forEach(function(code) {\n        FS.genericErrors[code] = new FS.ErrnoError(code);\n        FS.genericErrors[code].stack = \'<generic error, no stack>\';\n    });\n},staticInit:function () {\n    FS.ensureErrnoError();\n\n    FS.nameTable = new Array(4096);\n\n    FS.mount(MEMFS, {}, \'/\');\n\n    FS.createDefaultDirectories();\n    FS.createDefaultDevices();\n    FS.createSpecialDirectories();\n\n    FS.filesystems = {\n        \'MEMFS\': MEMFS,\n        \'IDBFS\': IDBFS,\n        \'NODEFS\': NODEFS,\n        \'WORKERFS\': WORKERFS,\n    };\n},init:function (input, output, error) {\n    assert(!FS.init.initialized, \'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\');\n    FS.init.initialized = true;\n\n    FS.ensureErrnoError();\n\n    // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n    Module[\'stdin\'] = input || Module[\'stdin\'];\n    Module[\'stdout\'] = output || Module[\'stdout\'];\n    Module[\'stderr\'] = error || Module[\'stderr\'];\n\n    FS.createStandardStreams();\n},quit:function () {\n    FS.init.initialized = false;\n    // force-flush all streams, so we get musl std streams printed out\n    var fflush = Module[\'_fflush\'];\n    if (fflush) fflush(0);\n    // close all of our streams\n    for (var i = 0; i < FS.streams.length; i++) {\n        var stream = FS.streams[i];\n        if (!stream) {\n            continue;\n        }\n        FS.close(stream);\n    }\n},getMode:function (canRead, canWrite) {\n    var mode = 0;\n    if (canRead) mode |= 292 | 73;\n    if (canWrite) mode |= 146;\n    return mode;\n},joinPath:function (parts, forceRelative) {\n    var path = PATH.join.apply(null, parts);\n    if (forceRelative && path[0] == \'/\') path = path.substr(1);\n    return path;\n},absolutePath:function (relative, base) {\n    return PATH.resolve(base, relative);\n},standardizePath:function (path) {\n    return PATH.normalize(path);\n},findObject:function (path, dontResolveLastLink) {\n    var ret = FS.analyzePath(path, dontResolveLastLink);\n    if (ret.exists) {\n        return ret.object;\n    } else {\n        ___setErrNo(ret.error);\n        return null;\n    }\n},analyzePath:function (path, dontResolveLastLink) {\n    // operate from within the context of the symlink\'s target\n    try {\n        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n        path = lookup.path;\n    } catch (e) {\n    }\n    var ret = {\n        isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n        parentExists: false, parentPath: null, parentObject: null\n    };\n    try {\n        var lookup = FS.lookupPath(path, { parent: true });\n        ret.parentExists = true;\n        ret.parentPath = lookup.path;\n        ret.parentObject = lookup.node;\n        ret.name = PATH.basename(path);\n        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n        ret.exists = true;\n        ret.path = lookup.path;\n        ret.object = lookup.node;\n        ret.name = lookup.node.name;\n        ret.isRoot = lookup.path === \'/\';\n    } catch (e) {\n        ret.error = e.errno;\n    };\n    return ret;\n},createFolder:function (parent, name, canRead, canWrite) {\n    var path = PATH.join2(typeof parent === \'string\' ? parent : FS.getPath(parent), name);\n    var mode = FS.getMode(canRead, canWrite);\n    return FS.mkdir(path, mode);\n},createPath:function (parent, path, canRead, canWrite) {\n    parent = typeof parent === \'string\' ? parent : FS.getPath(parent);\n    var parts = path.split(\'/\').reverse();\n    while (parts.length) {\n        var part = parts.pop();\n        if (!part) continue;\n        var current = PATH.join2(parent, part);\n        try {\n            FS.mkdir(current);\n        } catch (e) {\n            // ignore EEXIST\n        }\n        parent = current;\n    }\n    return current;\n},createFile:function (parent, name, properties, canRead, canWrite) {\n    var path = PATH.join2(typeof parent === \'string\' ? parent : FS.getPath(parent), name);\n    var mode = FS.getMode(canRead, canWrite);\n    return FS.create(path, mode);\n},createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {\n    var path = name ? PATH.join2(typeof parent === \'string\' ? parent : FS.getPath(parent), name) : parent;\n    var mode = FS.getMode(canRead, canWrite);\n    var node = FS.create(path, mode);\n    if (data) {\n        if (typeof data === \'string\') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n        }\n        // make sure we can write to the file\n        FS.chmod(node, mode | 146);\n        var stream = FS.open(node, \'w\');\n        FS.write(stream, data, 0, data.length, 0, canOwn);\n        FS.close(stream);\n        FS.chmod(node, mode);\n    }\n    return node;\n},createDevice:function (parent, name, input, output) {\n    var path = PATH.join2(typeof parent === \'string\' ? parent : FS.getPath(parent), name);\n    var mode = FS.getMode(!!input, !!output);\n    if (!FS.createDevice.major) FS.createDevice.major = 64;\n    var dev = FS.makedev(FS.createDevice.major++, 0);\n    // Create a fake device that a set of stream ops to emulate\n    // the old behavior.\n    FS.registerDevice(dev, {\n        open: function(stream) {\n            stream.seekable = false;\n        },\n        close: function(stream) {\n            // flush any pending line data\n            if (output && output.buffer && output.buffer.length) {\n                output(10);\n            }\n        },\n        read: function(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n                var result;\n                try {\n                    result = input();\n                } catch (e) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EIO);\n                }\n                if (result === undefined && bytesRead === 0) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n                }\n                if (result === null || result === undefined) break;\n                bytesRead++;\n                buffer[offset+i] = result;\n            }\n            if (bytesRead) {\n                stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n        },\n        write: function(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n                try {\n                    output(buffer[offset+i]);\n                } catch (e) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EIO);\n                }\n            }\n            if (length) {\n                stream.node.timestamp = Date.now();\n            }\n            return i;\n        }\n    });\n    return FS.mkdev(path, mode, dev);\n},createLink:function (parent, name, target, canRead, canWrite) {\n    var path = PATH.join2(typeof parent === \'string\' ? parent : FS.getPath(parent), name);\n    return FS.symlink(target, path);\n},forceLoadFile:function (obj) {\n    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n    var success = true;\n    if (typeof XMLHttpRequest !== \'undefined\') {\n        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");\n    } else if (Module[\'read\']) {\n        // Command-line.\n        try {\n            // WARNING: Can\'t read binary files in V8\'s d8 or tracemonkey\'s js, as\n            //          read() will try to parse UTF8.\n            obj.contents = intArrayFromString(Module[\'read\'](obj.url), true);\n            obj.usedBytes = obj.contents.length;\n        } catch (e) {\n            success = false;\n        }\n    } else {\n        throw new Error(\'Cannot load without read() or XMLHttpRequest.\');\n    }\n    if (!success) ___setErrNo(ERRNO_CODES.EIO);\n    return success;\n},createLazyFile:function (parent, name, url, canRead, canWrite) {\n    // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\n    function LazyUint8Array() {\n        this.lengthKnown = false;\n        this.chunks = []; // Loaded chunks. Index is the chunk number\n    }\n    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n        if (idx > this.length-1 || idx < 0) {\n            return undefined;\n        }\n        var chunkOffset = idx % this.chunkSize;\n        var chunkNum = (idx / this.chunkSize)|0;\n        return this.getter(chunkNum)[chunkOffset];\n    }\n    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n        this.getter = getter;\n    }\n    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n        // Find length\n        var xhr = new XMLHttpRequest();\n        xhr.open(\'HEAD\', url, false);\n        xhr.send(null);\n        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);\n        var datalength = Number(xhr.getResponseHeader("Content-length"));\n        var header;\n        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";\n        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";\n\n        var chunkSize = 1024*1024; // Chunk size in bytes\n\n        if (!hasByteServing) chunkSize = datalength;\n\n        // Function to get a range from the remote URL.\n        var doXHR = (function(from, to) {\n            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");\n            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");\n\n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n            var xhr = new XMLHttpRequest();\n            xhr.open(\'GET\', url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);\n\n            // Some hints to the browser that we want binary data.\n            if (typeof Uint8Array != \'undefined\') xhr.responseType = \'arraybuffer\';\n            if (xhr.overrideMimeType) {\n                xhr.overrideMimeType(\'text/plain; charset=x-user-defined\');\n            }\n\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);\n            if (xhr.response !== undefined) {\n                return new Uint8Array(xhr.response || []);\n            } else {\n                return intArrayFromString(xhr.responseText || \'\', true);\n            }\n        });\n        var lazyArray = this;\n        lazyArray.setDataGetter(function(chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\n            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");\n            return lazyArray.chunks[chunkNum];\n        });\n\n        if (usesGzip || !datalength) {\n            // if the server uses gzip or doesn\'t supply the length, we have to download the whole file to get the (uncompressed) length\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            console.log("LazyFiles on gzip forces download of the whole file when length is accessed");\n        }\n\n        this._length = datalength;\n        this._chunkSize = chunkSize;\n        this.lengthKnown = true;\n    }\n    if (typeof XMLHttpRequest !== \'undefined\') {\n        if (!ENVIRONMENT_IS_WORKER) throw \'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\';\n        var lazyArray = new LazyUint8Array();\n        Object.defineProperties(lazyArray, {\n            length: {\n                get: function() {\n                    if(!this.lengthKnown) {\n                        this.cacheLength();\n                    }\n                    return this._length;\n                }\n            },\n            chunkSize: {\n                get: function() {\n                    if(!this.lengthKnown) {\n                        this.cacheLength();\n                    }\n                    return this._chunkSize;\n                }\n            }\n        });\n\n        var properties = { isDevice: false, contents: lazyArray };\n    } else {\n        var properties = { isDevice: false, url: url };\n    }\n\n    var node = FS.createFile(parent, name, properties, canRead, canWrite);\n    // This is a total hack, but I want to get this lazy file code out of the\n    // core of MEMFS. If we want to keep this lazy file concept I feel it should\n    // be its own thin LAZYFS proxying calls to MEMFS.\n    if (properties.contents) {\n        node.contents = properties.contents;\n    } else if (properties.url) {\n        node.contents = null;\n        node.url = properties.url;\n    }\n    // Add a function that defers querying the file size until it is asked the first time.\n    Object.defineProperties(node, {\n        usedBytes: {\n            get: function() { return this.contents.length; }\n        }\n    });\n    // override each stream op with one that tries to force load the lazy file first\n    var stream_ops = {};\n    var keys = Object.keys(node.stream_ops);\n    keys.forEach(function(key) {\n        var fn = node.stream_ops[key];\n        stream_ops[key] = function forceLoadLazyFile() {\n            if (!FS.forceLoadFile(node)) {\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n            return fn.apply(null, arguments);\n        };\n    });\n    // use a custom read function\n    stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n        if (!FS.forceLoadFile(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        }\n        var contents = stream.node.contents;\n        if (position >= contents.length)\n            return 0;\n        var size = Math.min(contents.length - position, length);\n        assert(size >= 0);\n        if (contents.slice) { // normal array\n            for (var i = 0; i < size; i++) {\n                buffer[offset + i] = contents[position + i];\n            }\n        } else {\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n                buffer[offset + i] = contents.get(position + i);\n            }\n        }\n        return size;\n    };\n    node.stream_ops = stream_ops;\n    return node;\n},createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n    Browser.init(); // XXX perhaps this method should move onto Browser?\n    // TODO we should allow people to just pass in a complete filename instead\n    // of parent and name being that we just join them anyways\n    var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\n    var dep = getUniqueRunDependency(\'cp \' + fullname); // might have several active requests for the same fullname\n    function processData(byteArray) {\n        function finish(byteArray) {\n            if (preFinish) preFinish();\n            if (!dontCreateFile) {\n                FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n            if (onload) onload();\n            removeRunDependency(dep);\n        }\n        var handled = false;\n        Module[\'preloadPlugins\'].forEach(function(plugin) {\n            if (handled) return;\n            if (plugin[\'canHandle\'](fullname)) {\n                plugin[\'handle\'](byteArray, fullname, finish, function() {\n                    if (onerror) onerror();\n                    removeRunDependency(dep);\n                });\n                handled = true;\n            }\n        });\n        if (!handled) finish(byteArray);\n    }\n    addRunDependency(dep);\n    if (typeof url == \'string\') {\n        Browser.asyncLoad(url, function(byteArray) {\n            processData(byteArray);\n        }, onerror);\n    } else {\n        processData(url);\n    }\n},indexedDB:function () {\n    return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n},DB_NAME:function () {\n    return \'EM_FS_\' + window.location.pathname;\n},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {\n    onload = onload || function(){};\n    onerror = onerror || function(){};\n    var indexedDB = FS.indexedDB();\n    try {\n        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n    } catch (e) {\n        return onerror(e);\n    }\n    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n        console.log(\'creating db\');\n        var db = openRequest.result;\n        db.createObjectStore(FS.DB_STORE_NAME);\n    };\n    openRequest.onsuccess = function openRequest_onsuccess() {\n        var db = openRequest.result;\n        var transaction = db.transaction([FS.DB_STORE_NAME], \'readwrite\');\n        var files = transaction.objectStore(FS.DB_STORE_NAME);\n        var ok = 0, fail = 0, total = paths.length;\n        function finish() {\n            if (fail == 0) onload(); else onerror();\n        }\n        paths.forEach(function(path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };\n            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };\n        });\n        transaction.onerror = onerror;\n    };\n    openRequest.onerror = onerror;\n},loadFilesFromDB:function (paths, onload, onerror) {\n    onload = onload || function(){};\n    onerror = onerror || function(){};\n    var indexedDB = FS.indexedDB();\n    try {\n        var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n    } catch (e) {\n        return onerror(e);\n    }\n    openRequest.onupgradeneeded = onerror; // no database to load from\n    openRequest.onsuccess = function openRequest_onsuccess() {\n        var db = openRequest.result;\n        try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \'readonly\');\n        } catch(e) {\n            onerror(e);\n            return;\n        }\n        var files = transaction.objectStore(FS.DB_STORE_NAME);\n        var ok = 0, fail = 0, total = paths.length;\n        function finish() {\n            if (fail == 0) onload(); else onerror();\n        }\n        paths.forEach(function(path) {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = function getRequest_onsuccess() {\n                if (FS.analyzePath(path).exists) {\n                    FS.unlink(path);\n                }\n                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n                ok++;\n                if (ok + fail == total) finish();\n            };\n            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };\n        });\n        transaction.onerror = onerror;\n    };\n    openRequest.onerror = onerror;\n}};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function (dirfd, path) {\n    if (path[0] !== \'/\') {\n        // relative path\n        var dir;\n        if (dirfd === -100) {\n            dir = FS.cwd();\n        } else {\n            var dirstream = FS.getStream(dirfd);\n            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n            dir = dirstream.path;\n        }\n        path = PATH.join2(dir, path);\n    }\n    return path;\n},doStat:function (func, path, buf) {\n    try {\n        var stat = func(path);\n    } catch (e) {\n        if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\n            return -ERRNO_CODES.ENOTDIR;\n        }\n        throw e;\n    }\n    HEAP32[((buf)>>2)]=stat.dev;\n    HEAP32[(((buf)+(4))>>2)]=0;\n    HEAP32[(((buf)+(8))>>2)]=stat.ino;\n    HEAP32[(((buf)+(12))>>2)]=stat.mode;\n    HEAP32[(((buf)+(16))>>2)]=stat.nlink;\n    HEAP32[(((buf)+(20))>>2)]=stat.uid;\n    HEAP32[(((buf)+(24))>>2)]=stat.gid;\n    HEAP32[(((buf)+(28))>>2)]=stat.rdev;\n    HEAP32[(((buf)+(32))>>2)]=0;\n    HEAP32[(((buf)+(36))>>2)]=stat.size;\n    HEAP32[(((buf)+(40))>>2)]=4096;\n    HEAP32[(((buf)+(44))>>2)]=stat.blocks;\n    HEAP32[(((buf)+(48))>>2)]=(stat.atime.getTime() / 1000)|0;\n    HEAP32[(((buf)+(52))>>2)]=0;\n    HEAP32[(((buf)+(56))>>2)]=(stat.mtime.getTime() / 1000)|0;\n    HEAP32[(((buf)+(60))>>2)]=0;\n    HEAP32[(((buf)+(64))>>2)]=(stat.ctime.getTime() / 1000)|0;\n    HEAP32[(((buf)+(68))>>2)]=0;\n    HEAP32[(((buf)+(72))>>2)]=stat.ino;\n    return 0;\n},doMsync:function (addr, stream, len, flags) {\n    var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\n    FS.msync(stream, buffer, 0, len, flags);\n},doMkdir:function (path, mode) {\n    // remove a trailing slash, if one - /a/b/ has basename of \'\', but\n    // we want to create b in the context of this function\n    path = PATH.normalize(path);\n    if (path[path.length-1] === \'/\') path = path.substr(0, path.length-1);\n    FS.mkdir(path, mode, 0);\n    return 0;\n},doMknod:function (path, mode, dev) {\n    // we don\'t want this in the JS API as it uses mknod to create all nodes.\n    switch (mode & 61440) {\n        case 32768:\n        case 8192:\n        case 24576:\n        case 4096:\n        case 49152:\n            break;\n        default: return -ERRNO_CODES.EINVAL;\n    }\n    FS.mknod(path, mode, dev);\n    return 0;\n},doReadlink:function (path, buf, bufsize) {\n    if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\n    var ret = FS.readlink(path);\n\n    var len = Math.min(bufsize, lengthBytesUTF8(ret));\n    var endChar = HEAP8[buf+len];\n    stringToUTF8(ret, buf, bufsize+1);\n    // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)\n    // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.\n    HEAP8[buf+len] = endChar;\n\n    return len;\n},doAccess:function (path, amode) {\n    if (amode & ~7) {\n        // need a valid mode\n        return -ERRNO_CODES.EINVAL;\n    }\n    var node;\n    var lookup = FS.lookupPath(path, { follow: true });\n    node = lookup.node;\n    var perms = \'\';\n    if (amode & 4) perms += \'r\';\n    if (amode & 2) perms += \'w\';\n    if (amode & 1) perms += \'x\';\n    if (perms /* otherwise, they\'ve just passed F_OK */ && FS.nodePermissions(node, perms)) {\n        return -ERRNO_CODES.EACCES;\n    }\n    return 0;\n},doDup:function (path, flags, suggestFD) {\n    var suggest = FS.getStream(suggestFD);\n    if (suggest) FS.close(suggest);\n    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n},doReadv:function (stream, iov, iovcnt, offset) {\n    var ret = 0;\n    for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        var curr = FS.read(stream, HEAP8,ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break; // nothing more to read\n    }\n    return ret;\n},doWritev:function (stream, iov, iovcnt, offset) {\n    var ret = 0;\n    for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        var curr = FS.write(stream, HEAP8,ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n    }\n    return ret;\n},varargs:0,get:function (varargs) {\n    SYSCALLS.varargs += 4;\n    var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n    return ret;\n},getStr:function () {\n    var ret = Pointer_stringify(SYSCALLS.get());\n    return ret;\n},getStreamFromFD:function () {\n    var stream = FS.getStream(SYSCALLS.get());\n    if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    return stream;\n},getSocketFromFD:function () {\n    var socket = SOCKFS.getSocket(SYSCALLS.get());\n    if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n    return socket;\n},getSocketAddress:function (allowNull) {\n    var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();\n    if (allowNull && addrp === 0) return null;\n    var info = __read_sockaddr(addrp, addrlen);\n    if (info.errno) throw new FS.ErrnoError(info.errno);\n    info.addr = DNS.lookup_addr(info.addr) || info.addr;\n    return info;\n},get64:function () {\n    var low = SYSCALLS.get(), high = SYSCALLS.get();\n    if (low >= 0) assert(high === 0);\n    else assert(high === -1);\n    return low;\n},getZero:function () {\n    assert(SYSCALLS.get() === 0);\n}};function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // ioctl\n        var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();\n        switch (op) {\n            case 21505: {\n                if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                return 0;\n            }\n            case 21506: {\n                if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                return 0; // no-op, not actually adjusting terminal settings\n            }\n            case 21519: {\n                if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                var argp = SYSCALLS.get();\n                HEAP32[((argp)>>2)]=0;\n                return 0;\n            }\n            case 21520: {\n                if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                return -ERRNO_CODES.EINVAL; // not supported\n            }\n            case 21531: {\n                var argp = SYSCALLS.get();\n                return FS.ioctl(stream, op, argp);\n            }\n            case 21523: {\n                // TODO: in theory we should write to the winsize struct that gets\n                // passed in, but for now musl doesn\'t read anything on it\n                if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                return 0;\n            }\n            default: abort(\'bad ioctl syscall \' + op);\n        }\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\n\nvar ___tm_current=STATICTOP; STATICTOP += 48;;\n\nfunction ___cxa_pure_virtual() {\n    ABORT = true;\n    throw \'Pure virtual function called!\';\n}\n\nfunction _pthread_cond_init() { return 0; }\n\n\n\nfunction _pthread_join() {}\n\n\n\nfunction ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // open\n        var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get() // optional TODO\n        var stream = FS.open(pathname, flags, mode);\n        return stream.fd;\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\n\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    return dest;\n}\n\nfunction ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // close\n        var stream = SYSCALLS.getStreamFromFD();\n        FS.close(stream);\n        return 0;\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\n\n\n\nvar cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", ALLOC_STATIC);function _llvm_cttz_i32(x) {\n    x = x|0;\n    var ret = 0;\n    ret = ((HEAP8[(((cttz_i8)+(x & 0xff))>>0)])|0);\n    if ((ret|0) < 8) return ret|0;\n    ret = ((HEAP8[(((cttz_i8)+((x >> 8)&0xff))>>0)])|0);\n    if ((ret|0) < 8) return (ret + 8)|0;\n    ret = ((HEAP8[(((cttz_i8)+((x >> 16)&0xff))>>0)])|0);\n    if ((ret|0) < 8) return (ret + 16)|0;\n    return (((HEAP8[(((cttz_i8)+(x >>> 24))>>0)])|0) + 24)|0;\n}\n\n\n\n\n\n\nfunction __ZSt18uncaught_exceptionv() { // std::uncaught_exception()\n    return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n}\n\nvar EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {\n    if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n    for (var ptr in EXCEPTIONS.infos) {\n        var info = EXCEPTIONS.infos[ptr];\n        if (info.adjusted === adjusted) {\n            return ptr;\n        }\n    }\n    return adjusted;\n},addRef:function (ptr) {\n    if (!ptr) return;\n    var info = EXCEPTIONS.infos[ptr];\n    info.refcount++;\n},decRef:function (ptr) {\n    if (!ptr) return;\n    var info = EXCEPTIONS.infos[ptr];\n    assert(info.refcount > 0);\n    info.refcount--;\n    // A rethrown exception can reach refcount 0; it must not be discarded\n    // Its next handler will clear the rethrown flag and addRef it, prior to\n    // final decRef and destruction here\n    if (info.refcount === 0 && !info.rethrown) {\n        if (info.destructor) {\n            Module[\'dynCall_vi\'](info.destructor, ptr);\n        }\n        delete EXCEPTIONS.infos[ptr];\n        ___cxa_free_exception(ptr);\n    }\n},clearRef:function (ptr) {\n    if (!ptr) return;\n    var info = EXCEPTIONS.infos[ptr];\n    info.refcount = 0;\n}};function ___cxa_begin_catch(ptr) {\n    var info = EXCEPTIONS.infos[ptr];\n    if (info && !info.caught) {\n        info.caught = true;\n        __ZSt18uncaught_exceptionv.uncaught_exception--;\n    }\n    if (info) info.rethrown = false;\n    EXCEPTIONS.caught.push(ptr);\n    EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));\n    return ptr;\n}\n\n\n\nfunction ___resumeException(ptr) {\n    if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }\n    throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";\n}function ___cxa_find_matching_catch() {\n    var thrown = EXCEPTIONS.last;\n    if (!thrown) {\n        // just pass through the null ptr\n        return ((Runtime.setTempRet0(0),0)|0);\n    }\n    var info = EXCEPTIONS.infos[thrown];\n    var throwntype = info.type;\n    if (!throwntype) {\n        // just pass through the thrown ptr\n        return ((Runtime.setTempRet0(0),thrown)|0);\n    }\n    var typeArray = Array.prototype.slice.call(arguments);\n\n    var pointer = Module[\'___cxa_is_pointer_type\'](throwntype);\n    // can_catch receives a **, add indirection\n    if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);\n    HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;\n    thrown = ___cxa_find_matching_catch.buffer;\n    // The different catch blocks are denoted by different types.\n    // Due to inheritance, those types may not precisely match the\n    // type of the thrown object. Find one which matches, and\n    // return the type of the catch block which should be called.\n    for (var i = 0; i < typeArray.length; i++) {\n        if (typeArray[i] && Module[\'___cxa_can_catch\'](typeArray[i], throwntype, thrown)) {\n            thrown = HEAP32[((thrown)>>2)]; // undo indirection\n            info.adjusted = thrown;\n            return ((Runtime.setTempRet0(typeArray[i]),thrown)|0);\n        }\n    }\n    // Shouldn\'t happen unless we have bogus data in typeArray\n    // or encounter a type for which emscripten doesn\'t have suitable\n    // typeinfo defined. Best-efforts match just in case.\n    thrown = HEAP32[((thrown)>>2)]; // undo indirection\n    return ((Runtime.setTempRet0(throwntype),thrown)|0);\n}function ___gxx_personality_v0() {\n}\n\n\n\nfunction _pthread_mutexattr_init() {}\n\n\n\nfunction ___cxa_free_exception(ptr) {\n    try {\n        return _free(ptr);\n    } catch(e) { // XXX FIXME\n    }\n}function ___cxa_end_catch() {\n    // Clear state flag.\n    Module[\'setThrew\'](0);\n    // Call destructor if one is registered then clear it.\n    var ptr = EXCEPTIONS.caught.pop();\n    if (ptr) {\n        EXCEPTIONS.decRef(EXCEPTIONS.deAdjust(ptr));\n        EXCEPTIONS.last = 0; // XXX in decRef?\n    }\n}function ___cxa_rethrow() {\n    var ptr = EXCEPTIONS.caught.pop();\n    if (!EXCEPTIONS.infos[ptr].rethrown) {\n        // Only pop if the corresponding push was through rethrow_primary_exception\n        EXCEPTIONS.caught.push(ptr)\n        EXCEPTIONS.infos[ptr].rethrown = true;\n    }\n    EXCEPTIONS.last = ptr;\n    throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";\n}\n\nfunction _time(ptr) {\n    var ret = (Date.now()/1000)|0;\n    if (ptr) {\n      HEAP32[((ptr)>>2)]=ret;\n    }\n    return ret;\n  }\n\n  function _localtime(time) {\n    return _localtime_r(time, ___tm_current);\n  }\n\n  function _localtime_r(time, tmPtr) {\n    _tzset();\n    var date = new Date(HEAP32[((time)>>2)]*1000);\n    HEAP32[((tmPtr)>>2)]=date.getSeconds();\n    HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();\n    HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();\n    HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();\n    HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();\n    HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;\n    HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();\n\n    var start = new Date(date.getFullYear(), 0, 1);\n    var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;\n    HEAP32[(((tmPtr)+(28))>>2)]=yday;\n    HEAP32[(((tmPtr)+(36))>>2)]=-(date.getTimezoneOffset() * 60);\n\n    // DST is in December in South\n    var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();\n    var winterOffset = start.getTimezoneOffset();\n    var dst = (date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;\n    HEAP32[(((tmPtr)+(32))>>2)]=dst;\n\n    var zonePtr = HEAP32[(((_tzname)+(dst ? Runtime.QUANTUM_SIZE : 0))>>2)];\n    HEAP32[(((tmPtr)+(40))>>2)]=zonePtr;\n\n    return tmPtr;\n  }\n\nfunction ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // llseek\n        var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();\n        // NOTE: offset_high is unused - Emscripten\'s off_t is 32-bit\n        var offset = offset_low;\n        FS.llseek(stream, offset, whence);\n        HEAP32[((result)>>2)]=stream.position;\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n        return 0;\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\n\nfunction ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // writev\n        var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n        return SYSCALLS.doWritev(stream, iov, iovcnt);\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\n\nfunction ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // fcntl64\n        var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();\n        switch (cmd) {\n            case 0: {\n                var arg = SYSCALLS.get();\n                if (arg < 0) {\n                    return -ERRNO_CODES.EINVAL;\n                }\n                var newStream;\n                newStream = FS.open(stream.path, stream.flags, 0, arg);\n                return newStream.fd;\n            }\n            case 1:\n            case 2:\n                return 0;  // FD_CLOEXEC makes no sense for a single process.\n            case 3:\n                return stream.flags;\n            case 4: {\n                var arg = SYSCALLS.get();\n                stream.flags |= arg;\n                return 0;\n            }\n            case 12:\n            case 12: {\n                var arg = SYSCALLS.get();\n                var offset = 0;\n                // We\'re always unlocked.\n                HEAP16[(((arg)+(offset))>>1)]=2;\n                return 0;\n            }\n            case 13:\n            case 14:\n            case 13:\n            case 14:\n                return 0; // Pretend that the locking is successful.\n            case 16:\n            case 8:\n                return -ERRNO_CODES.EINVAL; // These are for sockets. We don\'t have them fully implemented yet.\n            case 9:\n                // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.\n                ___setErrNo(ERRNO_CODES.EINVAL);\n                return -1;\n            default: {\n                return -ERRNO_CODES.EINVAL;\n            }\n        }\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\n\nfunction ___syscall145(which, varargs) {SYSCALLS.varargs = varargs;\n    try {\n        // readv\n        var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n        return SYSCALLS.doReadv(stream, iov, iovcnt);\n    } catch (e) {\n        if (typeof FS === \'undefined\' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n    }\n}\nFS.staticInit();__ATINIT__.unshift(function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;Module["FS_unlink"] = FS.unlink;;\n__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });;\nif (ENVIRONMENT_IS_NODE) { var fs = require("fs"); var NODEJS_PATH = require("path"); NODEFS.staticInit(); };\nDYNAMICTOP_PTR = allocate(1, "i32", ALLOC_STATIC);\n\nSTACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);\n\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\n\nDYNAMIC_BASE = Runtime.alignMemory(STACK_MAX);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\nstaticSealed = true; // seal the static portion of memory\n\n\nModule[\'wasmTableSize\'] = 306;\n\nModule[\'wasmMaxTableSize\'] = 306;\n\nfunction invoke_vi(index,a1) {\n    try {\n        Module["dynCall_vi"](index,a1);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_iiii(index,a1,a2,a3) {\n    try {\n        return Module["dynCall_iiii"](index,a1,a2,a3);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {\n    try {\n        Module["dynCall_viiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiiii(index,a1,a2,a3,a4,a5) {\n    try {\n        Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {\n    try {\n        return Module["dynCall_iiiiiii"](index,a1,a2,a3,a4,a5,a6);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_vii(index,a1,a2) {\n    try {\n        Module["dynCall_vii"](index,a1,a2);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {\n    try {\n        return Module["dynCall_iiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {\n    try {\n        Module["dynCall_viiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_ii(index,a1) {\n    try {\n        return Module["dynCall_ii"](index,a1);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {\n    try {\n        Module["dynCall_viiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {\n    try {\n        Module["dynCall_viiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_v(index) {\n    try {\n        Module["dynCall_v"](index);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_iiiii(index,a1,a2,a3,a4) {\n    try {\n        return Module["dynCall_iiiii"](index,a1,a2,a3,a4);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {\n    try {\n        Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_iii(index,a1,a2) {\n    try {\n        return Module["dynCall_iii"](index,a1,a2);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nfunction invoke_viiii(index,a1,a2,a3,a4) {\n    try {\n        Module["dynCall_viiii"](index,a1,a2,a3,a4);\n    } catch(e) {\n        if (typeof e !== \'number\' && e !== \'longjmp\') throw e;\n        Module["setThrew"](1, 0);\n    }\n}\n\nModule.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity, "byteLength": byteLength };\n\nModule.asmLibraryArg = { "abort": abort, "assert": assert, "enlargeMemory": enlargeMemory, "getTotalMemory": getTotalMemory, "abortOnCannotGrowMemory": abortOnCannotGrowMemory, "invoke_vi": invoke_vi, "invoke_iiii": invoke_iiii, "invoke_viiiiiiiiii": invoke_viiiiiiiiii, "invoke_viiiii": invoke_viiiii, "invoke_iiiiiii": invoke_iiiiiii, "invoke_vii": invoke_vii, "invoke_iiiiiiiiiii": invoke_iiiiiiiiiii, "invoke_viiiiiiiii": invoke_viiiiiiiii, "invoke_ii": invoke_ii, "invoke_viiiiiii": invoke_viiiiiii, "invoke_viiiiiiii": invoke_viiiiiiii, "invoke_v": invoke_v, "invoke_iiiii": invoke_iiiii, "invoke_viiiiii": invoke_viiiiii, "invoke_iii": invoke_iii, "invoke_viiii": invoke_viiii, "___syscall221": ___syscall221, "_pthread_cond_wait": _pthread_cond_wait, "___lock": ___lock, "_pthread_join": _pthread_join, "___syscall54": ___syscall54, "_abort": _abort, "___gxx_personality_v0": ___gxx_personality_v0, "___cxa_free_exception": ___cxa_free_exception, "_usleep": _usleep, "__ZSt18uncaught_exceptionv": __ZSt18uncaught_exceptionv, "_pthread_cond_init": _pthread_cond_init, "_llvm_cttz_i32": _llvm_cttz_i32, "___setErrNo": ___setErrNo, "___cxa_begin_catch": ___cxa_begin_catch, "_emscripten_memcpy_big": _emscripten_memcpy_big, "___cxa_end_catch": ___cxa_end_catch, "___resumeException": ___resumeException, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "_pthread_getspecific": _pthread_getspecific, "_pthread_mutex_destroy": _pthread_mutex_destroy, "_pthread_once": _pthread_once, "_pthread_mutexattr_settype": _pthread_mutexattr_settype, "_pthread_key_create": _pthread_key_create, "___unlock": ___unlock, "_pthread_create": _pthread_create, "_pthread_mutexattr_init": _pthread_mutexattr_init, "_pthread_setspecific": _pthread_setspecific, "___cxa_rethrow": ___cxa_rethrow, "___syscall6": ___syscall6, "___syscall5": ___syscall5, "_time": _time, "_mktime": _mktime, "_tzset": _tzset, "_localtime": _localtime, "_localtime_r": _localtime_r,  "___cxa_pure_virtual": ___cxa_pure_virtual, "_pthread_cond_destroy": _pthread_cond_destroy, "___syscall140": ___syscall140, "_pthread_mutex_init": _pthread_mutex_init, "___syscall145": ___syscall145, "___syscall146": ___syscall146, "DYNAMICTOP_PTR": DYNAMICTOP_PTR, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "cttz_i8": cttz_i8 };\n// EMSCRIPTEN_START_ASM\n/*var asm =Module["asm"]// EMSCRIPTEN_END_ASM\n(Module.asmGlobalArg, Module.asmLibraryArg, buffer);*/\n\n//Module[\'asm\'] = asm;\n\nvar _QY265GetFramePts = Module["_QY265GetFramePts"] = function() {  return Module["asm"]["_QY265GetFramePts"].apply(null, arguments) };\nvar stackSave = Module["stackSave"] = function() {  return Module["asm"]["stackSave"].apply(null, arguments) };\nvar getTempRet0 = Module["getTempRet0"] = function() {  return Module["asm"]["getTempRet0"].apply(null, arguments) };\nvar ___udivdi3 = Module["___udivdi3"] = function() {  return Module["asm"]["___udivdi3"].apply(null, arguments) };\nvar _QY265DecodeFrameEnSkip = Module["_QY265DecodeFrameEnSkip"] = function() {  return Module["asm"]["_QY265DecodeFrameEnSkip"].apply(null, arguments) };\nvar _QY265DecoderDestroy = Module["_QY265DecoderDestroy"] = function() {  return Module["asm"]["_QY265DecoderDestroy"].apply(null, arguments) };\nvar setThrew = Module["setThrew"] = function() {  return Module["asm"]["setThrew"].apply(null, arguments) };\nvar _bitshift64Lshr = Module["_bitshift64Lshr"] = function() {  return Module["asm"]["_bitshift64Lshr"].apply(null, arguments) };\nvar _QY265DecoderCreate = Module["_QY265DecoderCreate"] = function() {  return Module["asm"]["_QY265DecoderCreate"].apply(null, arguments) };\nvar _QY265DumpVUIParameters = Module["_QY265DumpVUIParameters"] = function() {  return Module["asm"]["_QY265DumpVUIParameters"].apply(null, arguments) };\nvar _bitshift64Shl = Module["_bitshift64Shl"] = function() {  return Module["asm"]["_bitshift64Shl"].apply(null, arguments) };\nvar _QY265DecoderGetDecodedFrameEm = Module["_QY265DecoderGetDecodedFrameEm"] = function() {  return Module["asm"]["_QY265DecoderGetDecodedFrameEm"].apply(null, arguments) };\nvar _QY265GetFrameHeight = Module["_QY265GetFrameHeight"] = function() {  return Module["asm"]["_QY265GetFrameHeight"].apply(null, arguments) };\nvar _memset = Module["_memset"] = function() {  return Module["asm"]["_memset"].apply(null, arguments) };\nvar _QY265DecoderGetDecodedFrame = Module["_QY265DecoderGetDecodedFrame"] = function() {  return Module["asm"]["_QY265DecoderGetDecodedFrame"].apply(null, arguments) };\nvar _sbrk = Module["_sbrk"] = function() {  return Module["asm"]["_sbrk"].apply(null, arguments) };\nvar _memcpy = Module["_memcpy"] = function() {  return Module["asm"]["_memcpy"].apply(null, arguments) };\nvar ___errno_location = Module["___errno_location"] = function() {  return Module["asm"]["___errno_location"].apply(null, arguments) };\nvar ___uremdi3 = Module["___uremdi3"] = function() {  return Module["asm"]["___uremdi3"].apply(null, arguments) };\nvar _QY265DecodeFrame = Module["_QY265DecodeFrame"] = function() {  return Module["asm"]["_QY265DecodeFrame"].apply(null, arguments) };\nvar stackAlloc = Module["stackAlloc"] = function() {  return Module["asm"]["stackAlloc"].apply(null, arguments) };\nvar _QY265GetFrameWidth = Module["_QY265GetFrameWidth"] = function() {  return Module["asm"]["_QY265GetFrameWidth"].apply(null, arguments) };\nvar _i64Subtract = Module["_i64Subtract"] = function() {  return Module["asm"]["_i64Subtract"].apply(null, arguments) };\nvar setTempRet0 = Module["setTempRet0"] = function() {  return Module["asm"]["setTempRet0"].apply(null, arguments) };\nvar _QY265DecodeFlush = Module["_QY265DecodeFlush"] = function() {  return Module["asm"]["_QY265DecodeFlush"].apply(null, arguments) };\nvar _i64Add = Module["_i64Add"] = function() {  return Module["asm"]["_i64Add"].apply(null, arguments) };\nvar _pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = function() {  return Module["asm"]["_pthread_mutex_unlock"].apply(null, arguments) };\nvar __GLOBAL__sub_I_DecParameterSetReader_cpp = Module["__GLOBAL__sub_I_DecParameterSetReader_cpp"] = function() {  return Module["asm"]["__GLOBAL__sub_I_DecParameterSetReader_cpp"].apply(null, arguments) };\nvar _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {  return Module["asm"]["_emscripten_get_global_libc"].apply(null, arguments) };\nvar _pthread_cond_broadcast = Module["_pthread_cond_broadcast"] = function() {  return Module["asm"]["_pthread_cond_broadcast"].apply(null, arguments) };\nvar _llvm_bswap_i32 = Module["_llvm_bswap_i32"] = function() {  return Module["asm"]["_llvm_bswap_i32"].apply(null, arguments) };\nvar runPostSets = Module["runPostSets"] = function() {  return Module["asm"]["runPostSets"].apply(null, arguments) };\nvar ___cxa_can_catch = Module["___cxa_can_catch"] = function() {  return Module["asm"]["___cxa_can_catch"].apply(null, arguments) };\nvar _free = Module["_free"] = function() {  return Module["asm"]["_free"].apply(null, arguments) };\nvar _QY265DecoderSetDecConfig = Module["_QY265DecoderSetDecConfig"] = function() {  return Module["asm"]["_QY265DecoderSetDecConfig"].apply(null, arguments) };\nvar establishStackSpace = Module["establishStackSpace"] = function() {  return Module["asm"]["establishStackSpace"].apply(null, arguments) };\nvar _QY265DecoderReturnDecodedFrame = Module["_QY265DecoderReturnDecodedFrame"] = function() {  return Module["asm"]["_QY265DecoderReturnDecodedFrame"].apply(null, arguments) };\nvar _QY265DecoderGetFrameValid = Module["_QY265DecoderGetFrameValid"] = function() {  return Module["asm"]["_QY265DecoderGetFrameValid"].apply(null, arguments) };\nvar stackRestore = Module["stackRestore"] = function() {  return Module["asm"]["stackRestore"].apply(null, arguments) };\nvar _malloc = Module["_malloc"] = function() {  return Module["asm"]["_malloc"].apply(null, arguments) };\nvar _pthread_mutex_lock = Module["_pthread_mutex_lock"] = function() {  return Module["asm"]["_pthread_mutex_lock"].apply(null, arguments) };\nvar _emscripten_replace_memory = Module["_emscripten_replace_memory"] = function() {  return Module["asm"]["_emscripten_replace_memory"].apply(null, arguments) };\nvar _QY265GetPixelBits = Module["_QY265GetPixelBits"] = function() {  return Module["asm"]["_QY265GetPixelBits"].apply(null, arguments) };\nvar ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {  return Module["asm"]["___cxa_is_pointer_type"].apply(null, arguments) };\nvar _QY265DecoderGetFramePlane = Module["_QY265DecoderGetFramePlane"] = function() {  return Module["asm"]["_QY265DecoderGetFramePlane"].apply(null, arguments) };\nvar dynCall_vi = Module["dynCall_vi"] = function() {  return Module["asm"]["dynCall_vi"].apply(null, arguments) };\nvar dynCall_iiii = Module["dynCall_iiii"] = function() {  return Module["asm"]["dynCall_iiii"].apply(null, arguments) };\nvar dynCall_viiiiiiiiii = Module["dynCall_viiiiiiiiii"] = function() {  return Module["asm"]["dynCall_viiiiiiiiii"].apply(null, arguments) };\nvar dynCall_viiiii = Module["dynCall_viiiii"] = function() {  return Module["asm"]["dynCall_viiiii"].apply(null, arguments) };\nvar dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {  return Module["asm"]["dynCall_iiiiiii"].apply(null, arguments) };\nvar dynCall_vii = Module["dynCall_vii"] = function() {  return Module["asm"]["dynCall_vii"].apply(null, arguments) };\nvar dynCall_iiiiiiiiiii = Module["dynCall_iiiiiiiiiii"] = function() {  return Module["asm"]["dynCall_iiiiiiiiiii"].apply(null, arguments) };\nvar dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {  return Module["asm"]["dynCall_viiiiiiiii"].apply(null, arguments) };\nvar dynCall_ii = Module["dynCall_ii"] = function() {  return Module["asm"]["dynCall_ii"].apply(null, arguments) };\nvar dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {  return Module["asm"]["dynCall_viiiiiii"].apply(null, arguments) };\nvar dynCall_viiiiiiii = Module["dynCall_viiiiiiii"] = function() {  return Module["asm"]["dynCall_viiiiiiii"].apply(null, arguments) };\nvar dynCall_v = Module["dynCall_v"] = function() {  return Module["asm"]["dynCall_v"].apply(null, arguments) };\nvar dynCall_iiiii = Module["dynCall_iiiii"] = function() {  return Module["asm"]["dynCall_iiiii"].apply(null, arguments) };\nvar dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {  return Module["asm"]["dynCall_viiiiii"].apply(null, arguments) };\nvar dynCall_iii = Module["dynCall_iii"] = function() {  return Module["asm"]["dynCall_iii"].apply(null, arguments) };\nvar dynCall_viiii = Module["dynCall_viiii"] = function() {  return Module["asm"]["dynCall_viiii"].apply(null, arguments) };\n;\nvar _mktime = Module["_mktime"] = function() {  return Module["asm"]["_mktime"].apply(null, arguments) };\nvar _time = Module["_time"] = function() {  return Module["asm"]["_time"].apply(null, arguments) };\nvar _localtime = Module["_localtime"] = function() {  return Module["asm"]["_localtime"].apply(null, arguments) };\n;\nRuntime.stackAlloc = Module[\'stackAlloc\'];\nRuntime.stackSave = Module[\'stackSave\'];\nRuntime.stackRestore = Module[\'stackRestore\'];\nRuntime.establishStackSpace = Module[\'establishStackSpace\'];\nRuntime.setTempRet0 = Module[\'setTempRet0\'];\nRuntime.getTempRet0 = Module[\'getTempRet0\'];\n\n\n// === Auto-generated postamble setup entry stuff ===\n\n//Module[\'asm\'] = asm;\n\n\n\nif (memoryInitializer) {\n    if (typeof Module[\'locateFile\'] === \'function\') {\n        memoryInitializer = Module[\'locateFile\'](memoryInitializer);\n    } else if (Module[\'memoryInitializerPrefixURL\']) {\n        memoryInitializer = Module[\'memoryInitializerPrefixURL\'] + memoryInitializer;\n    }\n    if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {\n        var data = Module[\'readBinary\'](memoryInitializer);\n        HEAPU8.set(data, Runtime.GLOBAL_BASE);\n    } else {\n        addRunDependency(\'memory initializer\');\n        var applyMemoryInitializer = function(data) {\n            if (data.byteLength) data = new Uint8Array(data);\n            HEAPU8.set(data, Runtime.GLOBAL_BASE);\n            // Delete the typed array that contains the large blob of the memory initializer request response so that\n            // we won\'t keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g.\n            // its .status field can still be accessed later.\n            if (Module[\'memoryInitializerRequest\']) delete Module[\'memoryInitializerRequest\'].response;\n            removeRunDependency(\'memory initializer\');\n        }\n        function doBrowserLoad() {\n            Module[\'readAsync\'](memoryInitializer, applyMemoryInitializer, function() {\n                throw \'could not load memory initializer \' + memoryInitializer;\n            });\n        }\n        if (Module[\'memoryInitializerRequest\']) {\n            // a network request has already been created, just use that\n            function useRequest() {\n                var request = Module[\'memoryInitializerRequest\'];\n                if (request.status !== 200 && request.status !== 0) {\n                    // If you see this warning, the issue may be that you are using locateFile or memoryInitializerPrefixURL, and defining them in JS. That\n                    // means that the HTML file doesn\'t know about them, and when it tries to create the mem init request early, does it to the wrong place.\n                    // Look in your browser\'s devtools network console to see what\'s going on.\n                    console.warn(\'a problem seems to have happened with Module.memoryInitializerRequest, status: \' + request.status + \', retrying \' + memoryInitializer);\n                    doBrowserLoad();\n                    return;\n                }\n                applyMemoryInitializer(request.response);\n            }\n            if (Module[\'memoryInitializerRequest\'].response) {\n                setTimeout(useRequest, 0); // it\'s already here; but, apply it asynchronously\n            } else {\n                Module[\'memoryInitializerRequest\'].addEventListener(\'load\', useRequest); // wait for it\n            }\n        } else {\n            // fetch it from the network ourselves\n            doBrowserLoad();\n        }\n    }\n}\n\n\n\n/**\n * @constructor\n * @extends {Error}\n */\nfunction ExitStatus(status) {\n    this.name = "ExitStatus";\n    this.message = "Program terminated with exit(" + status + ")";\n    this.status = status;\n};\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\n\nvar initialStackTop;\nvar preloadStartTime = null;\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n    if (!Module[\'calledRun\']) run();\n    if (!Module[\'calledRun\']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n}\n\nModule[\'callMain\'] = Module.callMain = function callMain(args) {\n\n    args = args || [];\n\n    ensureInitRuntime();\n\n    var argc = args.length+1;\n    function pad() {\n        for (var i = 0; i < 4-1; i++) {\n            argv.push(0);\n        }\n    }\n    var argv = [allocate(intArrayFromString(Module[\'thisProgram\']), \'i8\', ALLOC_NORMAL) ];\n    pad();\n    for (var i = 0; i < argc-1; i = i + 1) {\n        argv.push(allocate(intArrayFromString(args[i]), \'i8\', ALLOC_NORMAL));\n        pad();\n    }\n    argv.push(0);\n    argv = allocate(argv, \'i32\', ALLOC_NORMAL);\n\n\n    try {\n\n        var ret = Module[\'_main\'](argc, argv, 0);\n\n\n        // if we\'re not running an evented main loop, it\'s time to exit\n        exit(ret, /* implicit = */ true);\n    }\n    catch(e) {\n        if (e instanceof ExitStatus) {\n            // exit() throws this once it\'s done to make sure execution\n            // has been stopped completely\n            return;\n        } else if (e == \'SimulateInfiniteLoop\') {\n            // running an evented main loop, don\'t immediately exit\n            Module[\'noExitRuntime\'] = true;\n            return;\n        } else {\n            var toLog = e;\n            if (e && typeof e === \'object\' && e.stack) {\n                toLog = [e, e.stack];\n            }\n            Module.printErr(\'exception thrown: \' + toLog);\n            Module[\'quit\'](1, e);\n        }\n    } finally {\n        calledMain = true;\n    }\n}\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n    args = args || Module[\'arguments\'];\n\n    if (preloadStartTime === null) preloadStartTime = Date.now();\n\n    if (runDependencies > 0) {\n        return;\n    }\n\n\n    preRun();\n\n    if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n    if (Module[\'calledRun\']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n    function doRun() {\n        if (Module[\'calledRun\']) return; // run may have just been called while the async setStatus time below was happening\n        Module[\'calledRun\'] = true;\n\n        if (ABORT) return;\n\n        ensureInitRuntime();\n\n        preMain();\n\n\n        if (Module[\'onRuntimeInitialized\']) Module[\'onRuntimeInitialized\']();\n\n        if (Module[\'_main\'] && shouldRunNow) Module[\'callMain\'](args);\n\n        postRun();\n    }\n\n    if (Module[\'setStatus\']) {\n        Module[\'setStatus\'](\'Running...\');\n        setTimeout(function() {\n            setTimeout(function() {\n                Module[\'setStatus\'](\'\');\n            }, 1);\n            doRun();\n        }, 1);\n    } else {\n        doRun();\n    }\n}\nModule[\'run\'] = Module.run = run;\n\nfunction exit(status, implicit) {\n    if (implicit && Module[\'noExitRuntime\']) {\n        return;\n    }\n\n    if (Module[\'noExitRuntime\']) {\n    } else {\n\n        ABORT = true;\n        EXITSTATUS = status;\n        STACKTOP = initialStackTop;\n\n        exitRuntime();\n\n        if (Module[\'onExit\']) Module[\'onExit\'](status);\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n        process[\'exit\'](status);\n    }\n    Module[\'quit\'](status, new ExitStatus(status));\n}\nModule[\'exit\'] = Module.exit = exit;\n\nvar abortDecorators = [];\n\nfunction abort(what) {\n    if (Module[\'onAbort\']) {\n        Module[\'onAbort\'](what);\n    }\n\n    if (what !== undefined) {\n        Module.print(what);\n        Module.printErr(what);\n        what = JSON.stringify(what)\n    } else {\n        what = \'\';\n    }\n\n    ABORT = true;\n    EXITSTATUS = 1;\n\n    var extra = \'\\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.\';\n\n    var output = \'abort(\' + what + \') at \' + stackTrace() + extra;\n    if (abortDecorators) {\n        abortDecorators.forEach(function(decorator) {\n            output = decorator(output, what);\n        });\n    }\n    throw output;\n}\nModule[\'abort\'] = Module.abort = abort;\n\n// {{PRE_RUN_ADDITIONS}}\n\nif (Module[\'preInit\']) {\n    if (typeof Module[\'preInit\'] == \'function\') Module[\'preInit\'] = [Module[\'preInit\']];\n    while (Module[\'preInit\'].length > 0) {\n        Module[\'preInit\'].pop()();\n    }\n}\n\n// shouldRunNow refers to calling main(), not run().\nvar shouldRunNow = false;\nif (Module[\'noInitialRun\']) {\n    shouldRunNow = false;\n}\n\nModule["noExitRuntime"] = true;\n\n//run();\n\n// {{POST_RUN_ADDITIONS}}\n\n// {{MODULE_ADDITIONS}}\n\n// don\'t pollute the global namespace\n//delete this[\'Module\'];\n\nconst qy265decoder = {\n    QY_OK : (0x00000000),          // Success codes\n    QY_FAIL : (0x80000001),        //  Unspecified error\n    QY_OUTOFMEMORY : (0x80000002), //  Ran out of memory\n    QY_POINTER : (0x80000003),     //  Invalid pointer\n    QY_NOTSUPPORTED : (0x80000004),//  NOT support feature encoutnered\n    //QY_REACH_LIMIT : (0x80000005), //  frame cnt Reach limit\n    QY_AUTH_INVALID : (0x80000005), //  authentication invalid\n    QY_SEARCHING_ACCESS_POINT : (0x00000001), // in process of searching first access point\n    QY_REF_PIC_NOT_FOUND : (0x80000007), // encode complete\n    QY_NEED_MORE_DATA : (0x00000008),\n    QY_BITSTREAM_ERROR : (0x00000009),\n\n    QY265DecoderCreate: cwrap(\'QY265DecoderCreate\', \'number\',[\'number\', \'number\']),\n    QY265DecoderDestroy: cwrap(\'QY265DecoderDestroy\', \'number\', [\'number\']),\n    QY265DecoderSetDecConfig: cwrap(\'QY265DecoderSetDecConfig\', \'number\', [\'number\',\'number\',\'number\']),\n    QY265DecodeFrame:cwrap(\'QY265DecodeFrame\', \'number\', [\'number\',\'array\',\'number\',\'number\',\'number\']),\n    QY265DecodeFrameEnSkip:cwrap(\'QY265DecodeFrameEnSkip\', \'number\', [\'number\',\'array\',\'number\',\'number\',\'number\',\'number\']),\n\n    QY265DecodeFlush:cwrap(\'QY265DecodeFlush\', \'number\', [\'number\',\'number\',\'number\']),\n    QY265DecoderGetDecodedFrame:cwrap(\'QY265DecoderGetDecodedFrame\', \'number\', [\'number\',\'number\',\'number\',\'number\']),\n    QY265DecoderGetDecodedFrameEm:cwrap(\'QY265DecoderGetDecodedFrameEm\', \'number\', [\'number\',\'number\',\'number\']),\n    QY265DecoderReturnDecodedFrame:cwrap(\'QY265DecoderReturnDecodedFrame\', \'number\', [\'number\',\'number\']),\n    QY265DecoderGetFramePlane : cwrap(\'QY265DecoderGetFramePlane\', \'number\', [\'number\',\'number\',\'number\']),\n    QY265DecoderGetFrameValid: cwrap(\'QY265DecoderGetFrameValid\',  \'number\', [\'number\']),\n   \n    QY265DumpVUIParameters:cwrap(\'QY265DumpVUIParameters\', \'number\', [\'number\',\'number\',\'number\']),\n    QY265GetFrameWidth:cwrap(\'QY265GetFrameWidth\', \'number\', [\'number\',\'number\']),\n    QY265GetFrameHeight:cwrap(\'QY265GetFrameHeight\', \'number\', [\'number\',\'number\']),\n    QY265GetFramePts:cwrap(\'QY265GetFramePts\', \'number\', [\'number\',\'number\']),\n    QY265GetPixelBits:cwrap(\'QY265GetPixelBits\', \'number\', [\'number\',\'number\']),\n};\n\n\n\n\n\n/**\n * A decoded image\n */\nclass Image {\n    constructor(decoder, img) {\n        this.decoder = decoder;\n        this.img = img; // frame\n        this.width = null;\n        this.height = null;\n        this.pts = null;\n    }\n    free(){\n        this.decoder = null;\n        this.img = null;\n        this.width = null;\n        this.height = null;\n        this.pts = null;\n    }\n    get_width() {\n        if (this.width === null) {\n            this.width = qy265decoder.QY265GetFrameWidth(this.img, 0);\n        }\n        return this.width;\n    }\n    get_height() {\n        if (this.height === null) {\n            this.height = qy265decoder.QY265GetFrameHeight(this.img, 0);\n        }\n        return this.height;\n    }\n    get_pts() {\n        if(this.pts === null) {\n            this.pts = qy265decoder.QY265GetFramePts(this.img, 0);\n        }\n        return this.pts;\n    }\n    transcode(imageData, callback, next) { //get YUV data and convert to RGB data\n        var w = this.get_width();\n        var h = this.get_height();\n        var chroma = 1;\n        var stride = _malloc(2);\n        var y = qy265decoder.QY265DecoderGetFramePlane(this.img, 0, stride);\n        var stridey = getValue(stride, "i16");\n        var bppy = 8;\n        var u = qy265decoder.QY265DecoderGetFramePlane(this.img, 1, stride);\n        var strideu = getValue(stride, "i16");\n        var bppu = 8;\n        var v = qy265decoder.QY265DecoderGetFramePlane(this.img, 2, stride);\n        var stridev = getValue(stride, "i16");\n        var bppv = 8;\n        _free(stride);\n\n        this.decoder.convert_yuv2rgb(chroma, y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, imageData, callback, next);\n    }\n    //\u83B7\u53D6image \u7684YUV420\u6570\u636E\n    getYuvData() {\n        var h = this.get_height();\n        var w = this.get_width();\n        var stride = _malloc(2);\n        var y = qy265decoder.QY265DecoderGetFramePlane(this.img, 0, stride);\n        var stridey = getValue(stride, "i16"); //544\n        var u = qy265decoder.QY265DecoderGetFramePlane(this.img, 1, stride);\n        var strideu = getValue(stride, "i16");\n        var v = qy265decoder.QY265DecoderGetFramePlane(this.img, 2, stride);\n        var stridev = getValue(stride, "i16");\n        \n        var yData = HEAPU8.subarray(y, y+(h*stridey));\n        var uData = HEAPU8.subarray(u, u+(h*strideu));\n        var vData = HEAPU8.subarray(v, v+(h*stridev));\n\n        let yuvData = new Uint8Array(h * w + h / 2 * w / 2 * 2);\n        for(let i = 0; i < h; i++) {\n            yuvData.set(yData.subarray(i*stridey, i*stridey + w), w * i);\n        }\n        for(let i = 0; i < h/2; i++) {\n            let offset = w * h + w/2 * i;\n            yuvData.set(uData.subarray(i* strideu, i* strideu + w/2), offset);\n        }\n        for(let i = 0; i < h/2; i++) {\n            let offset = w * h * 1.25 + w / 2 * i;\n            yuvData.set(vData.subarray(i* stridev, i*stridev+ w/2), offset);\n        }\n        yData = null;\n        uData = null;\n        vData = null;\n    \n        return yuvData;\n    }\n    // \u83B7\u53D6YUV\u6570\u636E\uFF08\u4E0D\u9700\u8981\u6570\u636E\u62FC\u63A5\uFF09\n    getYuvDataNew() {\n        let h = this.get_height();\n        let w = this.get_width();\n        let bufSize = h * w * 1.5;\n\n        let yuvPtr = qy265decoder.QY265DecoderSetYUVPlane(this.img);\n        let yuvData = HEAPU8.subarray(yuvPtr, yuvPtr + bufSize);\n\n        return new Uint8Array(yuvData);\n    \n    }\n}\n\n\nclass LocalConverter{\n    constructor(){}\n    destroy() {}\n    convert(chroma, y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, imageData, callback) {\n        _do_convert_yuv2rgb(chroma,\n            y, u, v,\n            w, h,\n            stridey, strideu, stridev,\n            bppy, bppu, bppv,\n            imageData);\n\n        if(callback) callback(imageData);\n    }\n}\n\nfunction _do_convert_yuv2rgb(chroma, y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, dest) {\n    if (!dest) {\n        dest = new Uint8ClampedArray(w * h * 4);\n    }\n    // NOTE: we can\'t use libde265 constants here as the function can also be\n    // run inside the Worker where "libde265" is not available.\n    switch (chroma) {\n        case 0:  /* libde265.de265_chroma_mono */\n            // TODO(fancycode): implement me\n            console.log("Chroma format not implemented yet", chroma, bppy, bppu, bppv);\n            break;\n        case 1:  /* libde265.de265_chroma_420 */\n            if (bppy !== 8 || bppu !== 8 || bppv !== 8) {\n                // TODO(fancycode): implement me\n                console.log("Chroma format not implemented yet", chroma, bppy, bppu, bppv);\n            } else {\n                _do_convert_yuv420(y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, dest);\n            }\n            break;\n        case 2:  /* libde265.de265_chroma_422 */\n            // TODO(fancycode): implement me\n            console.log("Chroma format not implemented yet", chroma, bppy, bppu, bppv);\n            break;\n        case 3:  /* libde265.de265_chroma_444 */\n            // TODO(fancycode): implement me\n            console.log("Chroma format not implemented yet", chroma, bppy, bppu, bppv);\n            break;\n        default:\n            console.log("Unsupported chroma format", chroma, bppy, bppu, bppv);\n            break;\n    }\n    return dest;\n}\n\nfunction _do_convert_yuv420(y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, dest) {\n    var yval;\n    var uval;\n    var vval;\n    var xpos = 0;\n    var ypos = 0;\n    var w2 = w >> 1;\n    var maxi = w2*h;\n    var yoffset = 0;\n    var uoffset = 0;\n    var voffset = 0;\n    var x2;\n    var i2;\n    for (var i=0; i<maxi; i++) {\n        i2 = i << 1;\n        x2 = (xpos << 1);\n        yval = 1.164 * (y[yoffset + x2] - 16);\n\n        uval = u[uoffset + xpos] - 128;\n        vval = v[voffset + xpos] - 128;\n        dest[(i2<<2)+0] = yval + 1.596 * vval;\n        dest[(i2<<2)+1] = yval - 0.813 * vval - 0.391 * uval;\n        dest[(i2<<2)+2] = yval + 2.018 * uval;\n        dest[(i2<<2)+3] = 0xff;\n\n        yval = 1.164 * (y[yoffset + x2 + 1] - 16);\n        dest[((i2+1)<<2)+0] = yval + 1.596 * vval;\n        dest[((i2+1)<<2)+1] = yval - 0.813 * vval - 0.391 * uval;\n        dest[((i2+1)<<2)+2] = yval + 2.018 * uval;\n        dest[((i2+1)<<2)+3] = 0xff;\n\n        xpos++;\n        if (xpos === w2) {\n            xpos = 0;\n            ypos++;\n            yoffset += stridey;\n            uoffset = ((ypos >> 1) * strideu);\n            voffset = ((ypos >> 1) * stridev);\n        }\n    }\n}\n\n\nclass H265Decoder {\n    constructor(config) {\n        this.TAG = \'H265Decoder\';\n        this.config = config;\n        this.enableRender = config.enableRender;\n        this.image_callback = null;\n\n        this.framecount = 0; // the counter of frames outputed from decoder\n        this.skippedframecount = 0; // the counter of skipped frames\n        this.innalucount = 0;  // the number of NALU sended to decoder (include frames skipped) \n        this.times = 0;        // decode time\n        this.convertimes = 0; // YUV to RGB converting time\n        this.decStat_cre = _malloc(4);\n\n        //this.more = _malloc(2);\n        this.decStat_ret = _malloc(4);\n        this.decStat_get = _malloc(4);\n\n        this.decoder = qy265decoder.QY265DecoderCreate(null, this.decStat_cre); // request to create a h265 decoder \n\n        this.converter = new LocalConverter();\n\n        this.toBeDecodeQueue = []; // store items like {nalu: Uint8Array, pts: number } \n        this._emitter = new EventEmitter();\n        this._started = false;\n        this._isPausing = false;\n        this.start();\n    }\n    free() {\n        if (this.converter) {\n            this.converter.destroy();\n            this.converter = null;\n        }\n        qy265decoder.QY265DecoderDestroy(this.decoder);\n        this.decoder = null;\n        //_free(this.more);\n        //this.more = null;\n        _free(this.decStat_ret);\n        this.decStat_ret = null;\n        _free(this.decStat_get);\n        this.decStat_get = null;\n        this.toBeDecodeQueue = null;\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n        this.framecount = 0;  \n        this.innalucount = 0;  \n    }\n    on(event, listener) {\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n    \n    convert_yuv2rgb(chroma, y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, imageData, callback, next) {\n        var begin = new Date();\n        y = HEAPU8.subarray(y, y+(h*stridey));\n        u = HEAPU8.subarray(u, u+(h*strideu));\n        v = HEAPU8.subarray(v, v+(h*stridev));\n        this.converter.convert(chroma, y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv, imageData, callback, next);\n        var span = new Date() - begin;\n        this.convertimes += span; // yuv->rgb coverting time\n    }\n    start() {\n        this._started = true;\n        this._consumeData();\n    }\n    isStarted() {\n        return this._started;\n    }\n    pause() {\n        this._isPausing = true;\n    }\n    isPaused() {\n        return this._isPausing;\n    }\n    resume() {\n        this._isPausing = false;\n        this._consumeData();\n    }\n    _consumeData() {\n        if(this._started && !this._isPausing) {\n            let nal = this.toBeDecodeQueue.shift();\n            if(nal && nal.nalu && nal.pts) {\n                this._decode(nal);\n            }else {\n                setTimeout(() => {\n                    if(!this._isPausing) {\n                        this.resume();\n                    }\n                }, 0);\n            }\n        }\n    }\n    //send data to decoder when previous round of dicoding finished or need more data \n    _decode(data, callback) {  //data: {nalu: Uint8Array, pts: number}\n        try{\n            let starttime = new Date();\n\n            var err;\n            setValue(this.decStat_ret, 0, "i32"); //set the return code of QY265DecodeFrameEnSkip to 0\n            setValue(this.decStat_get, 0, "i32"); //set the return code of QY265DecoderGetDecodedFrameEm to 0\n       \n            if(this.config.enableSkipFrame) {\n                qy265decoder.QY265DecodeFrameEnSkip(this.decoder, data.nalu, data.nalu.length, this.decStat_ret, data.pts, data.isDroppable ? 1: 0);\n            }else {\n                qy265decoder.QY265DecodeFrameEnSkip(this.decoder, data.nalu, data.nalu.length, this.decStat_ret, data.pts, 0);\n            }\n    \n            this.innalucount++ ; \n    \n            if(this.config.enableSkipFrame && data.isDroppable) {\n                this.skippedframecount++;\n                if(this.skippedframecount % 30 == 0) {\n                    this._emitter.emit(\'skip_frame\', this.skippedframecount);\n                }\n            }\n    \n            var framevalid =  1;\n    \n            var bForcelogo = 0;\n            do{  \n                var frame = qy265decoder.QY265DecoderGetDecodedFrameEm(this.decoder,this.decStat_get, bForcelogo);\n                if(getValue(this.decStat_get, \'i32\') !== qy265decoder.QY_OK) //get result status of decoding\n                    break;\n                framevalid = qy265decoder.QY265DecoderGetFrameValid(frame);\n                if(getValue(this.decStat_get, \'i32\') === qy265decoder.QY_OK && framevalid){\n                    if (this.image_callback) {\n                        if(this.enableRender){\n                            this.framecount++ ; //include skipped frame\n                            this.image_callback(new Image(this, frame));\n                        }else{\n                            this.image_callback(undefined);\n                        }\n                    }\n                    qy265decoder.QY265DecoderReturnDecodedFrame(this.decoder, frame); // tell decoder to release memory of the frame\n                   \n                }\n            }while(getValue(this.decStat_get, \'i32\') === qy265decoder.QY_OK && framevalid);\n    \n    \n            var spantime = new Date() - starttime;\n            this.times += spantime;\n            if(this.framecount % 30 == 0) {\n                let realFps = (this.framecount/(this.times * 0.001)).toFixed(1);\n     \n                //console.log(\'\u5B9E\u9645\u89E3\u51FA\u5E27\u6570: \' + this.framecount + \'\\t \u5355\u7EAF\u89E3\u7801\u5E27\u7387:\' + realFps);\n                if(this.config.enableSkipFrame) {\n                    let fakeFps = ((this.skippedframecount + this.framecount) / this.times *1000).toFixed(1);\n                    //console.log(\'\u8DF3\u5E27\u6570: \' + this.skippedframecount + \'\\t \u8DF3\u5E27\u89E3\u7801\u5E27\u7387:\' + fakeFps);\n                }\n            }\n    \n            if(callback) {\n                callback(getValue(this.decStat_ret, \'i32\'));\n            }\n    \n            this._consumeData();\n\n        }catch(e) {\n            this.toBeDecodeQueue.unshift(data); //\u6570\u636E\u585E\u56DE\u961F\u5217\n            setTimeout(()=> {\n                this.consumeData();\n            }, 0);\n        }\n\n        return;\n    }\n    set_image_callback(callback) {\n        this.image_callback = callback;\n    }\n}\n\nfunction compileWasmInterfaces(wasmFilePath, callback) {\n  integrateWasmJS(Module, wasmFilePath, callback);\n  var asm = Module[\'asm\'](Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n  Module[\'asm\'] = asm;\n}\n\nlet decoder = null;\nlet config = {\n  wasmFilePath: \'https://s.ssl.pdim.gs/static/0012deb34ee6d934.wasm\',\n  enableSkipFrame: true,\n  enableRender:true,\n  maxLength4ToBeDecodeQueue: 30 * 30,\n  maxLength4ToBeRenderQueue: 30\n};\ninitHevcDecoder();\nonmessage = function(e) {\n  hevcDecode(e.data);\n}\n\nfunction initHevcDecoder() {\n  compileWasmInterfaces(config.wasmFilePath, callback);\n  \n  function callback() {\n    decoder = new H265Decoder(config);\n    decoder.set_image_callback((image) => {\n      let w = image.get_width(); \n      let h = image.get_height(); \n      let pts = image.get_pts();\n      let yuvData = image.getYuvData();\n      let imageObject = {\n        width:w,\n        height:h,\n        imagedata:yuvData,\n        pts\n      };\n      postMessage(imageObject);\n    });\n  }\n}\n\nfunction hevcDecode(frame) {\n  if(decoder){\n    decoder.toBeDecodeQueue.push({\n    nalu: new Uint8Array(frame.data),  // naluData \u4E3A ArrayBuffer\u7C7B\u578B\u6570\u636E\n    pts: frame.timestamp + frame.compositionTime,  //\u5C55\u793A\u65F6\u95F4\u6233\n    isDroppable: true });  // \u8868\u793A\u662F\u5426\u53EF\u4EE5\u8DF3\u5E27\n  }\n}';
	            var workerBlob = new Blob([workerText], { type: 'text/javascript' });
	            var workerURL = window.URL.createObjectURL(workerBlob);
	            this.worker = new Worker(workerURL);
	            this.worker.onmessage = messageEvent.bind(this);
	            function messageEvent(e) {
	                this.clearbuffer.call(this);
	                if (this.images && new Date().getTime() - this.ifDecodeTime < 1e3) {
	                    this.images.push(e.data);
	                }
	            }
	        }
	    }, {
	        key: 'clearbuffer',
	        value: function clearbuffer() {
	            if (!this.images || this.images.length < 1) {
	                return;
	            }
	            if (this.images.length > 100) {
	                this.images = this.images.slice(this.images.length - 50);
	            }
	        }
	    }, {
	        key: '_canvasPlay',
	        value: function _canvasPlay() {
	            var got = 0;
	            if (!this.canvas) {
	                this.logger.warn(this.TAG, 'no canvas!');
	                return;
	            }
	            if (this.images && this.images.length > 45) {
	                if (this.needWait && this.mediaElement.paused) {
	                    this.mediaElement.play();
	                    this.needWait = false;
	                }
	                var w = this.images[0].width;
	                var h = this.images[0].height;
	                if (this.canvas.width != w || this.canvas.height != h) {
	                    this.canvas.width = w;
	                    this.canvas.height = h;
	                    this.webGLCanvas = new _yuvrenderMin2.default({
	                        canvas: this.canvas,
	                        width: w,
	                        height: h
	                    });
	                    this.ylen = w * h;
	                    this.uvlen = w / 2 * (h / 2);
	                }
	                for (var i = 0; i < this.images.length - 1; i++) {
	                    var that = this.images[i];
	                    var next = this.images[i + 1];
	                    if (this.mediaElement.currentTime * 1000 >= that.pts - 5 && this.mediaElement.currentTime * 1000 <= next.pts + 5) {
	                        var ylen = this.ylen;
	                        var uvlen = this.uvlen;
	                        this.webGLCanvas.drawNextOutputPicture({
	                            yData: that.imagedata.subarray(0, ylen),
	                            uData: that.imagedata.subarray(ylen, ylen + uvlen),
	                            vData: that.imagedata.subarray(ylen + uvlen, ylen + uvlen * 2)
	                        });
	                        got++;
	                        this.images.shift();
	                        break;
	                    } else if (this.mediaElement.currentTime * 1000 > that.pts + 50 && this.images.length > 1) {
	                        this.images.shift();
	                    }
	                }
	                if (got == 0 && this.images[0].pts / 1000 - this.mediaElement.currentTime > 1.5) {
	                    this.mediaElement.currentTime = this.images[0].pts / 1000;
	                    this.logger.log(this.TAG, '追帧至' + this.images[0].pts);
	                }
	                if (got == 0 && this.mediaElement.currentTime - this.images[0].pts / 1000 > 1.5 && !this.needWait) {
	                    this.needWait = true;
	                    this.mediaElement.pause();
	                    this.logger.log(this.TAG, '停顿等帧');
	                }
	            }
	            this.ifDecodeTime = new Date().getTime();
	            window.requestAnimationFrame(this._canvasPlay.bind(this));
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._dtsBase = 0;
	            this._dtsBaseInited = false;
	            this._audioDtsBase = Infinity;
	            this._videoDtsBase = Infinity;
	            this._audioNextDts = undefined;
	            this._videoNextDts = undefined;
	            this._audioMeta = null;
	            this._videoMeta = null;
	            this.images = null;
	            this.frame = null;
	            this.inits = false;
	            this.ifDecodeTime = null;
	            this.worker = null;
	            this.webGLCanvas = null;
	            this.ylen = null;
	            this.uvlen = null;
	        }
	    }, {
	        key: 'timmerCallback',
	        value: function timmerCallback() {
	            this.mccree.media.tracks.videoTrack && this.mccree.media.tracks.audioTrack && this._generateBoxes();
	        }
	    }, {
	        key: 'remux',
	        value: function remux() {
	            //传入来源MSE.
	            // 监听媒体数据传入.
	            this.observer.on('METADATA_PARSED', this._generateInitailSegment.bind(this));

	            // 监听视频数据传入.
	            this.observer.on('AUDIODATA_PARSED', this._generateBoxes.bind(this));

	            this.observer.on('VIDEO_PARSED', this._generatevideo.bind(this));
	        }
	    }, {
	        key: '_generateInitailSegment',
	        value: function _generateInitailSegment() {
	            _mp4Generator2.default.init();
	            var audioTrack = this.mccree.media.tracks.audioTrack;
	            audioTrack.isAAC = audioTrack.format === 10;
	            this._generateConfig();
	            // 视频处理
	            var amovie = _mp4Generator2.default.initSegment([audioTrack]);
	            this.mccree.initSegment.audio = amovie;
	            this.observer.trigger('INIT_SEGMENT_REMUXED');
	            this._generateBoxes();
	        }
	    }, {
	        key: '_fixRatio',
	        value: function _fixRatio() {
	            // SPS 错误兼容 / SPS宽高信息错误。转成16:9
	            var mediaInfo = this.mccree.media.mediaInfo || {},
	                videoTrack = this.mccree.media.tracks.videoTrack || {},
	                meta = videoTrack.meta || {},
	                height = meta.codecHeight,
	                width = meta.codecWidth;

	            if (mediaInfo.width && mediaInfo.height && mediaInfo.width === meta.codecWidth && mediaInfo.height === meta.codecHeight) {
	                return;
	            }
	            if (meta.codecHeight !== meta.codecWidth * 9 / 16) {
	                width = mediaInfo.width ? mediaInfo.width : parseInt(meta.codecHeight * 16 / 9);
	                height = mediaInfo.height ? mediaInfo.height : parseInt(meta.codecWidth * 9 / 16);
	                meta.codecHeight = height;
	                meta.codecWidth = width;
	                meta.presentHeight = height;
	                meta.presentWidth = width;
	            }
	        }
	    }, {
	        key: '_generateConfig',
	        value: function _generateConfig() {
	            var audioTrack = this.mccree.media.tracks.audioTrack,
	                meta = audioTrack.meta;
	            var config = [],
	                audioObjectType = audioTrack.objectType,
	                samplingIndex = meta.sampleRateIndex,
	                extensionSamplingIndex = void 0,
	                channelConfig = meta.channelCount;
	            var userAgent = navigator.userAgent.toLowerCase();
	            if (userAgent.indexOf('firefox') !== -1) {
	                if (samplingIndex >= 6) {
	                    audioObjectType = 5;
	                    extensionSamplingIndex = samplingIndex - 3;
	                } else {
	                    audioObjectType = 2;
	                    config = new Array(2);
	                    extensionSamplingIndex = samplingIndex;
	                }
	            } else if (userAgent.indexOf('android') !== -1) {
	                audioObjectType = 2;
	                extensionSamplingIndex = samplingIndex;
	            } else {
	                audioObjectType = 5;
	                extensionSamplingIndex = samplingIndex;
	                if (samplingIndex >= 6) {
	                    extensionSamplingIndex = samplingIndex - 3;
	                } else if (channelConfig === 1) {
	                    audioObjectType = 2;
	                    extensionSamplingIndex = samplingIndex;
	                }
	            }
	            config[0] = audioObjectType << 3;
	            config[0] |= (samplingIndex & 0x0F) >>> 1;
	            config[1] = (samplingIndex & 0x0F) << 7;
	            config[1] |= (channelConfig & 0x0F) << 3;
	            if (audioObjectType === 5) {
	                config[1] |= (samplingIndex & 0x0F) >>> 1;
	                config[2] = (samplingIndex & 0x01) << 7;
	                config[2] |= 2 << 2;
	                config[3] = 0;
	            }
	            meta.config = config;
	            meta.codec = 'mp4a.40.' + audioObjectType;
	        }
	    }, {
	        key: '_generateBoxes',
	        value: function _generateBoxes() {
	            var audioTrack = this.mccree.media.tracks.audioTrack,
	                nextIframe = 15;

	            if (audioTrack.samples.length < 16) {
	                return;
	            }

	            this._remuxAudio(audioTrack.samples[0].timestamp, audioTrack.samples[nextIframe].timestamp);
	        }
	    }, {
	        key: '_remuxAudio',
	        value: function _remuxAudio(baseDts, nextDts) {
	            var base = baseDts,
	                next = baseDts;
	            var videoTrack = this.mccree.media.tracks.videoTrack;
	            var audioTrack = this.mccree.media.tracks.audioTrack,
	                sampleDuration = audioTrack.meta.refSampleDuration,
	                audioSamples = audioTrack.samples;
	            var sampleSize = 0;
	            var mp4data = [],
	                mp4Samples = [];
	            // 如果音视频总时长差出一个音频片段长度，则该音频片段废弃。
	            while (audioSamples[0] && audioSamples[0].timestamp + sampleDuration < baseDts) {
	                this.logger.warn(this.TAG, 'Audio chase frame to ' + audioSamples[0].timestamp);
	                audioSamples.shift();
	            }

	            baseDts = audioSamples[0].timestamp;
	            var audioSample = audioSamples[0];
	            var tep = audioSamples[0].timestamp;
	            while (audioSamples.length > 0 && audioSamples[0].timestamp <= nextDts // 音频片段起始时间小于下一个gop的时间
	            ) {

	                audioSample = audioSamples.shift();

	                if (audioSamples[0]) {
	                    base = audioSample.timestamp;
	                    next = audioSamples[0].timestamp;
	                } else {
	                    base = audioSample.timestamp;
	                    next = audioSample.timestamp + sampleDuration;
	                }

	                audioSample.sampleDuration = next - base;

	                this.mccree.media.audioDuration += audioSample.sampleDuration;
	                var mp4Sample = {
	                    dts: audioSample.timestamp - this._dtsBase,
	                    pts: audioSample.timestamp - this._dtsBase,
	                    cts: 0,
	                    size: audioSample.data.length,
	                    duration: audioSample.sampleDuration,
	                    originalDts: base,
	                    flags: {
	                        isLeading: 0,
	                        dependsOn: 1,
	                        isDependedOn: 0,
	                        hasRedundancy: 0
	                    }
	                };
	                mp4Samples.push(mp4Sample);
	                sampleSize += audioSample.data.length;
	                mp4data.push(audioSample.data);
	                this.mccree.remuxBuffer.lastDts = mp4Sample.dts;
	            }

	            var bytes = sampleSize + 8;
	            var offset = 8;
	            var mdatbox = new Uint8Array(bytes);
	            mdatbox[0] = bytes >>> 24 & 0xFF;
	            mdatbox[1] = bytes >>> 16 & 0xFF;
	            mdatbox[2] = bytes >>> 8 & 0xFF;
	            mdatbox[3] = bytes & 0xFF;
	            mdatbox.set(_mp4Generator2.default.types.mdat, 4);
	            for (var i = 0; i < mp4data.length; i++) {
	                mdatbox.set(mp4data[i], offset);
	                offset += mp4data[i].length;
	            }
	            var track = {
	                id: audioTrack.id,
	                samples: mp4Samples
	            };

	            audioTrack.sequenceNumber++;
	            var moofbox = _mp4Generator2.default.moof(audioTrack.sequenceNumber, baseDts - this._dtsBase, track);
	            this.mccree.remuxBuffer.audio.push({
	                type: 'audio',
	                data: this._mergeBoxes(moofbox, mdatbox)
	            });
	            this.observer.trigger('MEDIA_SEGMENT_REMUXED', 15);
	        }
	    }, {
	        key: '_calculateDtsBase',
	        value: function _calculateDtsBase(audioTrack, videoTrack) {
	            if (this._dtsBaseInited) {
	                return;
	            }

	            if (audioTrack.samples && audioTrack.samples.length) {
	                this._audioDtsBase = audioTrack.samples[0].timestamp;
	            }
	            if (videoTrack.samples && videoTrack.samples.length) {
	                this._videoDtsBase = videoTrack.samples[0].timestamp;
	            }

	            this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);
	            this._dtsBaseInited = true;
	        }
	    }, {
	        key: '_mergeBoxes',
	        value: function _mergeBoxes(moof, mdat) {
	            var result = new Uint8Array(moof.byteLength + mdat.byteLength);
	            result.set(moof, 0);
	            result.set(mdat, moof.byteLength);
	            return result;
	        }
	    }, {
	        key: '_generatevideo',
	        value: function _generatevideo() {
	            this.frame = this.mccree.media.tracks.videoTrack.samples.shift();
	            if (new Date().getTime() - this.ifDecodeTime < 1e3) {
	                this.worker.postMessage(this.frame);
	            } else {
	                this.images = [];
	            }

	            if (!this.inits) {
	                this.mediaElement = this.mccree.getMediaElement();
	                if (this.mediaElement) {
	                    window.requestAnimationFrame(this._canvasPlay.bind(this));
	                } else {
	                    this.logger.warn(this.TAG, 'no mediaElement!');
	                }
	                this.inits = true;
	            }
	        }
	    }]);

	    return HevcDecoder;
	}();

	exports.default = HevcDecoder;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Generate MP4 Box
	*/

	//import Hex from '../utils/hex';

	var UINT32_MAX = Math.pow(2, 32) - 1;

	var MP4 = function () {
	  function MP4() {
	    _classCallCheck(this, MP4);
	  }

	  _createClass(MP4, null, [{
	    key: 'init',
	    value: function init() {
	      MP4.types = {
	        avc1: [], // codingname
	        avcC: [],
	        btrt: [],
	        dinf: [],
	        dref: [],
	        esds: [],
	        ftyp: [],
	        hdlr: [],
	        mdat: [],
	        mdhd: [],
	        mdia: [],
	        mfhd: [],
	        minf: [],
	        moof: [],
	        moov: [],
	        mp4a: [],
	        mvex: [],
	        mvhd: [],
	        pasp: [],
	        sdtp: [],
	        stbl: [],
	        stco: [],
	        stsc: [],
	        stsd: [],
	        stsz: [],
	        stts: [],
	        tfdt: [],
	        tfhd: [],
	        traf: [],
	        trak: [],
	        trun: [],
	        trex: [],
	        tkhd: [],
	        vmhd: [],
	        smhd: [],
	        hvcc: [],
	        '.mp3': []
	      };

	      var i = void 0;
	      for (i in MP4.types) {
	        if (MP4.types.hasOwnProperty(i)) {
	          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
	        }
	      }

	      var videoHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
	      ]);

	      var audioHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
	      ]);

	      MP4.HDLR_TYPES = {
	        'video': videoHdlr,
	        'audio': audioHdlr
	      };

	      var dref = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01, // entry_count
	      0x00, 0x00, 0x00, 0x0c, // entry_size
	      0x75, 0x72, 0x6c, 0x20, // 'url' type
	      0x00, // version 0
	      0x00, 0x00, 0x01 // entry_flags
	      ]);

	      var stco = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00 // entry_count
	      ]);

	      MP4.STTS = MP4.STSC = MP4.STCO = stco;

	      MP4.STSZ = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // sample_size
	      0x00, 0x00, 0x00, 0x00]);
	      MP4.VMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x01, // flags
	      0x00, 0x00, // graphicsmode
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
	      ]);
	      MP4.SMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, // balance
	      0x00, 0x00 // reserved
	      ]);

	      MP4.STSD = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01]); // entry_count

	      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
	      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
	      var minorVersion = new Uint8Array([0, 0, 0, 1]);

	      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
	      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
	    }

	    // TODO: support large length & uuid

	  }, {
	    key: 'box',
	    value: function box(type) {
	      var payload = Array.prototype.slice.call(arguments, 1),
	          size = 8,
	          i = payload.length,
	          len = i,
	          result = void 0;
	      // calculate the total size we need to allocate
	      while (i--) {
	        size += payload[i].byteLength;
	      }
	      result = new Uint8Array(size);
	      result[0] = size >> 24 & 0xff;
	      result[1] = size >> 16 & 0xff;
	      result[2] = size >> 8 & 0xff;
	      result[3] = size & 0xff;
	      result.set(type, 4);
	      // copy the payload into the result
	      for (i = 0, size = 8; i < len; i++) {
	        // copy payload[i] array @ offset size
	        result.set(payload[i], size);
	        size += payload[i].byteLength;
	      }
	      return result;
	    }
	  }, {
	    key: 'hdlr',
	    value: function hdlr(type) {
	      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
	    }
	  }, {
	    key: 'mdat',
	    value: function mdat(data) {
	      return MP4.box(MP4.types.mdat, data);
	    }
	  }, {
	    key: 'mdhd',
	    value: function mdhd(timescale, duration) {
	      duration *= timescale;
	      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
	      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'mdia',
	    value: function mdia(meta) {
	      return MP4.box(MP4.types.mdia, MP4.mdhd(meta.timescale, meta.duration), MP4.hdlr(meta.type), MP4.minf(meta));
	    }
	  }, {
	    key: 'mfhd',
	    value: function mfhd(sequenceNumber) {
	      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
	      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]) // sequence_number
	      );
	    }
	  }, {
	    key: 'minf',
	    value: function minf(meta) {
	      if (meta.type === 'audio') {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(meta));
	      } else {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(meta));
	      }
	    }
	  }, {
	    key: 'moof',
	    value: function moof(sn, baseMediaDecodeTime, track) {
	      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
	    }
	    /**
	     * @param tracks... (optional) {array} the tracks associated with this movie
	     */

	  }, {
	    key: 'moov',
	    value: function moov(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trak(tracks[i].meta);
	      }

	      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].meta.timescale, tracks[0].meta.duration)].concat(boxes).concat(MP4.mvex(tracks)));
	    }
	  }, {
	    key: 'mvex',
	    value: function mvex(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trex(tracks[i]);
	      }
	      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
	    }
	  }, {
	    key: 'mvhd',
	    value: function mvhd(timescale, duration) {
	      duration *= timescale;
	      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
	      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      var bytes = new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
	      0x01, 0x00, // 1.0 volume
	      0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
	      0xff, 0xff, 0xff, 0xff // next_track_ID
	      ]);
	      return MP4.box(MP4.types.mvhd, bytes);
	    }
	  }, {
	    key: 'sdtp',
	    value: function sdtp(track) {
	      var samples = track.samples || [],
	          bytes = new Uint8Array(4 + samples.length),
	          flags = track.flags,
	          i;
	      // leave the full box header (4 bytes) all zero
	      // write the sample table
	      for (i = 0; i < samples.length; i++) {
	        flags = samples[i].flags;
	        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
	      }

	      return MP4.box(MP4.types.sdtp, bytes);
	    }
	  }, {
	    key: 'stbl',
	    value: function stbl(meta) {
	      return MP4.box(MP4.types.stbl, MP4.stsd(meta), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
	    }
	  }, {
	    key: 'avc1',
	    value: function avc1(meta) {
	      var avcc = meta.avcc;
	      var width = meta.codecWidth,
	          height = meta.codecHeight;

	      var data = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, width >>> 8 & 0xFF, // width: 2 bytes
	      width & 0xFF, height >>> 8 & 0xFF, height & 0xFF, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0A, 0x78, 0x71, 0x71, 0x2F, 0x66, 0x6C, 0x76, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xFF, 0xFF]);
	      return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));
	    }
	  }, {
	    key: 'esds',
	    value: function esds(track) {
	      var configlen = track.config.length;
	      return new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags

	      0x03, // descriptor_type
	      0x17 + configlen, // length
	      0x00, 0x01, //es_id
	      0x00, // stream_priority

	      0x04, // descriptor_type
	      0x0f + configlen, // length
	      0x40, //codec : mpeg4_audio
	      0x15, // stream_type
	      0x00, 0x00, 0x00, // buffer_size
	      0x00, 0x00, 0x00, 0x00, // maxBitrate
	      0x00, 0x00, 0x00, 0x00, // avgBitrate

	      0x05 // descriptor_type
	      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
	    }
	  }, {
	    key: 'mp4a',
	    value: function mp4a(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
	    }
	  }, {
	    key: 'mp3',
	    value: function mp3(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'stsd',
	    value: function stsd(meta) {
	      if (meta.type === 'audio') {
	        if (!meta.isAAC && meta.codec === 'mp3') {
	          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(meta));
	        }
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(meta));
	      } else {
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(meta));
	      }
	    }
	  }, {
	    key: 'tkhd',
	    value: function tkhd(meta) {
	      var id = meta.id,
	          duration = meta.duration * meta.timescale,
	          width = meta.presentWidth,
	          height = meta.presentHeight,
	          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
	          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x07, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x00, // reserved
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, // layer
	      0x00, 0x00, // alternate_group
	      0x00, 0x00, // non-audio track volume
	      0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
	      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
	      ]));
	    }
	  }, {
	    key: 'traf',
	    value: function traf(track, baseMediaDecodeTime) {
	      var sampleDependencyTable = MP4.sdtp(track),
	          id = track.id,
	          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
	          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
	      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
	      20 + // tfdt
	      8 + // traf header
	      16 + // mfhd
	      8 + // moof header
	      8), // mdat header
	      sampleDependencyTable);
	    }

	    /**
	     * Generate a track box.
	     * @param track {object} a track definition
	     * @return {Uint8Array} the track box
	     */

	  }, {
	    key: 'trak',
	    value: function trak(meta) {
	      meta.duration = meta.duration || 0xffffffff;
	      return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));
	    }
	  }, {
	    key: 'trex',
	    value: function trex(track) {
	      var id = track.id;
	      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
	      0x00, 0x00, 0x00, 0x00, // default_sample_duration
	      0x00, 0x00, 0x00, 0x00, // default_sample_size
	      0x00, 0x01, 0x00, 0x01 // default_sample_flags
	      ]));
	    }
	  }, {
	    key: 'trun',
	    value: function trun(track, offset) {
	      var samples = track.samples || [],
	          len = samples.length,
	          arraylen = 12 + 16 * len,
	          array = new Uint8Array(arraylen),
	          i,
	          sample,
	          duration,
	          size,
	          flags,
	          cts;
	      offset += 8 + arraylen;
	      array.set([0x00, // version 0
	      0x00, 0x0f, 0x01, // flags
	      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
	      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
	      ], 0);
	      for (i = 0; i < len; i++) {
	        sample = samples[i];
	        duration = sample.duration;
	        size = sample.size;
	        flags = sample.flags;
	        cts = sample.cts;
	        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
	        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
	        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
	        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
	        ], 12 + 16 * i);
	      }
	      return MP4.box(MP4.types.trun, array);
	    }
	  }, {
	    key: 'initSegment',
	    value: function initSegment(tracks) {
	      if (!MP4.types) {
	        MP4.init();
	      }
	      var movie = MP4.moov(tracks),
	          result;
	      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
	      result.set(MP4.FTYP);
	      result.set(movie, MP4.FTYP.byteLength);
	      return result;
	    }
	  }]);

	  return MP4;
	}();

	exports.default = MP4;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	!function (e, t) {
	  "object" == ( false ? "undefined" : _typeof(exports)) && "object" == ( false ? "undefined" : _typeof(module)) ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.yuvrender = t() : e.yuvrender = t();
	}(window, function () {
	  return function (e) {
	    var t = {};function r(i) {
	      if (t[i]) return t[i].exports;var o = t[i] = { i: i, l: !1, exports: {} };return e[i].call(o.exports, o, o.exports, r), o.l = !0, o.exports;
	    }return r.m = e, r.c = t, r.d = function (e, t, i) {
	      r.o(e, t) || Object.defineProperty(e, t, { configurable: !1, enumerable: !0, get: i });
	    }, r.r = function (e) {
	      Object.defineProperty(e, "__esModule", { value: !0 });
	    }, r.n = function (e) {
	      var t = e && e.__esModule ? function () {
	        return e.default;
	      } : function () {
	        return e;
	      };return r.d(t, "a", t), t;
	    }, r.o = function (e, t) {
	      return Object.prototype.hasOwnProperty.call(e, t);
	    }, r.p = "", r(r.s = 0);
	  }([function (e, t, r) {
	    "use strict";
	    Object.defineProperty(t, "__esModule", { value: !0 });var i = function () {
	      function e(e, t) {
	        for (var r = 0; r < t.length; r++) {
	          var i = t[r];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
	        }
	      }return function (t, r, i) {
	        return r && e(t.prototype, r), i && e(t, i), t;
	      };
	    }();var o = function () {
	      function e(t) {
	        !function (e, t) {
	          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	        }(this, e), t = t || {}, this.canvasElement = t.canvas || document.createElement("canvas"), this.contextOptions = t.contextOptions, this.type = t.type || "yuv420", this.customYUV444 = t.customYUV444, this.conversionType = t.conversionType || "rec601", this.width = t.width || 640, this.height = t.height || 320, this.animationTime = t.animationTime || 0, this._scaleRate = this.canvasElement.width / this.width, this.canvasElement.height = this.canvasElement.width / (this.width / this.height), this.initContextGL(), this.contextGL && (this.initProgram(), this.initBuffers(), this.initTextures()), "yuv420" === this.type ? this.drawNextOuptutPictureGL = function (e) {
	          var t = this.contextGL,
	              r = this.texturePosBuffer,
	              i = this.uTexturePosBuffer,
	              o = this.vTexturePosBuffer,
	              a = this.yTextureRef,
	              n = this.uTextureRef,
	              u = this.vTextureRef,
	              s = e.yData,
	              f = e.uData,
	              h = e.vData,
	              x = this.width,
	              c = this.height,
	              v = e.yDataPerRow || x,
	              l = e.yRowCnt || c,
	              T = e.uDataPerRow || x / 2,
	              R = e.uRowCnt || c / 2,
	              A = e.vDataPerRow || T,
	              d = e.vRowCnt || R;t.viewport(0, 0, this.canvasElement.width, this.canvasElement.height);var m = c / l,
	              E = x / v,
	              g = new Float32Array([E, 0, 0, 0, E, m, 0, m]);t.bindBuffer(t.ARRAY_BUFFER, r), t.bufferData(t.ARRAY_BUFFER, g, t.DYNAMIC_DRAW), this.customYUV444 ? (m = c / R, E = x / T) : (m = c / 2 / R, E = x / 2 / T);var p = new Float32Array([E, 0, 0, 0, E, m, 0, m]);t.bindBuffer(t.ARRAY_BUFFER, i), t.bufferData(t.ARRAY_BUFFER, p, t.DYNAMIC_DRAW), this.customYUV444 ? (m = c / d, E = x / A) : (m = c / 2 / d, E = x / 2 / A);var y = new Float32Array([E, 0, 0, 0, E, m, 0, m]);t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, y, t.DYNAMIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a), t.texImage2D(t.TEXTURE_2D, 0, t.LUMINANCE, v, l, 0, t.LUMINANCE, t.UNSIGNED_BYTE, s), t.activeTexture(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.LUMINANCE, T, R, 0, t.LUMINANCE, t.UNSIGNED_BYTE, f), t.activeTexture(t.TEXTURE2), t.bindTexture(t.TEXTURE_2D, u), t.texImage2D(t.TEXTURE_2D, 0, t.LUMINANCE, A, d, 0, t.LUMINANCE, t.UNSIGNED_BYTE, h), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
	        } : "yuv422" === this.type && (this.drawNextOuptutPictureGL = function (e) {
	          var t = this.contextGL,
	              r = this.texturePosBuffer,
	              i = this.textureRef,
	              o = e.data,
	              a = this.width,
	              n = this.height,
	              u = e.dataPerRow || 2 * a,
	              s = e.rowCnt || n;t.viewport(0, 0, a, n);var f = n / s,
	              h = a / (u / 2),
	              x = new Float32Array([h, 0, 0, 0, h, f, 0, f]);t.bindBuffer(t.ARRAY_BUFFER, r), t.bufferData(t.ARRAY_BUFFER, x, t.DYNAMIC_DRAW), t.uniform2f(t.getUniformLocation(this.shaderProgram, "resolution"), u, n), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, t.LUMINANCE, u, s, 0, t.LUMINANCE, t.UNSIGNED_BYTE, o), t.drawArrays(t.TRIANGLE_STRIP, 0, 4);
	        });
	      }return i(e, [{ key: "isWebGL", value: function value() {
	          return this.contextGL;
	        } }, { key: "initContextGL", value: function value() {
	          for (var e = this.canvasElement, t = null, r = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], i = 0; !t && i < r.length;) {
	            var o = r[i];try {
	              t = this.contextOptions ? e.getContext(o, this.contextOptions) : e.getContext(o);
	            } catch (e) {
	              t = null;
	            }t && "function" == typeof t.getParameter || (t = null), ++i;
	          }this.contextGL = t;
	        } }, { key: "initProgram", value: function value() {
	          var e = this.contextGL,
	              t = void 0,
	              r = void 0;"yuv420" === this.type ? (t = ["attribute vec4 vertexPos;", "attribute vec4 texturePos;", "attribute vec4 uTexturePos;", "attribute vec4 vTexturePos;", "varying vec2 textureCoord;", "varying vec2 uTextureCoord;", "varying vec2 vTextureCoord;", "uniform mat4 u_scaleMatrix;", "void main()", "{", "  gl_Position = vertexPos;", "  textureCoord = texturePos.xy;", "  uTextureCoord = uTexturePos.xy;", "  vTextureCoord = vTexturePos.xy;", "}"].join("\n"), r = ["precision highp float;", "varying highp vec2 textureCoord;", "varying highp vec2 uTextureCoord;", "varying highp vec2 vTextureCoord;", "uniform sampler2D ySampler;", "uniform sampler2D uSampler;", "uniform sampler2D vSampler;", "uniform mat4 YUV2RGB;", "void main(void) {", "  highp float y = texture2D(ySampler,  textureCoord).r;", "  highp float u = texture2D(uSampler,  uTextureCoord).r;", "  highp float v = texture2D(vSampler,  vTextureCoord).r;", "  gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;", "}"].join("\n")) : "yuv422" === this.type && (t = ["attribute vec4 vertexPos;", "attribute vec4 texturePos;", "varying vec2 textureCoord;", "void main()", "{", "  gl_Position = vertexPos;", "  textureCoord = texturePos.xy;", "}"].join("\n"), r = ["precision highp float;", "varying highp vec2 textureCoord;", "uniform sampler2D sampler;", "uniform highp vec2 resolution;", "uniform mat4 YUV2RGB;", "void main(void) {", "  highp float texPixX = 1.0 / resolution.x;", "  highp float logPixX = 2.0 / resolution.x;", "  highp float logHalfPixX = 4.0 / resolution.x;", "  highp float steps = floor(textureCoord.x / logPixX);", "  highp float uvSteps = floor(textureCoord.x / logHalfPixX);", "  highp float y = texture2D(sampler, vec2((logPixX * steps) + texPixX, textureCoord.y)).r;", "  highp float u = texture2D(sampler, vec2((logHalfPixX * uvSteps), textureCoord.y)).r;", "  highp float v = texture2D(sampler, vec2((logHalfPixX * uvSteps) + texPixX + texPixX, textureCoord.y)).r;", "  gl_FragColor = vec4(y, u, v, 1.0) * YUV2RGB;", "}"].join("\n"));var i = [];i = "rec709" == this.conversionType ? [1.16438, 0, 1.79274, -.97295, 1.16438, -.21325, -.53291, .30148, 1.16438, 2.1124, 0, -1.1334, 0, 0, 0, 1] : [1.16438, 0, 1.59603, -.87079, 1.16438, -.39176, -.81297, .52959, 1.16438, 2.01723, 0, -1.08139, 0, 0, 0, 1];var o = e.createShader(e.VERTEX_SHADER);e.shaderSource(o, t), e.compileShader(o), e.getShaderParameter(o, e.COMPILE_STATUS) || console.log("Vertex shader failed to compile: " + e.getShaderInfoLog(o));var a = e.createShader(e.FRAGMENT_SHADER);e.shaderSource(a, r), e.compileShader(a), e.getShaderParameter(a, e.COMPILE_STATUS) || console.log("Fragment shader failed to compile: " + e.getShaderInfoLog(a));var n = e.createProgram();e.attachShader(n, o), e.attachShader(n, a), e.linkProgram(n), e.getProgramParameter(n, e.LINK_STATUS) || console.log("Program failed to compile: " + e.getProgramInfoLog(n)), e.useProgram(n);var u = e.getUniformLocation(n, "YUV2RGB");e.uniformMatrix4fv(u, !1, i), this.shaderProgram = n;
	        } }, { key: "initBuffers", value: function value() {
	          var e = this.contextGL,
	              t = this.shaderProgram,
	              r = e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER, r), e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);var i = e.getAttribLocation(t, "vertexPos");if (e.enableVertexAttribArray(i), e.vertexAttribPointer(i, 2, e.FLOAT, !1, 0, 0), this.animationTime) {
	            var o = this.animationTime,
	                a = 0;!function r() {
	              var i = 1 * (a += 15) / o;a >= o ? i = 1 : setTimeout(r, 15);var n = -1 * i,
	                  u = 1 * i,
	                  s = e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array([u, u, n, u, u, n, n, n]), e.STATIC_DRAW);var f = e.getAttribLocation(t, "vertexPos");e.enableVertexAttribArray(f), e.vertexAttribPointer(f, 2, e.FLOAT, !1, 0, 0);try {
	                e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
	              } catch (e) {
	                console.log(e);
	              }
	            }();
	          }var n = e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER, n), e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), e.STATIC_DRAW);var u = e.getAttribLocation(t, "texturePos");if (e.enableVertexAttribArray(u), e.vertexAttribPointer(u, 2, e.FLOAT, !1, 0, 0), this.texturePosBuffer = n, "yuv420" === this.type) {
	            var s = e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), e.STATIC_DRAW);var f = e.getAttribLocation(t, "uTexturePos");e.enableVertexAttribArray(f), e.vertexAttribPointer(f, 2, e.FLOAT, !1, 0, 0), this.uTexturePosBuffer = s;var h = e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER, h), e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), e.STATIC_DRAW);var x = e.getAttribLocation(t, "vTexturePos");e.enableVertexAttribArray(x), e.vertexAttribPointer(x, 2, e.FLOAT, !1, 0, 0), this.vTexturePosBuffer = h;
	          }
	        } }, { key: "initTextures", value: function value() {
	          var e = this.contextGL,
	              t = this.shaderProgram;if ("yuv420" === this.type) {
	            var r = this.initTexture(),
	                i = e.getUniformLocation(t, "ySampler");e.uniform1i(i, 0), this.yTextureRef = r;var o = this.initTexture(),
	                a = e.getUniformLocation(t, "uSampler");e.uniform1i(a, 1), this.uTextureRef = o;var n = this.initTexture(),
	                u = e.getUniformLocation(t, "vSampler");e.uniform1i(u, 2), this.vTextureRef = n;
	          } else if ("yuv422" === this.type) {
	            var s = this.initTexture(),
	                f = e.getUniformLocation(t, "sampler");e.uniform1i(f, 0), this.textureRef = s;
	          }
	        } }, { key: "initTexture", value: function value() {
	          var e = this.contextGL,
	              t = e.createTexture();return e.bindTexture(e.TEXTURE_2D, t), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.bindTexture(e.TEXTURE_2D, null), t;
	        } }, { key: "drawNextOutputPicture", value: function value(e, t, r, i) {
	          this.contextGL ? this.drawNextOuptutPictureGL(e, t, r, i) : this.drawNextOutputPictureRGBA(e, t, r, i);
	        } }, { key: "drawNextOutputPictureRGBA", value: function value(e, t, r, i) {
	          var o = i,
	              a = this.canvasElement.getContext("2d"),
	              n = a.getImageData(0, 0, e, t);n.data.set(o), null === r ? a.putImageData(n, 0, 0) : a.putImageData(n, -r.left, -r.top, 0, 0, r.width, r.height);
	        } }]), e;
	    }();t.default = o;
	  }]);
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mp4Generator = __webpack_require__(25);

	var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

	var _mccreeHelperBrowser = __webpack_require__(12);

	var _mccreeHelperBrowser2 = _interopRequireDefault(_mccreeHelperBrowser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Fragmented mp4 remuxer
	var MP4Remuxer = function () {
	  function MP4Remuxer(config) {
	    _classCallCheck(this, MP4Remuxer);

	    this.TAG = 'Mccree-remuxer-mp4live:index';

	    this.type = 'remuxer';

	    this._config = config || {};
	    this._isLive = this._config.isLive;

	    this._dtsBase = 0;
	    this._dtsBaseInited = false;
	    this._audioDtsBase = Infinity;
	    this._videoDtsBase = Infinity;
	    this._audioNextDts = undefined;
	    this._videoNextDts = undefined;

	    this._audioMeta = null;
	    this._videoMeta = null;
	    this._browser = _mccreeHelperBrowser2.default.uaMatch();
	  }

	  _createClass(MP4Remuxer, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events;
	      this.onMediaSegment = mccree.onMediaSegment;
	      this.mccree.initSegment = {};
	      this.mccree.remuxBuffer = {
	        audio: [],
	        video: []
	      };
	      this.observer.on('METADATA_PARSED', this._generateInitailSegment.bind(this));
	      this.observer.on('VIDEODATA_PARSED', this.timmerCallback.bind(this));
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._dtsBase = 0;
	      this._dtsBaseInited = false;
	      this._audioDtsBase = Infinity;
	      this._videoDtsBase = Infinity;
	      this._audioNextDts = undefined;
	      this._videoNextDts = undefined;

	      this._audioMeta = null;
	      this._videoMeta = null;
	    }
	  }, {
	    key: 'timmerCallback',
	    value: function timmerCallback() {
	      this.mccree.media.tracks.videoTrack && this.mccree.media.tracks.audioTrack && this._generateBoxes();
	    }
	  }, {
	    key: '_generateInitailSegment',
	    value: function _generateInitailSegment() {
	      _mp4Generator2.default.init();
	      this._fixRatio();
	      var audioTrack = this.mccree.media.tracks.audioTrack,
	          videoTrack = this.mccree.media.tracks.videoTrack;
	      audioTrack.isAAC = audioTrack.format === 10;
	      this._generateConfig();
	      // 视频处理
	      if (videoTrack.meta) {
	        var vmovie = _mp4Generator2.default.initSegment([videoTrack]);
	        this.mccree.initSegment.video = vmovie;
	        var amovie = _mp4Generator2.default.initSegment([audioTrack]);
	        this.mccree.initSegment.audio = amovie;
	        this.observer.trigger('INIT_SEGMENT_REMUXED');
	        this._generateBoxes();
	      }
	    }
	  }, {
	    key: '_fixRatio',
	    value: function _fixRatio() {
	      // SPS 错误兼容 / SPS宽高信息错误。转成16:9
	      var mediaInfo = this.mccree.media.mediaInfo || {},
	          videoTrack = this.mccree.media.tracks.videoTrack || {},
	          meta = videoTrack.meta || {},
	          height = meta.codecHeight,
	          width = meta.codecWidth;

	      if (mediaInfo.width === meta.codecWidth && mediaInfo.height === meta.codecHeight) {
	        return;
	      }
	      if (meta.height !== meta.width * 9 / 16) {
	        width = mediaInfo.width ? mediaInfo.width : parseInt(meta.height * 16 / 9);
	        height = mediaInfo.height ? mediaInfo.height : parseInt(meta.width * 9 / 16);
	        meta.codecHeight = height;
	        meta.codecWidth = width;
	        meta.presentHeight = height;
	        meta.presentWidth = width;
	      }
	    }
	  }, {
	    key: '_generateConfig',
	    value: function _generateConfig() {
	      var audioTrack = this.mccree.media.tracks.audioTrack,
	          meta = audioTrack.meta;
	      var config = [],
	          audioObjectType = audioTrack.objectType,
	          samplingIndex = meta.sampleRateIndex,
	          extensionSamplingIndex = void 0,
	          channelConfig = meta.channelCount;
	      var userAgent = navigator.userAgent.toLowerCase();
	      if (userAgent.indexOf('firefox') !== -1) {
	        if (samplingIndex >= 6) {
	          audioObjectType = 5;
	          extensionSamplingIndex = samplingIndex - 3;
	        } else {
	          audioObjectType = 2;
	          config = new Array(2);
	          extensionSamplingIndex = samplingIndex;
	        }
	      } else if (userAgent.indexOf('android') !== -1) {
	        audioObjectType = 2;
	        extensionSamplingIndex = samplingIndex;
	      } else {
	        audioObjectType = 5;
	        extensionSamplingIndex = samplingIndex;
	        if (samplingIndex >= 6) {
	          extensionSamplingIndex = samplingIndex - 3;
	        } else if (channelConfig === 1) {
	          audioObjectType = 2;
	          extensionSamplingIndex = samplingIndex;
	        }
	      }
	      config[0] = audioObjectType << 3;
	      config[0] |= (samplingIndex & 0x0F) >>> 1;
	      config[1] = (samplingIndex & 0x0F) << 7;
	      config[1] |= (channelConfig & 0x0F) << 3;
	      if (audioObjectType === 5) {
	        config[1] |= (samplingIndex & 0x0F) >>> 1;
	        config[2] = (samplingIndex & 0x01) << 7;
	        config[2] |= 2 << 2;
	        config[3] = 0;
	      }
	      meta.config = config;
	      meta.codec = 'mp4a.40.' + audioObjectType;
	    }
	  }, {
	    key: '_generateBoxes',
	    value: function _generateBoxes() {
	      var videoTrack = this.mccree.media.tracks.videoTrack,
	          audioTrack = this.mccree.media.tracks.audioTrack,
	          nextIframe = -1,
	          gop = null,
	          nextDts = -1;

	      var i = 0;

	      if (!this._dtsBaseInited && videoTrack.samples.length > 1 && audioTrack.samples.length > 1) {
	        this._calculateDtsBase(audioTrack, videoTrack);
	      }

	      if (!videoTrack.meta || !audioTrack.meta) {
	        return;
	      }

	      if (videoTrack.samples.length < 15) {
	        return;
	      }

	      var lastPts = videoTrack.samples[0].timestamp + videoTrack.samples[0].compositionTime;
	      var index = 0;
	      nextIframe = 10;

	      if (nextIframe < 1) {
	        return;
	      }

	      if (videoTrack.samples.length <= nextIframe + 1) {
	        return;
	      }

	      var audioLengthLimit = Math.ceil((nextIframe + 1) * videoTrack.meta.refSampleDuration / audioTrack.meta.refSampleDuration) + 1;

	      if (audioTrack.samples.length <= audioLengthLimit || audioTrack.samples.length < nextIframe) {
	        return;
	      }

	      if (videoTrack.samples.length > nextIframe) {
	        nextDts = videoTrack.samples[nextIframe].timestamp;
	        gop = videoTrack.samples.splice(0, nextIframe);
	      }

	      if (gop) {
	        if (this._browser.chrome && this._browser.versionNumber <= 50 || this._browser.mozilla) {
	          gop[0].frameType = 1;
	        }
	        this._generateGop(gop, gop[0].timestamp, nextDts);
	        this._generateBoxes();
	      }
	    }
	  }, {
	    key: '_generateGop',
	    value: function _generateGop(gop, baseDts, nextDts) {
	      var base = baseDts,
	          next = baseDts;
	      var videoTrack = this.mccree.media.tracks.videoTrack,
	          sampleDuration = videoTrack.meta.refSampleDuration;
	      var sampleSize = 0;
	      var mp4Samples = [];
	      // 数据处理
	      for (var i = 0; i < gop.length; i++) {
	        sampleSize += gop[i].data.length;
	      }
	      var bytes = 8 + sampleSize;
	      var mdatbox = new Uint8Array(bytes);
	      mdatbox[0] = bytes >>> 24 & 0xFF;
	      mdatbox[1] = bytes >>> 16 & 0xFF;
	      mdatbox[2] = bytes >>> 8 & 0xFF;
	      mdatbox[3] = bytes & 0xFF;
	      mdatbox.set(_mp4Generator2.default.types.mdat, 4);
	      var offset = 8;
	      // metadata处理
	      for (var _i = 0; _i < gop.length; _i++) {
	        var frame = gop[_i];
	        if (gop[_i + 1]) {
	          next = gop[_i + 1].timestamp;
	          sampleDuration = next - base;
	          base = next;
	        } else {
	          next = nextDts;
	          sampleDuration = next - base;
	          base = next;
	        }

	        // 掉帧检测 音频抽帧
	        if (sampleDuration > videoTrack.meta.refSampleDuration + 1) {
	          this.observer.trigger('FRAME_DROPPED', Math.floor(sampleDuration / videoTrack.meta.refSampleDuration));
	          this.logger.warn(this.TAG, this.type, 'Video jump frame to ' + base);
	        }

	        this.mccree.media.videoDuration += sampleDuration;
	        var mp4Sample = {
	          dts: frame.timestamp - this._dtsBase,
	          pts: frame.compositionTime + frame.timestamp - this._dtsBase,
	          cts: frame.compositionTime,
	          size: frame.data.length,
	          isKeyframe: frame.frameType === 1,
	          duration: sampleDuration + 1,
	          originalDts: base,
	          flags: {
	            isLeading: 0,
	            dependsOn: frame.frameType === 1 ? 2 : 1,
	            isDependedOn: frame.frameType === 1 ? 1 : 0,
	            hasRedundancy: 0,
	            isNonSync: frame.frameType === 1 ? 0 : 1
	          }
	        };
	        mdatbox.set(frame.data, offset);
	        offset += frame.data.length;
	        mp4Samples.push(mp4Sample);
	        this.mccree.remuxBuffer.lastDts = mp4Sample.dts;
	      }
	      var track = {
	        id: videoTrack.id,
	        samples: mp4Samples
	      };
	      videoTrack.sequenceNumber++;
	      var moofbox = _mp4Generator2.default.moof(videoTrack.sequenceNumber, baseDts - this._dtsBase, track);
	      this.mccree.remuxBuffer.video.push({
	        type: 'video',
	        seekable: mp4Samples[0].isKeyframe,
	        timestamp: mp4Samples[0].dts,
	        data: this._mergeBoxes(moofbox, mdatbox)
	      });
	      this.observer.trigger('MEDIA_SEGMENT_REMUXED', gop.length);
	      this._remuxAudio(baseDts, nextDts);
	    }
	  }, {
	    key: '_remuxAudio',
	    value: function _remuxAudio(baseDts, nextDts) {
	      var base = baseDts,
	          next = baseDts;
	      var videoTrack = this.mccree.media.tracks.videoTrack;
	      var audioTrack = this.mccree.media.tracks.audioTrack,
	          sampleDuration = audioTrack.meta.refSampleDuration,
	          audioSamples = audioTrack.samples;
	      var sampleSize = 0;
	      var mp4data = [],
	          mp4Samples = [];
	      // 如果音视频总时长差出一个音频片段长度，则该音频片段废弃。
	      while (audioSamples[0] && audioSamples[0].timestamp + sampleDuration < baseDts) {
	        this.logger.warn(this.TAG, 'Audio chase frame to ' + audioSamples[0].timestamp);
	        audioSamples.shift();
	      }

	      baseDts = audioSamples[0].timestamp;
	      var audioSample = audioSamples[0];
	      var tep = audioSamples[0].timestamp;
	      while (audioSamples.length > 0 && audioSamples[0].timestamp <= nextDts // 音频片段起始时间小于下一个gop的时间
	      ) {

	        audioSample = audioSamples.shift();

	        if (audioSamples[0]) {
	          base = audioSample.timestamp;
	          next = audioSamples[0].timestamp;
	        } else {
	          base = audioSample.timestamp;
	          next = audioSample.timestamp + sampleDuration;
	        }

	        audioSample.sampleDuration = next - base;

	        this.mccree.media.audioDuration += audioSample.sampleDuration;
	        var mp4Sample = {
	          dts: audioSample.timestamp - this._dtsBase,
	          pts: audioSample.timestamp - this._dtsBase,
	          cts: 0,
	          size: audioSample.data.length,
	          duration: audioSample.sampleDuration,
	          originalDts: base - this._dtsBase,
	          flags: {
	            isLeading: 0,
	            dependsOn: 1,
	            isDependedOn: 0,
	            hasRedundancy: 0
	          }
	        };
	        mp4Samples.push(mp4Sample);
	        sampleSize += audioSample.data.length;
	        mp4data.push(audioSample.data);
	      }

	      while (this.mccree.media.videoDuration - this.mccree.media.audioDuration > audioTrack.meta.refSampleDuration + 1) {
	        this.logger.debug(this.TAG, 'Audio fill the frame of ' + base + ' 补偿时间点：' + next);
	        base = next;
	        next = base + audioSample.sampleDuration;
	        var _mp4Sample = {
	          dts: base - this._dtsBase,
	          pts: base - this._dtsBase,
	          cts: 0,
	          size: audioSample.data.length,
	          duration: audioSample.sampleDuration,
	          originalDts: base - this._dtsBase,
	          flags: {
	            isLeading: 0,
	            dependsOn: 1,
	            isDependedOn: 0,
	            hasRedundancy: 0
	          }
	        };
	        this.mccree.media.audioDuration += audioSample.sampleDuration;
	        mp4Samples.push(_mp4Sample);
	        sampleSize += audioSample.data.length;
	        mp4data.push(audioSample.data);
	      }

	      var bytes = sampleSize + 8;
	      var offset = 8;
	      var mdatbox = new Uint8Array(bytes);
	      mdatbox[0] = bytes >>> 24 & 0xFF;
	      mdatbox[1] = bytes >>> 16 & 0xFF;
	      mdatbox[2] = bytes >>> 8 & 0xFF;
	      mdatbox[3] = bytes & 0xFF;
	      mdatbox.set(_mp4Generator2.default.types.mdat, 4);
	      for (var i = 0; i < mp4data.length; i++) {
	        mdatbox.set(mp4data[i], offset);
	        offset += mp4data[i].length;
	      }
	      var track = {
	        id: audioTrack.id,
	        samples: mp4Samples
	      };

	      audioTrack.sequenceNumber++;
	      var moofbox = _mp4Generator2.default.moof(audioTrack.sequenceNumber, baseDts - this._dtsBase, track);
	      this.mccree.remuxBuffer.audio.push({
	        type: 'audio',
	        data: this._mergeBoxes(moofbox, mdatbox)
	      });
	    }
	  }, {
	    key: '_calculateDtsBase',
	    value: function _calculateDtsBase(audioTrack, videoTrack) {
	      if (this._dtsBaseInited) {
	        return;
	      }

	      if (audioTrack.samples && audioTrack.samples.length) {
	        this._audioDtsBase = audioTrack.samples[0].timestamp;
	      }
	      if (videoTrack.samples && videoTrack.samples.length) {
	        this._videoDtsBase = videoTrack.samples[0].timestamp;
	      }

	      this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);
	      this._dtsBaseInited = true;
	    }
	  }, {
	    key: '_mergeBoxes',
	    value: function _mergeBoxes(moof, mdat) {
	      var result = new Uint8Array(moof.byteLength + mdat.byteLength);
	      result.set(moof, 0);
	      result.set(mdat, moof.byteLength);
	      return result;
	    }
	  }]);

	  return MP4Remuxer;
	}();

	exports.default = MP4Remuxer;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Generate MP4 Box
	*/

	//import Hex from '../utils/hex';

	var UINT32_MAX = Math.pow(2, 32) - 1;

	var MP4 = function () {
	  function MP4() {
	    _classCallCheck(this, MP4);
	  }

	  _createClass(MP4, null, [{
	    key: 'init',
	    value: function init() {
	      MP4.types = {
	        avc1: [], // codingname
	        avcC: [],
	        btrt: [],
	        dinf: [],
	        dref: [],
	        esds: [],
	        ftyp: [],
	        hdlr: [],
	        mdat: [],
	        mdhd: [],
	        mdia: [],
	        mfhd: [],
	        minf: [],
	        moof: [],
	        moov: [],
	        mp4a: [],
	        mvex: [],
	        mvhd: [],
	        pasp: [],
	        sdtp: [],
	        stbl: [],
	        stco: [],
	        stsc: [],
	        stsd: [],
	        stsz: [],
	        stts: [],
	        tfdt: [],
	        tfhd: [],
	        traf: [],
	        trak: [],
	        trun: [],
	        trex: [],
	        tkhd: [],
	        vmhd: [],
	        smhd: [],
	        hvcc: [],
	        '.mp3': []
	      };

	      var i = void 0;
	      for (i in MP4.types) {
	        if (MP4.types.hasOwnProperty(i)) {
	          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
	        }
	      }

	      var videoHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
	      ]);

	      var audioHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
	      ]);

	      MP4.HDLR_TYPES = {
	        'video': videoHdlr,
	        'audio': audioHdlr
	      };

	      var dref = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01, // entry_count
	      0x00, 0x00, 0x00, 0x0c, // entry_size
	      0x75, 0x72, 0x6c, 0x20, // 'url' type
	      0x00, // version 0
	      0x00, 0x00, 0x01 // entry_flags
	      ]);

	      var stco = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00 // entry_count
	      ]);

	      MP4.STTS = MP4.STSC = MP4.STCO = stco;

	      MP4.STSZ = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // sample_size
	      0x00, 0x00, 0x00, 0x00]);
	      MP4.VMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x01, // flags
	      0x00, 0x00, // graphicsmode
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
	      ]);
	      MP4.SMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, // balance
	      0x00, 0x00 // reserved
	      ]);

	      MP4.STSD = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01]); // entry_count

	      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
	      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
	      var minorVersion = new Uint8Array([0, 0, 0, 1]);

	      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
	      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
	    }

	    // TODO: support large length & uuid

	  }, {
	    key: 'box',
	    value: function box(type) {
	      var payload = Array.prototype.slice.call(arguments, 1),
	          size = 8,
	          i = payload.length,
	          len = i,
	          result = void 0;
	      // calculate the total size we need to allocate
	      while (i--) {
	        size += payload[i].byteLength;
	      }
	      result = new Uint8Array(size);
	      result[0] = size >> 24 & 0xff;
	      result[1] = size >> 16 & 0xff;
	      result[2] = size >> 8 & 0xff;
	      result[3] = size & 0xff;
	      result.set(type, 4);
	      // copy the payload into the result
	      for (i = 0, size = 8; i < len; i++) {
	        // copy payload[i] array @ offset size
	        result.set(payload[i], size);
	        size += payload[i].byteLength;
	      }
	      return result;
	    }
	  }, {
	    key: 'hdlr',
	    value: function hdlr(type) {
	      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
	    }
	  }, {
	    key: 'mdat',
	    value: function mdat(data) {
	      return MP4.box(MP4.types.mdat, data);
	    }
	  }, {
	    key: 'mdhd',
	    value: function mdhd(timescale, duration) {
	      duration *= timescale;
	      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
	      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'mdia',
	    value: function mdia(meta) {
	      return MP4.box(MP4.types.mdia, MP4.mdhd(meta.timescale, meta.duration), MP4.hdlr(meta.type), MP4.minf(meta));
	    }
	  }, {
	    key: 'mfhd',
	    value: function mfhd(sequenceNumber) {
	      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
	      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]) // sequence_number
	      );
	    }
	  }, {
	    key: 'minf',
	    value: function minf(meta) {
	      if (meta.type === 'audio') {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(meta));
	      } else {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(meta));
	      }
	    }
	  }, {
	    key: 'moof',
	    value: function moof(sn, baseMediaDecodeTime, track) {
	      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
	    }
	    /**
	     * @param tracks... (optional) {array} the tracks associated with this movie
	     */

	  }, {
	    key: 'moov',
	    value: function moov(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trak(tracks[i].meta);
	      }

	      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].meta.timescale, tracks[0].meta.duration)].concat(boxes).concat(MP4.mvex(tracks)));
	    }
	  }, {
	    key: 'mvex',
	    value: function mvex(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trex(tracks[i]);
	      }
	      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
	    }
	  }, {
	    key: 'mvhd',
	    value: function mvhd(timescale, duration) {
	      duration *= timescale;
	      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
	      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      var bytes = new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
	      0x01, 0x00, // 1.0 volume
	      0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
	      0xff, 0xff, 0xff, 0xff // next_track_ID
	      ]);
	      return MP4.box(MP4.types.mvhd, bytes);
	    }
	  }, {
	    key: 'sdtp',
	    value: function sdtp(track) {
	      var samples = track.samples || [],
	          bytes = new Uint8Array(4 + samples.length),
	          flags = track.flags,
	          i;
	      // leave the full box header (4 bytes) all zero
	      // write the sample table
	      for (i = 0; i < samples.length; i++) {
	        flags = samples[i].flags;
	        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
	      }

	      return MP4.box(MP4.types.sdtp, bytes);
	    }
	  }, {
	    key: 'stbl',
	    value: function stbl(meta) {
	      return MP4.box(MP4.types.stbl, MP4.stsd(meta), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
	    }
	  }, {
	    key: 'avc1',
	    value: function avc1(meta) {
	      var avcc = meta.avcc;
	      var width = meta.codecWidth,
	          height = meta.codecHeight;

	      var data = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, width >>> 8 & 0xFF, // width: 2 bytes
	      width & 0xFF, height >>> 8 & 0xFF, height & 0xFF, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0A, 0x78, 0x71, 0x71, 0x2F, 0x66, 0x6C, 0x76, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xFF, 0xFF]);
	      return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));
	    }
	  }, {
	    key: 'esds',
	    value: function esds(track) {
	      var configlen = track.config.length;
	      return new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags

	      0x03, // descriptor_type
	      0x17 + configlen, // length
	      0x00, 0x01, //es_id
	      0x00, // stream_priority

	      0x04, // descriptor_type
	      0x0f + configlen, // length
	      0x40, //codec : mpeg4_audio
	      0x15, // stream_type
	      0x00, 0x00, 0x00, // buffer_size
	      0x00, 0x00, 0x00, 0x00, // maxBitrate
	      0x00, 0x00, 0x00, 0x00, // avgBitrate

	      0x05 // descriptor_type
	      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
	    }
	  }, {
	    key: 'mp4a',
	    value: function mp4a(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
	    }
	  }, {
	    key: 'mp3',
	    value: function mp3(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'stsd',
	    value: function stsd(meta) {
	      if (meta.type === 'audio') {
	        if (!meta.isAAC && meta.codec === 'mp3') {
	          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(meta));
	        }
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(meta));
	      } else {
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(meta));
	      }
	    }
	  }, {
	    key: 'tkhd',
	    value: function tkhd(meta) {
	      var id = meta.id,
	          duration = meta.duration * meta.timescale,
	          width = meta.presentWidth,
	          height = meta.presentHeight,
	          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
	          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x07, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x00, // reserved
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, // layer
	      0x00, 0x00, // alternate_group
	      0x00, 0x00, // non-audio track volume
	      0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
	      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
	      ]));
	    }
	  }, {
	    key: 'traf',
	    value: function traf(track, baseMediaDecodeTime) {
	      var sampleDependencyTable = MP4.sdtp(track),
	          id = track.id,
	          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
	          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
	      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
	      20 + // tfdt
	      8 + // traf header
	      16 + // mfhd
	      8 + // moof header
	      8), // mdat header
	      sampleDependencyTable);
	    }

	    /**
	     * Generate a track box.
	     * @param track {object} a track definition
	     * @return {Uint8Array} the track box
	     */

	  }, {
	    key: 'trak',
	    value: function trak(meta) {
	      meta.duration = meta.duration || 0xffffffff;
	      return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));
	    }
	  }, {
	    key: 'trex',
	    value: function trex(track) {
	      var id = track.id;
	      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
	      0x00, 0x00, 0x00, 0x00, // default_sample_duration
	      0x00, 0x00, 0x00, 0x00, // default_sample_size
	      0x00, 0x01, 0x00, 0x01 // default_sample_flags
	      ]));
	    }
	  }, {
	    key: 'trun',
	    value: function trun(track, offset) {
	      var samples = track.samples || [],
	          len = samples.length,
	          arraylen = 12 + 16 * len,
	          array = new Uint8Array(arraylen),
	          i,
	          sample,
	          duration,
	          size,
	          flags,
	          cts;
	      offset += 8 + arraylen;
	      array.set([0x00, // version 0
	      0x00, 0x0f, 0x01, // flags
	      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
	      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
	      ], 0);
	      for (i = 0; i < len; i++) {
	        sample = samples[i];
	        duration = sample.duration;
	        size = sample.size;
	        flags = sample.flags;
	        cts = sample.cts;
	        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
	        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
	        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
	        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
	        ], 12 + 16 * i);
	      }
	      return MP4.box(MP4.types.trun, array);
	    }
	  }, {
	    key: 'initSegment',
	    value: function initSegment(tracks) {
	      if (!MP4.types) {
	        MP4.init();
	      }
	      var movie = MP4.moov(tracks),
	          result;
	      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
	      result.set(MP4.FTYP);
	      result.set(movie, MP4.FTYP.byteLength);
	      return result;
	    }
	  }]);

	  return MP4;
	}();

	exports.default = MP4;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MSEController = function () {
	  function MSEController() {
	    _classCallCheck(this, MSEController);

	    this.TAG = 'Mccree-plugin-mse';
	    this.type = 'plugin';
	    this.mediaSource = new window.MediaSource();
	    this._lastappand = 'audio';
	    this.mediaElement = null;
	    this.seekables = [];
	    this.mccree = null;
	    this.observer = null;
	    this.config = null;
	    this._initAppanded = false;
	    this._lastappand = 'audio';
	    this.mediaElement = null;
	    this.lastSeek = -1;
	    this.startTime = undefined;
	    this._lastClearTime = 0;
	  }

	  _createClass(MSEController, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.observer = mccree.observer;
	      this.config = mccree.config;
	      this.logger = mccree.logger;
	      this.observer.on('MEDIA_SEGMENT_REMUXED', this._onMediaSegment.bind(this));
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      this.mediaElement.play();
	    }
	  }, {
	    key: 'checkState',
	    value: function checkState() {
	      if (this.config.autoReload > 15e3 && this.mediaElement && this.mediaElement.readyState < 3 && new Date().getTime() - this.startTime - this.mediaElement.currentTime * 1e3 > this.config.autoReload) {
	        var that = this;
	        this.mccree.reload().then(function () {
	          that.startTime = undefined;
	        });
	      }
	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.mediaElement.readyState === 2 && this.seekables.length > 1) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	      }

	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.mediaElement.readyState === 1 && this.mediaElement.currentTime > 0 && this.seekables.length > 1) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	      }

	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.seekables.length > 1 && this.mediaElement.readyState < 3 && this.mediaElement.currentTime < this.seekables[this.seekables.length - 1] / 1e3 - 10) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	        this.logger.debug(this.TAG, 'Chase frame to ' + this.seekables[this.seekables.length - 1] / 1e3);
	      }

	      this._onMediaSegment();
	    }
	  }, {
	    key: 'clearBuffer',
	    value: function clearBuffer() {
	      if (!this.mediaElement) {
	        return;
	      }
	      if ((new Date().getTime() - this.startTime - this._lastClearTime) / 1000 < 30) {
	        return;
	      }

	      // 降低消耗，一分钟取一次差不多了。
	      var playTime = this.mediaElement.currentTime;

	      // 降低消耗，一分钟清一次差不多了。
	      if (playTime - this._lastClearTime < 30) {
	        return;
	      }

	      if (this.asourceBuffer && this.vsourceBuffer && !this.vsourceBuffer.updating && !this.asourceBuffer.updating) {
	        this.vsourceBuffer.remove(this._lastClearTime, playTime - 10);
	        this.asourceBuffer.remove(this._lastClearTime, playTime - 10);
	        this._lastClearTime = playTime - 10;
	        this.logger.debug(this.TAG, 'Cache clear');
	        while (this.seekables && this.seekables.length > 0 && this.seekables[0] / 1e3 < playTime - 10) {
	          this.seekables.shift();
	        }
	      }
	    }
	  }, {
	    key: 'attachMediaElement',
	    value: function attachMediaElement(mediaElement) {
	      this.mediaElement = mediaElement;
	      this.mediaElement.loop = true;
	      this.mediaSourceObjectURL = window.URL.createObjectURL(this.mediaSource);
	      this.mediaElement.src = this.mediaSourceObjectURL;
	      this.mediaElement.onerror = this.onError.bind(this);
	      this.mediaElement.oncanplay = this.recordStartTime.bind(this);
	      this.mediaElement.onstalled = this.checkState.bind(this);
	    }
	  }, {
	    key: 'detachMediaElement',
	    value: function detachMediaElement() {
	      if (this.mediaElement) {
	        this.mediaElement.onerror = null;
	        this.mediaElement.oncanplay = null;
	        this.mediaElement.onstalled = null;
	      }
	    }
	  }, {
	    key: '_onMediaSegment',
	    value: function _onMediaSegment() {
	      // currently the player will play when 500ms data is ready in the buffer.
	      if (!this._initAppanded && this.mccree.remuxBuffer.lastDts > 500) {
	        this._onInitSegment.call(this);
	      }

	      this.clearBuffer.call(this);

	      if (this.mccree.remuxBuffer.video.length < 1 || this.mccree.remuxBuffer.audio.length < 1) {
	        return;
	      }

	      if (this.asourceBuffer && this.vsourceBuffer && !this.vsourceBuffer.updating && !this.asourceBuffer.updating) {
	        try {
	          if (!this.mediaElement.error && this.mccree.remuxBuffer.lastDts > 500) {
	            var vdata = this.mccree.remuxBuffer.video.shift();
	            var adata = this.mccree.remuxBuffer.audio.shift();
	            this.vsourceBuffer.appendBuffer(vdata.data);
	            this.asourceBuffer.appendBuffer(adata.data);
	            if (!this.seekables) {
	              this.seekables = [];
	            }
	            if (vdata.seekable && vdata.timestamp > 0) {
	              this.seekables.push(vdata.timestamp);
	            }
	            this.checkState.bind(this);
	          } else if (this.mediaElement.error) {
	            this.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	              code: 11
	            });
	          }
	        } catch (e) {
	          if (e.code) {
	            this.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	              code: 11
	            });
	          }
	          this.logger.error(this.TAG, 'Cache error of ' + e.code);
	        }
	      }
	    }
	  }, {
	    key: '_onInitSegment',
	    value: function _onInitSegment() {
	      this.seekables = [];
	      if (this.mediaSource.readyState !== 'open') {
	        this.mediaSource.addEventListener('sourceopen', this._appendInitSegment.bind(this));
	      } else {
	        this._appendInitSegment();
	      }
	    }
	  }, {
	    key: '_appendInitSegment',
	    value: function _appendInitSegment() {
	      var data = this.mccree.initSegment;
	      if (this._initAppanded || !data) {
	        return;
	      }
	      this._initAppanded = true;
	      this.asourceBuffer = this.mediaSource.addSourceBuffer('audio/mp4;codecs=' + this.mccree.media.tracks.audioTrack.meta.codec);
	      this.asourceBuffer.appendBuffer(data.audio);
	      this.vsourceBuffer = this.mediaSource.addSourceBuffer('video/mp4;codecs=' + this.mccree.media.tracks.videoTrack.meta.codec);
	      this.vsourceBuffer.appendBuffer(data.video);

	      var that = this;
	      that._onMediaSegment();
	      this.asourceBuffer.addEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer.addEventListener('error', this.onError.bind(this));
	      this.mediaSource.addEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer.addEventListener('updateend', this.checkState.bind(this));
	      try {
	        if (this.media && this.media.mediaInfo && this.media.mediaInfo.cdn_ip) {
	          this.mccree.cdnip = this.media.mediaInfo.cdn_ip;
	        } else if (!this.url) {
	          this.mccree.cdnip = '0.0.0.0';
	        } else {
	          var cdnip = this.url.match(/(\d+)\.(\d+)\.(\d+)\.(\d+)/);
	          this.mccree.cdnip = cdnip && cdnip[0];
	        }

	        var audiocodec = '';
	        var videocodec = '';
	        if (!this.mccree.media) {
	          audiocodec = 'Mccree uninitailized';
	        } else if (!this.mccree.media.tracks.audioTrack) {
	          audiocodec = 'ATNF';
	        } else if (!this.mccree.media.tracks.audioTrack.meta) {
	          audiocodec = 'AMNF';
	        } else {
	          audiocodec = this.mccree.media.tracks.audioTrack.meta.codec;
	        }

	        if (!this.mccree.media) {
	          videocodec = '';
	        } else if (!this.mccree.media.tracks.videoTrack) {
	          videocodec = 'VTNF';
	        } else if (!this.mccree.media.tracks.videoTrack.meta) {
	          videocodec = 'VMNF';
	        } else {
	          videocodec = this.mccree.media.tracks.videoTrack.meta.codec;
	        }

	        var info = {
	          mimeType: 'flv;codecs="' + audiocodec + ',' + videocodec + '"',
	          metadata: {
	            encoder: this.mccree.media ? this.mccree.media.mediaInfo.encoder : 'UNKNOWN'
	          },
	          audioChannelCount: this.mccree.media ? this.mccree.media.mediaInfo.audiochannels : 0,
	          audioDataRate: this.mccree.media ? this.mccree.media.mediaInfo.audiodatarate : 0,
	          audioSampleRate: this.mccree.media ? this.mccree.media.mediaInfo.audiosamplerate : 0,
	          fps: this.mccree.media ? this.mccree.media.tracks.videoTrack.meta.frameRate.fps : 0,
	          videoDataRate: this.mccree.media ? this.mccree.media.mediaInfo.videodatarate : 0,
	          height: this.mccree.media ? this.mccree.media.mediaInfo.height : 0,
	          width: this.mccree.media ? this.mccree.media.mediaInfo.width : 0,
	          cdnip: this.mccree.media ? this.mccree.media.mediaInfo.cdn_ip : this.mccree.cdnip
	        };
	        this.observer.trigger('media_info', info);
	      } catch (e) {}
	    }
	  }, {
	    key: 'pause',
	    value: function pause() {
	      this.mediaElement.pause();
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (!this.mediaSource || !this.asourceBuffer || !this.vsourceBuffer) {
	        return;
	      }
	      this.removeSourceBuffer();
	      this.detachMediaElement();
	      this.asourceBuffer = null;
	      this.vsourceBuffer = null;
	      this.mediaSource = null;
	      this._lastClearTime = 0;
	      this.seekables = [];
	    }
	  }, {
	    key: 'removeSourceBuffer',
	    value: function removeSourceBuffer() {
	      this._initAppanded = false;
	      this.mediaElement.pause();
	      URL.revokeObjectURL(this.mediaElement.src);
	      this.asourceBuffer && this.asourceBuffer.removeEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer && this.vsourceBuffer.removeEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer && this.vsourceBuffer.removeEventListener('updateend', this.checkState.bind(this));
	      if (this.mediaSource && this.mediaSource.sourceBuffers.length > 1) {
	        this.mediaSource.removeSourceBuffer(this.asourceBuffer);
	        this.mediaSource.removeSourceBuffer(this.vsourceBuffer);
	      }
	    }
	  }, {
	    key: 'onError',
	    value: function onError(error) {
	      // mediaError一般会一直报。此时肯能已经销毁准备换Flash。不一定还有mediaElment
	      if (this.mediaElement && this.mediaElement.error && !this.reloading) {
	        this.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	          code: 11
	        });
	      } else {
	        this.observer.trigger('error', this.events.errorTypes.OtherError, this.events.errorDetails.UNKNOWN);
	      }
	    }
	  }, {
	    key: 'recordStartTime',
	    value: function recordStartTime() {
	      if (!this.startTime) {
	        this.startTime = new Date().getTime();
	      }
	    }
	  }]);

	  return MSEController;
	}();

	exports.default = MSEController;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MSEController = function () {
	  function MSEController() {
	    _classCallCheck(this, MSEController);

	    this.TAG = 'Mccree-plugin-mse';
	    this.type = 'plugin';
	    this.mediaSource = new window.MediaSource();
	    this._lastappand = 'audio';
	    this.mediaElement = null;
	    this.seekables = [];
	    this.mccree = null;
	    this.observer = null;
	    this.config = null;
	    this._initAppanded = false;
	    this._lastappand = 'audio';
	    //this.mediaElement = null;
	    this.lastSeek = -1;
	    this.startTime = undefined;
	    this._lastClearTime = 0;
	    this._lastCurrentTime = -1;
	  }

	  _createClass(MSEController, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.observer = mccree.observer;
	      this.config = mccree.config;
	      this.logger = mccree.logger;
	      this.observer.on('MEDIA_SEGMENT_REMUXED', this.checkState.bind(this));
	      this.observer.on('INIT_SEGMENT_REMUXED', this._onInitSegment.bind(this));
	    }

	    // 播放.

	  }, {
	    key: 'play',
	    value: function play() {
	      this.mediaElement.play();
	    }

	    // 状态检查，入口,应该是只处理e.state<3时的状态.

	  }, {
	    key: 'checkState',
	    value: function checkState() {
	      // 重载和初始化入口.    
	      if (!this._initAppanded && this.mccree.remuxBuffer.lastDts > 500 && this.mediaSource) {
	        this._onInitSegment.call(this);
	      }

	      if (this.mccree.reloading) {
	        return;
	      }
	      //this.logger.debug(this.TAG, this.mediaElement.readyState);

	      // 媒体处理入口.
	      this._onMediaSegment();

	      // 自动重载时间.
	      //this.logger.debug(this.TAG, this.mediaElement.readyState);
	      if (this.config.autoReload > 15e3 && this.mediaElement && this.mediaElement.readyState < 3 && new Date().getTime() - this.startTime - this.mediaElement.currentTime * 1e3 > this.config.autoReload) {
	        var that = this;
	        this.mccree.reload().then(function () {
	          that.startTime = undefined;
	        });
	      }

	      /*     if (this.mediaElement && this.mediaElement.readyState === 4) {
	            if(this._lastCurrentTime == -1) {
	              this._lastCurrentTime = this.mediaElement.currentTime;
	            }
	            if(this._lastCurrentTime == this.mediaElement.currentTime 
	              && this.mediaElement.currentTime <= this.mediaElement.seekable.end(0) - 5
	              && !this.mediaElement.paused
	              ) {
	              this.mediaElement.currentTime = (this.mediaElement.seekable.end(0) + this.mediaElement.seekable.start(0)) / 2;
	              this.mediaElement.play();
	              this.logger.warn(this.TAG, '跳帧至' + ((this.mediaElement.seekable.end(0) + this.mediaElement.seekable.start(0)) / 2));
	            }
	            this._lastCurrentTime = this.mediaElement.currentTime;
	          } */

	      // element.readyState状态不对，即无法播放时的处理，一律跳到最新的buffered位置.
	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.mediaElement.readyState === 2 && this.seekables.length > 1) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	        this.logger.warn(this.TAG, '追帧至' + this.seekables[this.seekables.length - 1] / 1e3);
	      }

	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.mediaElement.readyState === 1 && this.mediaElement.currentTime > 0 && this.seekables.length > 1 && false) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	        this.logger.warn(this.TAG, '追帧至' + this.seekables[this.seekables.length - 1] / 1e3);
	      }

	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.seekables.length > 1 && this.mediaElement.readyState < 3 && this.mediaElement.currentTime < this.seekables[this.seekables.length - 1] / 1e3 - 10) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	        this.logger.warn(this.TAG, '10秒卡顿检测，并追帧至' + this.seekables[this.seekables.length - 1] / 1e3);
	      }
	    }

	    // 清缓存.

	  }, {
	    key: 'clearBuffer',
	    value: function clearBuffer() {
	      if (!this.mediaElement) {
	        return;
	      }
	      if ((new Date().getTime() - this.startTime - this._lastClearTime) / 1000 < 30) {
	        return;
	      }

	      // 每30秒清一次缓存. 
	      var playTime = this.mediaElement.currentTime;
	      if (playTime - this._lastClearTime < 30) {
	        return;
	      }
	      if (this.asourceBuffer && this.vsourceBuffer && !this.vsourceBuffer.updating && !this.asourceBuffer.updating) {
	        this.asourceBuffer.remove(this._lastClearTime, playTime - 10);
	        this._lastClearTime = playTime - 10;
	        this._needCheck = 0;
	        this.logger.debug(this.TAG, this.mccree.logMsgs.CLEAR_CACHE);
	        while (this.seekables && this.seekables.length > 0 && this.seekables[0] / 1e3 < playTime - 10) {
	          this.seekables.shift();
	        }
	      }
	    }

	    // 连接资源，初始化mediaSourceObject.(关注)

	  }, {
	    key: 'attachMediaElement',
	    value: function attachMediaElement(mediaElement) {
	      this.mediaElement = mediaElement;
	      this.mediaElement.loop = true;
	      this.mediaSourceObjectURL = window.URL.createObjectURL(this.mediaSource);
	      this.mediaElement.src = this.mediaSourceObjectURL;
	      this.mediaElement.onerror = this._onError.bind(this);
	      this.mediaElement.oncanplay = this.recordStartTime.bind(this);
	      this.mediaElement.onstalled = this.checkState.bind(this);
	    }

	    // 离开资源，由于是直播，所以只会在销毁时调用.

	  }, {
	    key: 'detachMediaElement',
	    value: function detachMediaElement() {
	      if (this.mediaElement) {
	        this.mediaElement.onerror = null;
	        this.mediaElement.oncanplay = null;
	        this.mediaElement.onstalled = null;
	      }
	    }
	  }, {
	    key: 'reload',
	    value: function reload() {
	      var tempurl = this.originUrl;
	      var that = this;
	      that._lastClearTime = 0;
	      that.seekables = [];
	      that.mccree.observer.off('FRAME_DROPPED');
	      that.mccree.media.tracks = {};
	      that.remuxBuffer = {
	        audio: [],
	        video: []
	      };
	      that.mccree.loaderBuffer.clear();
	      that.mccree.demux.reset();
	      that.mccree.remux.destroy();
	      if (that.mediaSource && that.mediaSource.sourceBuffers && that.mediaSource.sourceBuffers.length > 1) {
	        that.mediaSource.removeSourceBuffer(that.asourceBuffer);
	      }
	      URL.revokeObjectURL(that.mediaElement.src);
	      that.mediaSource = new MediaSource();
	      that.mediaSourceObjectURL = window.URL.createObjectURL(that.mediaSource);
	      that.mediaElement.src = that.mediaSourceObjectURL;
	      that._initAppanded = false;
	    }

	    // 暂停.

	  }, {
	    key: 'pause',
	    value: function pause() {
	      this.mediaElement.pause();
	    }

	    // 销毁.

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.pause();
	      this.removeSourceBuffer();
	      this.detachMediaElement();
	      this.asourceBuffer = null;
	      this.vsourceBuffer = null;
	      this.mediaSource = null;
	      this._lastClearTime = 0;
	      this.seekables = [];
	    }

	    // 移除所有sourcebuffer.

	  }, {
	    key: 'removeSourceBuffer',
	    value: function removeSourceBuffer() {
	      this._initAppanded = false;
	      this.mediaElement.pause();
	      URL.revokeObjectURL(this.mediaElement.src);
	      this.asourceBuffer && this.asourceBuffer.removeEventListener('error', this._onError.bind(this));
	      if (this.mediaSource && this.mediaSource.sourceBuffers.length > 1) {
	        this.mediaSource.removeSourceBuffer(this.asourceBuffer);
	      }
	    }

	    // 记录当前时间

	  }, {
	    key: 'recordStartTime',
	    value: function recordStartTime() {
	      if (!this.startTime) {
	        this.startTime = new Date().getTime();
	      }
	    }

	    // 重置时钟.

	  }, {
	    key: 'resetTimeout',
	    value: function resetTimeout() {
	      var _this = this;

	      var that = this.mccree;
	      clearTimeout(this.mccree.timeouttimmer);
	      this.mccree.timeouttimmer = setTimeout(function () {
	        if (_this.mediaElement.readyState >= 3) {
	          that.resetTimeout();
	        } else if (that.loader.TAG !== 'FetchLoader' && that.loader.TAG !== 'MozXhrLoader') {
	          that.observer.trigger('error', that.events.errorTypes.NETWORK_ERROR, that.events.errorDetails.NOTFOUND, {});
	        }
	      }, 3000);
	    }

	    // 报错抽离.

	  }, {
	    key: '_onError',
	    value: function _onError(error) {
	      // mediaError一般会一直报。此时可能已经销毁准备换Flash。不一定还有mediaElment
	      if (this.mediaElement && this.mediaElement.error && !this.reloading) {
	        this.mccree.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	          code: 11
	        });
	      } else {
	        this.mccree.observer.trigger('error', this.events.errorTypes.OtherError, this.events.errorDetails.UNKNOWN);
	      }
	    }

	    // 初始化模块.

	  }, {
	    key: '_onInitSegment',
	    value: function _onInitSegment() {
	      this.seekables = [];
	      if (this.mediaSource.readyState !== 'open') {
	        this.mediaSource.addEventListener('sourceopen', this._appendInitSegment.bind(this));
	      } else {
	        this._appendInitSegment();
	      }
	    }

	    // 初始化模块导入.

	  }, {
	    key: '_appendInitSegment',
	    value: function _appendInitSegment() {
	      var data = this.mccree.initSegment;
	      if (this._initAppanded || !data) {
	        return;
	      }
	      this._initAppanded = true;
	      if (this.mccree.media.tracks) {
	        if (this.mccree.media.tracks.audioTrack) {
	          this.asourceBuffer = this.mediaSource.addSourceBuffer('audio/mp4;codecs=' + this.mccree.media.tracks.audioTrack.meta.codec);
	          this.asourceBuffer.appendBuffer(data.audio);
	          try {
	            var that = this;
	            this._onMediaSegment();
	            this.asourceBuffer.addEventListener('error', this._onError.bind(this));
	            this.mediaSource.addEventListener('error', this._onError.bind(this));
	            this.asourceBuffer.addEventListener('updateend', this.checkState.bind(this));
	            if (this.mccree.media && this.mccree.media.mediaInfo && this.mccree.media.mediaInfo.cdn_ip) {
	              this.mccree.cdnip = this.mccree.media.mediaInfo.cdn_ip;
	            } else if (!this.url) {
	              this.mccree.cdnip = '0.0.0.0';
	            } else {
	              var cdnip = this.url.match(/(\d+)\.(\d+)\.(\d+)\.(\d+)/);
	              this.mccree.cdnip = cdnip && cdnip[0];
	            }

	            var audiocodec = '';
	            var videocodec = '';
	            if (!this.mccree.media) {
	              audiocodec = 'Mccree uninitailized';
	            } else if (!this.mccree.media.tracks.audioTrack) {
	              audiocodec = 'ATNF';
	            } else if (!this.mccree.media.tracks.audioTrack.meta) {
	              audiocodec = 'AMNF';
	            } else {
	              audiocodec = this.mccree.media.tracks.audioTrack.meta.codec;
	            }

	            var info = {
	              mimeType: 'flv;codecs="' + audiocodec,
	              metadata: {
	                encoder: this.mccree.media ? this.mccree.media.mediaInfo.encoder : 'UNKNOWN'
	              },
	              audioChannelCount: this.mccree.media ? this.mccree.media.mediaInfo.audiochannels : 0,
	              audioDataRate: this.mccree.media ? this.mccree.media.mediaInfo.audiodatarate : 0,
	              audioSampleRate: this.mccree.media ? this.mccree.media.mediaInfo.audiosamplerate : 0,
	              fps: this.mccree.media ? this.mccree.media.tracks.videoTrack.meta.frameRate.fps : 0,
	              videoDataRate: this.mccree.media ? this.mccree.media.mediaInfo.videodatarate : 0,
	              height: this.mccree.media ? this.mccree.media.mediaInfo.height : 0,
	              width: this.mccree.media ? this.mccree.media.mediaInfo.width : 0,
	              cdnip: this.mccree.media ? this.mccree.media.mediaInfo.cdn_ip : this.mccree.cdnip
	            };
	            this.observer.trigger('media_info', info);
	            this._onMediaSegment();
	          } catch (e) {
	            this.logger.warn(this.TAG, '_appendInitSegment:' + e.message);
	            return;
	          }
	        } else {
	          return;
	        }
	      } else {
	        return;
	      }
	    }

	    // 媒体模块处理.

	  }, {
	    key: '_onMediaSegment',
	    value: function _onMediaSegment() {
	      this.clearBuffer.call(this);
	      if (this.mccree.remuxBuffer.audio.length < 1) {
	        return;
	      }

	      if (this.asourceBuffer && !this.asourceBuffer.updating) {
	        try {
	          if (!this.mediaElement.error && this.mccree.remuxBuffer.lastDts > 500) {
	            var adata = this.mccree.remuxBuffer.audio.shift();
	            this.asourceBuffer.appendBuffer(adata.data);
	            if (adata.seekable && adata.timestamp > 0) {
	              this.seekables.push(adata.timestamp);
	            }
	            this.checkState.bind(this);
	          } else if (this.mediaElement.error) {
	            this.observer.trigger('error', this.mccree.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	              code: 11
	            });
	            this.logger.warn(this.TAG, '储能槽错误：' + this.mediaElement.error.message);
	          }
	        } catch (e) {
	          if (e.code) {
	            this.observer.trigger('error', this.mccree.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	              code: 11
	            });
	          }
	          this.logger.warn(this.TAG, '储能槽错误：' + e.message);
	        }
	      }
	    }
	  }]);

	  return MSEController;
	}();

	exports.default = MSEController;

/***/ })
/******/ ]);